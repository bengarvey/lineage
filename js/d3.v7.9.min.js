// https://d3js.org v7.9.0 Copyright 2010-2023 Mike Bostock
!(function (t, n) { typeof exports === 'object' && typeof module !== 'undefined' ? n(exports) : typeof define === 'function' && define.amd ? define(['exports'], n) : n((t = typeof globalThis !== 'undefined' ? globalThis : t || self).d3 = t.d3 || {}); }(this, ((t) => {
  function n(t, n) { return t == null || n == null ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN; } function e(t, n) { return t == null || n == null ? NaN : n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN; } function r(t) { let r; let o; let a; function u(t, n, e = 0, i = t.length) { if (e < i) { if (r(n, n) !== 0) return i; do { const r = e + i >>> 1; o(t[r], n) < 0 ? e = r + 1 : i = r; } while (e < i); } return e; } return t.length !== 2 ? (r = n, o = (e, r) => n(t(e), r), a = (n, e) => t(n) - e) : (r = t === n || t === e ? t : i, o = t, a = t), { left: u, center(t, n, e = 0, r = t.length) { const i = u(t, n, e, r - 1); return i > e && a(t[i - 1], n) > -a(t[i], n) ? i - 1 : i; }, right(t, n, e = 0, i = t.length) { if (e < i) { if (r(n, n) !== 0) return i; do { const r = e + i >>> 1; o(t[r], n) <= 0 ? e = r + 1 : i = r; } while (e < i); } return e; } }; } function i() { return 0; } function o(t) { return t === null ? NaN : +t; } const a = r(n); const u = a.right; const c = a.left; const f = r(o).center; const s = u; const l = d(y); const h = d(((t) => { const n = y(t); return (t, e, r, i, o) => { n(t, e, (r <<= 2) + 0, (i <<= 2) + 0, o <<= 2), n(t, e, r + 1, i + 1, o), n(t, e, r + 2, i + 2, o), n(t, e, r + 3, i + 3, o); }; })); function d(t) { return function (n, e, r = e) { if (!((e = +e) >= 0)) throw new RangeError('invalid rx'); if (!((r = +r) >= 0)) throw new RangeError('invalid ry'); let { data: i, width: o, height: a } = n; if (!((o = Math.floor(o)) >= 0)) throw new RangeError('invalid width'); if (!((a = Math.floor(void 0 !== a ? a : i.length / o)) >= 0)) throw new RangeError('invalid height'); if (!o || !a || !e && !r) return n; const u = e && t(e); const c = r && t(r); const f = i.slice(); return u && c ? (p(u, f, i, o, a), p(u, i, f, o, a), p(u, f, i, o, a), g(c, i, f, o, a), g(c, f, i, o, a), g(c, i, f, o, a)) : u ? (p(u, i, f, o, a), p(u, f, i, o, a), p(u, i, f, o, a)) : c && (g(c, i, f, o, a), g(c, f, i, o, a), g(c, i, f, o, a)), n; }; } function p(t, n, e, r, i) { for (let o = 0, a = r * i; o < a;)t(n, e, o, o += r, 1); } function g(t, n, e, r, i) { for (let o = 0, a = r * i; o < r; ++o)t(n, e, o, o + a, r); } function y(t) { const n = Math.floor(t); if (n === t) return (function (t) { const n = 2 * t + 1; return (e, r, i, o, a) => { if (!((o -= a) >= i)) return; let u = t * r[i]; const c = a * t; for (let t = i, n = i + c; t < n; t += a)u += r[Math.min(o, t)]; for (let t = i, f = o; t <= f; t += a)u += r[Math.min(o, t + c)], e[t] = u / n, u -= r[Math.max(i, t - c)]; }; }(t)); const e = t - n; const r = 2 * t + 1; return (t, i, o, a, u) => { if (!((a -= u) >= o)) return; let c = n * i[o]; const f = u * n; const s = f + u; for (let t = o, n = o + f; t < n; t += u)c += i[Math.min(a, t)]; for (let n = o, l = a; n <= l; n += u)c += i[Math.min(a, n + f)], t[n] = (c + e * (i[Math.max(o, n - s)] + i[Math.min(a, n + s)])) / r, c -= i[Math.max(o, n - f)]; }; } function v(t, n) { let e = 0; if (void 0 === n) for (let n of t)n != null && (n = +n) >= n && ++e; else { let r = -1; for (let i of t)(i = n(i, ++r, t)) != null && (i = +i) >= i && ++e; } return e; } function _(t) { return 0 | t.length; } function b(t) { return !(t > 0); } function m(t) { return typeof t !== 'object' || 'length' in t ? t : Array.from(t); } function x(t, n) { let e; let r = 0; let i = 0; let o = 0; if (void 0 === n) for (let n of t)n != null && (n = +n) >= n && (e = n - i, i += e / ++r, o += e * (n - i)); else { let a = -1; for (let u of t)(u = n(u, ++a, t)) != null && (u = +u) >= u && (e = u - i, i += e / ++r, o += e * (u - i)); } if (r > 1) return o / (r - 1); } function w(t, n) { const e = x(t, n); return e ? Math.sqrt(e) : e; } function M(t, n) { let e; let r; if (void 0 === n) for (const n of t)n != null && (void 0 === e ? n >= n && (e = r = n) : (e > n && (e = n), r < n && (r = n))); else { let i = -1; for (let o of t)(o = n(o, ++i, t)) != null && (void 0 === e ? o >= o && (e = r = o) : (e > o && (e = o), r < o && (r = o))); } return [e, r]; } class T {
    constructor() { this._partials = new Float64Array(32), this._n = 0; }

    add(t) { const n = this._partials; let e = 0; for (let r = 0; r < this._n && r < 32; r++) { const i = n[r]; const o = t + i; const a = Math.abs(t) < Math.abs(i) ? t - (o - i) : i - (o - t); a && (n[e++] = a), t = o; } return n[e] = t, this._n = e + 1, this; }

    valueOf() { const t = this._partials; let n; let e; let r; let i = this._n; let o = 0; if (i > 0) { for (o = t[--i]; i > 0 && (n = o, e = t[--i], o = n + e, r = e - (o - n), !r););i > 0 && (r < 0 && t[i - 1] < 0 || r > 0 && t[i - 1] > 0) && (e = 2 * r, n = o + e, e == n - o && (o = n)); } return o; }
  } class InternMap extends Map {
    constructor(t, n = N) { if (super(), Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: n } }), t != null) for (const [n, e] of t) this.set(n, e); }

    get(t) { return super.get(A(this, t)); }

    has(t) { return super.has(A(this, t)); }

    set(t, n) { return super.set(S(this, t), n); }

    delete(t) { return super.delete(E(this, t)); }
  } class InternSet extends Set {
    constructor(t, n = N) { if (super(), Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: n } }), t != null) for (const n of t) this.add(n); }

    has(t) { return super.has(A(this, t)); }

    add(t) { return super.add(S(this, t)); }

    delete(t) { return super.delete(E(this, t)); }
  } function A({ _intern: t, _key: n }, e) { const r = n(e); return t.has(r) ? t.get(r) : e; } function S({ _intern: t, _key: n }, e) { const r = n(e); return t.has(r) ? t.get(r) : (t.set(r, e), e); } function E({ _intern: t, _key: n }, e) { const r = n(e); return t.has(r) && (e = t.get(r), t.delete(r)), e; } function N(t) { return t !== null && typeof t === 'object' ? t.valueOf() : t; } function k(t) { return t; } function C(t, ...n) { return F(t, k, k, n); } function P(t, ...n) { return F(t, Array.from, k, n); } function z(t, n) { for (let e = 1, r = n.length; e < r; ++e)t = t.flatMap(((t) => t.pop().map((([n, e]) => [...t, n, e])))); return t; } function $(t, n, ...e) { return F(t, k, n, e); } function D(t, n, ...e) { return F(t, Array.from, n, e); } function R(t) { if (t.length !== 1) throw new Error('duplicate key'); return t[0]; } function F(t, n, e, r) {
    return (function t(i, o) {
      if (o >= r.length) return e(i); const a = new InternMap(); const
        u = r[o++]; let c = -1; for (const t of i) { const n = u(t, ++c, i); const e = a.get(n); e ? e.push(t) : a.set(n, [t]); } for (const [n, e] of a)a.set(n, t(e, o)); return n(a);
    }(t, 0));
  } function q(t, n) { return Array.from(n, ((n) => t[n])); } function U(t, ...n) { if (typeof t[Symbol.iterator] !== 'function') throw new TypeError('values is not iterable'); t = Array.from(t); let [e] = n; if (e && e.length !== 2 || n.length > 1) { const r = Uint32Array.from(t, ((t, n) => n)); return n.length > 1 ? (n = n.map(((n) => t.map(n))), r.sort(((t, e) => { for (const r of n) { const n = O(r[t], r[e]); if (n) return n; } }))) : (e = t.map(e), r.sort(((t, n) => O(e[t], e[n])))), q(t, r); } return t.sort(I(e)); } function I(t = n) { if (t === n) return O; if (typeof t !== 'function') throw new TypeError('compare is not a function'); return (n, e) => { const r = t(n, e); return r || r === 0 ? r : (t(e, e) === 0) - (t(n, n) === 0); }; } function O(t, n) { return (t == null || !(t >= t)) - (n == null || !(n >= n)) || (t < n ? -1 : t > n ? 1 : 0); } const B = Array.prototype.slice; function Y(t) { return () => t; } const L = Math.sqrt(50); const j = Math.sqrt(10); const H = Math.sqrt(2); function X(t, n, e) { const r = (n - t) / Math.max(0, e); const i = Math.floor(Math.log10(r)); const o = r / 10 ** i; const a = o >= L ? 10 : o >= j ? 5 : o >= H ? 2 : 1; let u; let c; let f; return i < 0 ? (f = 10 ** -i / a, u = Math.round(t * f), c = Math.round(n * f), u / f < t && ++u, c / f > n && --c, f = -f) : (f = 10 ** i * a, u = Math.round(t / f), c = Math.round(n / f), u * f < t && ++u, c * f > n && --c), c < u && e >= 0.5 && e < 2 ? X(t, n, 2 * e) : [u, c, f]; } function G(t, n, e) { if (!((e = +e) > 0)) return []; if ((t = +t) === (n = +n)) return [t]; const r = n < t; const [i, o, a] = r ? X(n, t, e) : X(t, n, e); if (!(o >= i)) return []; const u = o - i + 1; const c = new Array(u); if (r) if (a < 0) for (let t = 0; t < u; ++t)c[t] = (o - t) / -a; else for (let t = 0; t < u; ++t)c[t] = (o - t) * a; else if (a < 0) for (let t = 0; t < u; ++t)c[t] = (i + t) / -a; else for (let t = 0; t < u; ++t)c[t] = (i + t) * a; return c; } function V(t, n, e) { return X(t = +t, n = +n, e = +e)[2]; } function W(t, n, e) { e = +e; const r = (n = +n) < (t = +t); const i = r ? V(n, t, e) : V(t, n, e); return (r ? -1 : 1) * (i < 0 ? 1 / -i : i); } function Z(t, n, e) { let r; for (;;) { const i = V(t, n, e); if (i === r || i === 0 || !isFinite(i)) return [t, n]; i > 0 ? (t = Math.floor(t / i) * i, n = Math.ceil(n / i) * i) : i < 0 && (t = Math.ceil(t * i) / i, n = Math.floor(n * i) / i), r = i; } } function K(t) { return Math.max(1, Math.ceil(Math.log(v(t)) / Math.LN2) + 1); } function Q() { let t = k; let n = M; let e = K; function r(r) { Array.isArray(r) || (r = Array.from(r)); let i; let o; let a; const u = r.length; const c = new Array(u); for (i = 0; i < u; ++i)c[i] = t(r[i], i, r); const f = n(c); let l = f[0]; let h = f[1]; let d = e(c, l, h); if (!Array.isArray(d)) { const t = h; const e = +d; if (n === M && ([l, h] = Z(l, h, e)), (d = G(l, h, e))[0] <= l && (a = V(l, h, e)), d[d.length - 1] >= h) if (t >= h && n === M) { const t = V(l, h, e); isFinite(t) && (t > 0 ? h = (Math.floor(h / t) + 1) * t : t < 0 && (h = (Math.ceil(h * -t) + 1) / -t)); } else d.pop(); } for (var p = d.length, g = 0, y = p; d[g] <= l;)++g; for (;d[y - 1] > h;)--y; (g || y < p) && (d = d.slice(g, y), p = y - g); let v; const _ = new Array(p + 1); for (i = 0; i <= p; ++i)(v = _[i] = []).x0 = i > 0 ? d[i - 1] : l, v.x1 = i < p ? d[i] : h; if (isFinite(a)) { if (a > 0) for (i = 0; i < u; ++i)(o = c[i]) != null && l <= o && o <= h && _[Math.min(p, Math.floor((o - l) / a))].push(r[i]); else if (a < 0) for (i = 0; i < u; ++i) if ((o = c[i]) != null && l <= o && o <= h) { const t = Math.floor((l - o) * a); _[Math.min(p, t + (d[t] <= o))].push(r[i]); } } else for (i = 0; i < u; ++i)(o = c[i]) != null && l <= o && o <= h && _[s(d, o, 0, p)].push(r[i]); return _; } return r.value = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : Y(n), r) : t; }, r.domain = function (t) { return arguments.length ? (n = typeof t === 'function' ? t : Y([t[0], t[1]]), r) : n; }, r.thresholds = function (t) { return arguments.length ? (e = typeof t === 'function' ? t : Y(Array.isArray(t) ? B.call(t) : t), r) : e; }, r; } function J(t, n) { let e; if (void 0 === n) for (const n of t)n != null && (e < n || void 0 === e && n >= n) && (e = n); else { let r = -1; for (let i of t)(i = n(i, ++r, t)) != null && (e < i || void 0 === e && i >= i) && (e = i); } return e; } function tt(t, n) { let e; let r = -1; let i = -1; if (void 0 === n) for (const n of t)++i, n != null && (e < n || void 0 === e && n >= n) && (e = n, r = i); else for (let o of t)(o = n(o, ++i, t)) != null && (e < o || void 0 === e && o >= o) && (e = o, r = i); return r; } function nt(t, n) { let e; if (void 0 === n) for (const n of t)n != null && (e > n || void 0 === e && n >= n) && (e = n); else { let r = -1; for (let i of t)(i = n(i, ++r, t)) != null && (e > i || void 0 === e && i >= i) && (e = i); } return e; } function et(t, n) { let e; let r = -1; let i = -1; if (void 0 === n) for (const n of t)++i, n != null && (e > n || void 0 === e && n >= n) && (e = n, r = i); else for (let o of t)(o = n(o, ++i, t)) != null && (e > o || void 0 === e && o >= o) && (e = o, r = i); return r; } function rt(t, n, e = 0, r = 1 / 0, i) { if (n = Math.floor(n), e = Math.floor(Math.max(0, e)), r = Math.floor(Math.min(t.length - 1, r)), !(e <= n && n <= r)) return t; for (i = void 0 === i ? O : I(i); r > e;) { if (r - e > 600) { const o = r - e + 1; const a = n - e + 1; const u = Math.log(o); const c = 0.5 * Math.exp(2 * u / 3); const f = 0.5 * Math.sqrt(u * c * (o - c) / o) * (a - o / 2 < 0 ? -1 : 1); rt(t, n, Math.max(e, Math.floor(n - a * c / o + f)), Math.min(r, Math.floor(n + (o - a) * c / o + f)), i); } const o = t[n]; let a = e; let u = r; for (it(t, e, n), i(t[r], o) > 0 && it(t, e, r); a < u;) { for (it(t, a, u), ++a, --u; i(t[a], o) < 0;)++a; for (;i(t[u], o) > 0;)--u; }i(t[e], o) === 0 ? it(t, e, u) : (++u, it(t, u, r)), u <= n && (e = u + 1), n <= u && (r = u - 1); } return t; } function it(t, n, e) { const r = t[n]; t[n] = t[e], t[e] = r; } function ot(t, e = n) { let r; let i = !1; if (e.length === 1) { let o; for (const a of t) { const t = e(a); (i ? n(t, o) > 0 : n(t, t) === 0) && (r = a, o = t, i = !0); } } else for (const n of t)(i ? e(n, r) > 0 : e(n, n) === 0) && (r = n, i = !0); return r; } function at(t, n, e) { if (t = Float64Array.from(function* (t, n) { if (void 0 === n) for (let n of t)n != null && (n = +n) >= n && (yield n); else { let e = -1; for (let r of t)(r = n(r, ++e, t)) != null && (r = +r) >= r && (yield r); } }(t, e)), (r = t.length) && !isNaN(n = +n)) { if (n <= 0 || r < 2) return nt(t); if (n >= 1) return J(t); var r; const i = (r - 1) * n; const o = Math.floor(i); const a = J(rt(t, o).subarray(0, o + 1)); return a + (nt(t.subarray(o + 1)) - a) * (i - o); } } function ut(t, n, e = o) { if ((r = t.length) && !isNaN(n = +n)) { if (n <= 0 || r < 2) return +e(t[0], 0, t); if (n >= 1) return +e(t[r - 1], r - 1, t); var r; const i = (r - 1) * n; const a = Math.floor(i); const u = +e(t[a], a, t); return u + (+e(t[a + 1], a + 1, t) - u) * (i - a); } } function ct(t, n, e = o) { if (!isNaN(n = +n)) { if (r = Float64Array.from(t, ((n, r) => o(e(t[r], r, t)))), n <= 0) return et(r); if (n >= 1) return tt(r); let r; const i = Uint32Array.from(t, ((t, n) => n)); const a = r.length - 1; let u = Math.floor(a * n); return rt(i, u, 0, a, ((t, n) => O(r[t], r[n]))), (u = ot(i.subarray(0, u + 1), ((t) => r[t]))) >= 0 ? u : -1; } } function ft(t) { return Array.from(function* (t) { for (const n of t) yield* n; }(t)); } function st(t, n) { return [t, n]; } function lt(t, n, e) { t = +t, n = +n, e = (i = arguments.length) < 2 ? (n = t, t = 0, 1) : i < 3 ? 1 : +e; for (var r = -1, i = 0 | Math.max(0, Math.ceil((n - t) / e)), o = new Array(i); ++r < i;)o[r] = t + r * e; return o; } function ht(t, e = n) { if (e.length === 1) return et(t, e); let r; let i = -1; let o = -1; for (const n of t)++o, (i < 0 ? e(n, n) === 0 : e(n, r) < 0) && (r = n, i = o); return i; } const dt = pt(Math.random); function pt(t) { return function (n, e = 0, r = n.length) { let i = r - (e = +e); for (;i;) { const r = t() * i-- | 0; const o = n[i + e]; n[i + e] = n[r + e], n[r + e] = o; } return n; }; } function gt(t) { if (!(i = t.length)) return []; for (var n = -1, e = nt(t, yt), r = new Array(e); ++n < e;) for (var i, o = -1, a = r[n] = new Array(i); ++o < i;)a[o] = t[o][n]; return r; } function yt(t) { return t.length; } function vt(t) { return t instanceof InternSet ? t : new InternSet(t); } function _t(t, n) { const e = t[Symbol.iterator](); const r = new Set(); for (const t of n) { const n = bt(t); if (r.has(n)) continue; let i; let o; for (;({ value: i, done: o } = e.next());) { if (o) return !1; const t = bt(i); if (r.add(t), Object.is(n, t)) break; } } return !0; } function bt(t) { return t !== null && typeof t === 'object' ? t.valueOf() : t; } function mt(t) { return t; } const xt = 1; const wt = 2; const Mt = 3; const Tt = 4; const At = 1e-6; function St(t) { return `translate(${t},0)`; } function Et(t) { return `translate(0,${t})`; } function Nt(t) { return (n) => +t(n); } function kt(t, n) { return n = Math.max(0, t.bandwidth() - 2 * n) / 2, t.round() && (n = Math.round(n)), (e) => +t(e) + n; } function Ct() { return !this.__axis; } function Pt(t, n) {
    let e = []; let r = null; let i = null; let o = 6; let a = 6; let u = 3; let c = typeof window !== 'undefined' && window.devicePixelRatio > 1 ? 0 : 0.5; const f = t === xt || t === Tt ? -1 : 1; const s = t === Tt || t === wt ? 'x' : 'y'; const l = t === xt || t === Mt ? St : Et; function h(h) {
      const d = r == null ? n.ticks ? n.ticks.apply(n, e) : n.domain() : r; const p = i == null ? n.tickFormat ? n.tickFormat.apply(n, e) : mt : i; const g = Math.max(o, 0) + u; const y = n.range(); const v = +y[0] + c; const _ = +y[y.length - 1] + c; const b = (n.bandwidth ? kt : Nt)(n.copy(), c); const m = h.selection ? h.selection() : h; let x = m.selectAll('.domain').data([null]); let w = m.selectAll('.tick').data(d, n).order(); let M = w.exit(); const T = w.enter().append('g').attr('class', 'tick'); let A = w.select('line'); let S = w.select('text'); x = x.merge(x.enter().insert('path', '.tick').attr('class', 'domain').attr('stroke', 'currentColor')), w = w.merge(T), A = A.merge(T.append('line').attr('stroke', 'currentColor').attr(`${s}2`, f * o)), S = S.merge(T.append('text').attr('fill', 'currentColor').attr(s, f * g).attr('dy', t === xt ? '0em' : t === Mt ? '0.71em' : '0.32em')), h !== m && (x = x.transition(h), w = w.transition(h), A = A.transition(h), S = S.transition(h), M = M.transition(h).attr('opacity', At).attr('transform', (function (t) { return isFinite(t = b(t)) ? l(t + c) : this.getAttribute('transform'); })), T.attr('opacity', At).attr('transform', (function (t) { let n = this.parentNode.__axis; return l((n && isFinite(n = n(t)) ? n : b(t)) + c); }))), M.remove(), x.attr('d', t === Tt || t === wt ? a ? `M${f * a},${v}H${c}V${_}H${f * a}` : `M${c},${v}V${_}` : a ? `M${v},${f * a}V${c}H${_}V${f * a}` : `M${v},${c}H${_}`), w.attr('opacity', 1).attr('transform', ((t) => l(b(t) + c))), A.attr(`${s}2`, f * o), S.attr(s, f * g).text(p), m.filter(Ct).attr('fill', 'none').attr('font-size', 10).attr('font-family', 'sans-serif')
        .attr('text-anchor', t === wt ? 'start' : t === Tt ? 'end' : 'middle'), m.each((function () { this.__axis = b; }));
    } return h.scale = function (t) { return arguments.length ? (n = t, h) : n; }, h.ticks = function () { return e = Array.from(arguments), h; }, h.tickArguments = function (t) { return arguments.length ? (e = t == null ? [] : Array.from(t), h) : e.slice(); }, h.tickValues = function (t) { return arguments.length ? (r = t == null ? null : Array.from(t), h) : r && r.slice(); }, h.tickFormat = function (t) { return arguments.length ? (i = t, h) : i; }, h.tickSize = function (t) { return arguments.length ? (o = a = +t, h) : o; }, h.tickSizeInner = function (t) { return arguments.length ? (o = +t, h) : o; }, h.tickSizeOuter = function (t) { return arguments.length ? (a = +t, h) : a; }, h.tickPadding = function (t) { return arguments.length ? (u = +t, h) : u; }, h.offset = function (t) { return arguments.length ? (c = +t, h) : c; }, h;
  } const zt = { value: () => {} }; function $t() { for (var t, n = 0, e = arguments.length, r = {}; n < e; ++n) { if (!(t = `${arguments[n]}`) || t in r || /[\s.]/.test(t)) throw new Error(`illegal type: ${t}`); r[t] = []; } return new Dt(r); } function Dt(t) { this._ = t; } function Rt(t, n) { for (var e, r = 0, i = t.length; r < i; ++r) if ((e = t[r]).name === n) return e.value; } function Ft(t, n, e) { for (let r = 0, i = t.length; r < i; ++r) if (t[r].name === n) { t[r] = zt, t = t.slice(0, r).concat(t.slice(r + 1)); break; } return e != null && t.push({ name: n, value: e }), t; }Dt.prototype = $t.prototype = {
    constructor: Dt, on(t, n) { let e; let r; const i = this._; const o = (r = i, (`${t}`).trim().split(/^|\s+/).map(((t) => { let n = ''; const e = t.indexOf('.'); if (e >= 0 && (n = t.slice(e + 1), t = t.slice(0, e)), t && !r.hasOwnProperty(t)) throw new Error(`unknown type: ${t}`); return { type: t, name: n }; }))); let a = -1; const u = o.length; if (!(arguments.length < 2)) { if (n != null && typeof n !== 'function') throw new Error(`invalid callback: ${n}`); for (;++a < u;) if (e = (t = o[a]).type)i[e] = Ft(i[e], t.name, n); else if (n == null) for (e in i)i[e] = Ft(i[e], t.name, null); return this; } for (;++a < u;) if ((e = (t = o[a]).type) && (e = Rt(i[e], t.name))) return e; }, copy() { const t = {}; const n = this._; for (const e in n)t[e] = n[e].slice(); return new Dt(t); }, call(t, n) { if ((e = arguments.length - 2) > 0) for (var e, r, i = new Array(e), o = 0; o < e; ++o)i[o] = arguments[o + 2]; if (!this._.hasOwnProperty(t)) throw new Error(`unknown type: ${t}`); for (o = 0, e = (r = this._[t]).length; o < e; ++o)r[o].value.apply(n, i); }, apply(t, n, e) { if (!this._.hasOwnProperty(t)) throw new Error(`unknown type: ${t}`); for (let r = this._[t], i = 0, o = r.length; i < o; ++i)r[i].value.apply(n, e); },
  }; const qt = 'http://www.w3.org/1999/xhtml'; const Ut = {
    svg: 'http://www.w3.org/2000/svg', xhtml: qt, xlink: 'http://www.w3.org/1999/xlink', xml: 'http://www.w3.org/XML/1998/namespace', xmlns: 'http://www.w3.org/2000/xmlns/',
  }; function It(t) { let n = t += ''; const e = n.indexOf(':'); return e >= 0 && (n = t.slice(0, e)) !== 'xmlns' && (t = t.slice(e + 1)), Ut.hasOwnProperty(n) ? { space: Ut[n], local: t } : t; } function Ot(t) { return function () { const n = this.ownerDocument; const e = this.namespaceURI; return e === qt && n.documentElement.namespaceURI === qt ? n.createElement(t) : n.createElementNS(e, t); }; } function Bt(t) { return function () { return this.ownerDocument.createElementNS(t.space, t.local); }; } function Yt(t) { const n = It(t); return (n.local ? Bt : Ot)(n); } function Lt() {} function jt(t) { return t == null ? Lt : function () { return this.querySelector(t); }; } function Ht(t) { return t == null ? [] : Array.isArray(t) ? t : Array.from(t); } function Xt() { return []; } function Gt(t) { return t == null ? Xt : function () { return this.querySelectorAll(t); }; } function Vt(t) { return function () { return this.matches(t); }; } function Wt(t) { return function (n) { return n.matches(t); }; } const Zt = Array.prototype.find; function Kt() { return this.firstElementChild; } const Qt = Array.prototype.filter; function Jt() { return Array.from(this.children); } function tn(t) { return new Array(t.length); } function nn(t, n) { this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = n; } function en(t, n, e, r, i, o) { for (var a, u = 0, c = n.length, f = o.length; u < f; ++u)(a = n[u]) ? (a.__data__ = o[u], r[u] = a) : e[u] = new nn(t, o[u]); for (;u < c; ++u)(a = n[u]) && (i[u] = a); } function rn(t, n, e, r, i, o, a) { let u; let c; let f; const s = new Map(); const l = n.length; const h = o.length; const d = new Array(l); for (u = 0; u < l; ++u)(c = n[u]) && (d[u] = f = `${a.call(c, c.__data__, u, n)}`, s.has(f) ? i[u] = c : s.set(f, c)); for (u = 0; u < h; ++u)f = `${a.call(t, o[u], u, o)}`, (c = s.get(f)) ? (r[u] = c, c.__data__ = o[u], s.delete(f)) : e[u] = new nn(t, o[u]); for (u = 0; u < l; ++u)(c = n[u]) && s.get(d[u]) === c && (i[u] = c); } function on(t) { return t.__data__; } function an(t) { return typeof t === 'object' && 'length' in t ? t : Array.from(t); } function un(t, n) { return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN; } function cn(t) { return function () { this.removeAttribute(t); }; } function fn(t) { return function () { this.removeAttributeNS(t.space, t.local); }; } function sn(t, n) { return function () { this.setAttribute(t, n); }; } function ln(t, n) { return function () { this.setAttributeNS(t.space, t.local, n); }; } function hn(t, n) { return function () { const e = n.apply(this, arguments); e == null ? this.removeAttribute(t) : this.setAttribute(t, e); }; } function dn(t, n) { return function () { const e = n.apply(this, arguments); e == null ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, e); }; } function pn(t) { return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView; } function gn(t) { return function () { this.style.removeProperty(t); }; } function yn(t, n, e) { return function () { this.style.setProperty(t, n, e); }; } function vn(t, n, e) { return function () { const r = n.apply(this, arguments); r == null ? this.style.removeProperty(t) : this.style.setProperty(t, r, e); }; } function _n(t, n) { return t.style.getPropertyValue(n) || pn(t).getComputedStyle(t, null).getPropertyValue(n); } function bn(t) { return function () { delete this[t]; }; } function mn(t, n) { return function () { this[t] = n; }; } function xn(t, n) { return function () { const e = n.apply(this, arguments); e == null ? delete this[t] : this[t] = e; }; } function wn(t) { return t.trim().split(/^|\s+/); } function Mn(t) { return t.classList || new Tn(t); } function Tn(t) { this._node = t, this._names = wn(t.getAttribute('class') || ''); } function An(t, n) { for (let e = Mn(t), r = -1, i = n.length; ++r < i;)e.add(n[r]); } function Sn(t, n) { for (let e = Mn(t), r = -1, i = n.length; ++r < i;)e.remove(n[r]); } function En(t) { return function () { An(this, t); }; } function Nn(t) { return function () { Sn(this, t); }; } function kn(t, n) { return function () { (n.apply(this, arguments) ? An : Sn)(this, t); }; } function Cn() { this.textContent = ''; } function Pn(t) { return function () { this.textContent = t; }; } function zn(t) { return function () { const n = t.apply(this, arguments); this.textContent = n == null ? '' : n; }; } function $n() { this.innerHTML = ''; } function Dn(t) { return function () { this.innerHTML = t; }; } function Rn(t) { return function () { const n = t.apply(this, arguments); this.innerHTML = n == null ? '' : n; }; } function Fn() { this.nextSibling && this.parentNode.appendChild(this); } function qn() { this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild); } function Un() { return null; } function In() { const t = this.parentNode; t && t.removeChild(this); } function On() { const t = this.cloneNode(!1); const n = this.parentNode; return n ? n.insertBefore(t, this.nextSibling) : t; } function Bn() { const t = this.cloneNode(!0); const n = this.parentNode; return n ? n.insertBefore(t, this.nextSibling) : t; } function Yn(t) { return function () { const n = this.__on; if (n) { for (var e, r = 0, i = -1, o = n.length; r < o; ++r)e = n[r], t.type && e.type !== t.type || e.name !== t.name ? n[++i] = e : this.removeEventListener(e.type, e.listener, e.options); ++i ? n.length = i : delete this.__on; } }; } function Ln(t, n, e) {
    return function () {
      let r; const i = this.__on; const o = (function (t) { return function (n) { t.call(this, n, this.__data__); }; }(n)); if (i) for (let a = 0, u = i.length; a < u; ++a) if ((r = i[a]).type === t.type && r.name === t.name) return this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = o, r.options = e), void (r.value = n); this.addEventListener(t.type, o, e), r = {
        type: t.type, name: t.name, value: n, listener: o, options: e,
      }, i ? i.push(r) : this.__on = [r];
    };
  } function jn(t, n, e) { const r = pn(t); let i = r.CustomEvent; typeof i === 'function' ? i = new i(n, e) : (i = r.document.createEvent('Event'), e ? (i.initEvent(n, e.bubbles, e.cancelable), i.detail = e.detail) : i.initEvent(n, !1, !1)), t.dispatchEvent(i); } function Hn(t, n) { return function () { return jn(this, t, n); }; } function Xn(t, n) { return function () { return jn(this, t, n.apply(this, arguments)); }; }nn.prototype = {
    constructor: nn, appendChild(t) { return this._parent.insertBefore(t, this._next); }, insertBefore(t, n) { return this._parent.insertBefore(t, n); }, querySelector(t) { return this._parent.querySelector(t); }, querySelectorAll(t) { return this._parent.querySelectorAll(t); },
  }, Tn.prototype = { add(t) { this._names.indexOf(t) < 0 && (this._names.push(t), this._node.setAttribute('class', this._names.join(' '))); }, remove(t) { const n = this._names.indexOf(t); n >= 0 && (this._names.splice(n, 1), this._node.setAttribute('class', this._names.join(' '))); }, contains(t) { return this._names.indexOf(t) >= 0; } }; const Gn = [null]; function Vn(t, n) { this._groups = t, this._parents = n; } function Wn() { return new Vn([[document.documentElement]], Gn); } function Zn(t) { return typeof t === 'string' ? new Vn([[document.querySelector(t)]], [document.documentElement]) : new Vn([[t]], Gn); }Vn.prototype = Wn.prototype = {
    constructor: Vn, select(t) { typeof t !== 'function' && (t = jt(t)); for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i) for (var o, a, u = n[i], c = u.length, f = r[i] = new Array(c), s = 0; s < c; ++s)(o = u[s]) && (a = t.call(o, o.__data__, s, u)) && ('__data__' in o && (a.__data__ = o.__data__), f[s] = a); return new Vn(r, this._parents); }, selectAll(t) { t = typeof t === 'function' ? (function (t) { return function () { return Ht(t.apply(this, arguments)); }; }(t)) : Gt(t); for (var n = this._groups, e = n.length, r = [], i = [], o = 0; o < e; ++o) for (var a, u = n[o], c = u.length, f = 0; f < c; ++f)(a = u[f]) && (r.push(t.call(a, a.__data__, f, u)), i.push(a)); return new Vn(r, i); }, selectChild(t) { return this.select(t == null ? Kt : (function (t) { return function () { return Zt.call(this.children, t); }; }(typeof t === 'function' ? t : Wt(t)))); }, selectChildren(t) { return this.selectAll(t == null ? Jt : (function (t) { return function () { return Qt.call(this.children, t); }; }(typeof t === 'function' ? t : Wt(t)))); }, filter(t) { typeof t !== 'function' && (t = Vt(t)); for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i) for (var o, a = n[i], u = a.length, c = r[i] = [], f = 0; f < u; ++f)(o = a[f]) && t.call(o, o.__data__, f, a) && c.push(o); return new Vn(r, this._parents); }, data(t, n) { if (!arguments.length) return Array.from(this, on); const e = n ? rn : en; const r = this._parents; const i = this._groups; typeof t !== 'function' && (t = (function (t) { return function () { return t; }; }(t))); for (var o = i.length, a = new Array(o), u = new Array(o), c = new Array(o), f = 0; f < o; ++f) { const s = r[f]; const l = i[f]; const h = l.length; const d = an(t.call(s, s && s.__data__, f, r)); const p = d.length; const g = u[f] = new Array(p); const y = a[f] = new Array(p); e(s, l, g, y, c[f] = new Array(h), d, n); for (var v, _, b = 0, m = 0; b < p; ++b) if (v = g[b]) { for (b >= m && (m = b + 1); !(_ = y[m]) && ++m < p;);v._next = _ || null; } } return (a = new Vn(a, r))._enter = u, a._exit = c, a; }, enter() { return new Vn(this._enter || this._groups.map(tn), this._parents); }, exit() { return new Vn(this._exit || this._groups.map(tn), this._parents); }, join(t, n, e) { let r = this.enter(); let i = this; const o = this.exit(); return typeof t === 'function' ? (r = t(r)) && (r = r.selection()) : r = r.append(`${t}`), n != null && (i = n(i)) && (i = i.selection()), e == null ? o.remove() : e(o), r && i ? r.merge(i).order() : i; }, merge(t) { for (var n = t.selection ? t.selection() : t, e = this._groups, r = n._groups, i = e.length, o = r.length, a = Math.min(i, o), u = new Array(i), c = 0; c < a; ++c) for (var f, s = e[c], l = r[c], h = s.length, d = u[c] = new Array(h), p = 0; p < h; ++p)(f = s[p] || l[p]) && (d[p] = f); for (;c < i; ++c)u[c] = e[c]; return new Vn(u, this._parents); }, selection() { return this; }, order() { for (let t = this._groups, n = -1, e = t.length; ++n < e;) for (var r, i = t[n], o = i.length - 1, a = i[o]; --o >= 0;)(r = i[o]) && (a && 4 ^ r.compareDocumentPosition(a) && a.parentNode.insertBefore(r, a), a = r); return this; }, sort(t) { function n(n, e) { return n && e ? t(n.__data__, e.__data__) : !n - !e; }t || (t = un); for (var e = this._groups, r = e.length, i = new Array(r), o = 0; o < r; ++o) { for (var a, u = e[o], c = u.length, f = i[o] = new Array(c), s = 0; s < c; ++s)(a = u[s]) && (f[s] = a); f.sort(n); } return new Vn(i, this._parents).order(); }, call() { const t = arguments[0]; return arguments[0] = this, t.apply(null, arguments), this; }, nodes() { return Array.from(this); }, node() { for (let t = this._groups, n = 0, e = t.length; n < e; ++n) for (let r = t[n], i = 0, o = r.length; i < o; ++i) { const a = r[i]; if (a) return a; } return null; }, size() { let t = 0; for (const n of this)++t; return t; }, empty() { return !this.node(); }, each(t) { for (let n = this._groups, e = 0, r = n.length; e < r; ++e) for (var i, o = n[e], a = 0, u = o.length; a < u; ++a)(i = o[a]) && t.call(i, i.__data__, a, o); return this; }, attr(t, n) { const e = It(t); if (arguments.length < 2) { const r = this.node(); return e.local ? r.getAttributeNS(e.space, e.local) : r.getAttribute(e); } return this.each((n == null ? e.local ? fn : cn : typeof n === 'function' ? e.local ? dn : hn : e.local ? ln : sn)(e, n)); }, style(t, n, e) { return arguments.length > 1 ? this.each((n == null ? gn : typeof n === 'function' ? vn : yn)(t, n, e == null ? '' : e)) : _n(this.node(), t); }, property(t, n) { return arguments.length > 1 ? this.each((n == null ? bn : typeof n === 'function' ? xn : mn)(t, n)) : this.node()[t]; }, classed(t, n) { const e = wn(`${t}`); if (arguments.length < 2) { for (let r = Mn(this.node()), i = -1, o = e.length; ++i < o;) if (!r.contains(e[i])) return !1; return !0; } return this.each((typeof n === 'function' ? kn : n ? En : Nn)(e, n)); }, text(t) { return arguments.length ? this.each(t == null ? Cn : (typeof t === 'function' ? zn : Pn)(t)) : this.node().textContent; }, html(t) { return arguments.length ? this.each(t == null ? $n : (typeof t === 'function' ? Rn : Dn)(t)) : this.node().innerHTML; }, raise() { return this.each(Fn); }, lower() { return this.each(qn); }, append(t) { const n = typeof t === 'function' ? t : Yt(t); return this.select((function () { return this.appendChild(n.apply(this, arguments)); })); }, insert(t, n) { const e = typeof t === 'function' ? t : Yt(t); const r = n == null ? Un : typeof n === 'function' ? n : jt(n); return this.select((function () { return this.insertBefore(e.apply(this, arguments), r.apply(this, arguments) || null); })); }, remove() { return this.each(In); }, clone(t) { return this.select(t ? Bn : On); }, datum(t) { return arguments.length ? this.property('__data__', t) : this.node().__data__; }, on(t, n, e) { let r; let i; const o = (function (t) { return t.trim().split(/^|\s+/).map(((t) => { let n = ''; const e = t.indexOf('.'); return e >= 0 && (n = t.slice(e + 1), t = t.slice(0, e)), { type: t, name: n }; })); }(`${t}`)); const a = o.length; if (!(arguments.length < 2)) { for (u = n ? Ln : Yn, r = 0; r < a; ++r) this.each(u(o[r], n, e)); return this; } var u = this.node().__on; if (u) for (var c, f = 0, s = u.length; f < s; ++f) for (r = 0, c = u[f]; r < a; ++r) if ((i = o[r]).type === c.type && i.name === c.name) return c.value; }, dispatch(t, n) { return this.each((typeof n === 'function' ? Xn : Hn)(t, n)); }, * [Symbol.iterator]() { for (let t = this._groups, n = 0, e = t.length; n < e; ++n) for (var r, i = t[n], o = 0, a = i.length; o < a; ++o)(r = i[o]) && (yield r); },
  }; let Kn = 0; function Qn() { return new Jn(); } function Jn() { this._ = `@${(++Kn).toString(36)}`; } function te(t) { let n; for (;n = t.sourceEvent;)t = n; return t; } function ne(t, n) { if (t = te(t), void 0 === n && (n = t.currentTarget), n) { const e = n.ownerSVGElement || n; if (e.createSVGPoint) { let r = e.createSVGPoint(); return r.x = t.clientX, r.y = t.clientY, [(r = r.matrixTransform(n.getScreenCTM().inverse())).x, r.y]; } if (n.getBoundingClientRect) { const i = n.getBoundingClientRect(); return [t.clientX - i.left - n.clientLeft, t.clientY - i.top - n.clientTop]; } } return [t.pageX, t.pageY]; }Jn.prototype = Qn.prototype = {
    constructor: Jn, get(t) { for (var n = this._; !(n in t);) if (!(t = t.parentNode)) return; return t[n]; }, set(t, n) { return t[this._] = n; }, remove(t) { return this._ in t && delete t[this._]; }, toString() { return this._; },
  }; const ee = { passive: !1 }; const re = { capture: !0, passive: !1 }; function ie(t) { t.stopImmediatePropagation(); } function oe(t) { t.preventDefault(), t.stopImmediatePropagation(); } function ae(t) { const n = t.document.documentElement; const e = Zn(t).on('dragstart.drag', oe, re); 'onselectstart' in n ? e.on('selectstart.drag', oe, re) : (n.__noselect = n.style.MozUserSelect, n.style.MozUserSelect = 'none'); } function ue(t, n) { const e = t.document.documentElement; const r = Zn(t).on('dragstart.drag', null); n && (r.on('click.drag', oe, re), setTimeout((() => { r.on('click.drag', null); }), 0)), 'onselectstart' in e ? r.on('selectstart.drag', null) : (e.style.MozUserSelect = e.__noselect, delete e.__noselect); } const ce = (t) => () => t; function fe(t, {
    sourceEvent: n, subject: e, target: r, identifier: i, active: o, x: a, y: u, dx: c, dy: f, dispatch: s,
  }) {
    Object.defineProperties(this, {
      type: { value: t, enumerable: !0, configurable: !0 }, sourceEvent: { value: n, enumerable: !0, configurable: !0 }, subject: { value: e, enumerable: !0, configurable: !0 }, target: { value: r, enumerable: !0, configurable: !0 }, identifier: { value: i, enumerable: !0, configurable: !0 }, active: { value: o, enumerable: !0, configurable: !0 }, x: { value: a, enumerable: !0, configurable: !0 }, y: { value: u, enumerable: !0, configurable: !0 }, dx: { value: c, enumerable: !0, configurable: !0 }, dy: { value: f, enumerable: !0, configurable: !0 }, _: { value: s },
    });
  } function se(t) { return !t.ctrlKey && !t.button; } function le() { return this.parentNode; } function he(t, n) { return n == null ? { x: t.x, y: t.y } : n; } function de() { return navigator.maxTouchPoints || 'ontouchstart' in this; } function pe(t, n, e) { t.prototype = n.prototype = e, e.constructor = t; } function ge(t, n) { const e = Object.create(t.prototype); for (const r in n)e[r] = n[r]; return e; } function ye() {}fe.prototype.on = function () { const t = this._.on.apply(this._, arguments); return t === this._ ? this : t; }; const ve = 0.7; const _e = 1 / ve; const be = '\\s*([+-]?\\d+)\\s*'; const me = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*'; const xe = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*'; const we = /^#([0-9a-f]{3,8})$/; const Me = new RegExp(`^rgb\\(${be},${be},${be}\\)$`); const Te = new RegExp(`^rgb\\(${xe},${xe},${xe}\\)$`); const Ae = new RegExp(`^rgba\\(${be},${be},${be},${me}\\)$`); const Se = new RegExp(`^rgba\\(${xe},${xe},${xe},${me}\\)$`); const Ee = new RegExp(`^hsl\\(${me},${xe},${xe}\\)$`); const Ne = new RegExp(`^hsla\\(${me},${xe},${xe},${me}\\)$`); const ke = {
    aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074,
  }; function Ce() { return this.rgb().formatHex(); } function Pe() { return this.rgb().formatRgb(); } function ze(t) { let n; let e; return t = (`${t}`).trim().toLowerCase(), (n = we.exec(t)) ? (e = n[1].length, n = parseInt(n[1], 16), e === 6 ? $e(n) : e === 3 ? new qe(n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, (15 & n) << 4 | 15 & n, 1) : e === 8 ? De(n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, (255 & n) / 255) : e === 4 ? De(n >> 12 & 15 | n >> 8 & 240, n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, ((15 & n) << 4 | 15 & n) / 255) : null) : (n = Me.exec(t)) ? new qe(n[1], n[2], n[3], 1) : (n = Te.exec(t)) ? new qe(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, 1) : (n = Ae.exec(t)) ? De(n[1], n[2], n[3], n[4]) : (n = Se.exec(t)) ? De(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, n[4]) : (n = Ee.exec(t)) ? Le(n[1], n[2] / 100, n[3] / 100, 1) : (n = Ne.exec(t)) ? Le(n[1], n[2] / 100, n[3] / 100, n[4]) : ke.hasOwnProperty(t) ? $e(ke[t]) : t === 'transparent' ? new qe(NaN, NaN, NaN, 0) : null; } function $e(t) { return new qe(t >> 16 & 255, t >> 8 & 255, 255 & t, 1); } function De(t, n, e, r) { return r <= 0 && (t = n = e = NaN), new qe(t, n, e, r); } function Re(t) { return t instanceof ye || (t = ze(t)), t ? new qe((t = t.rgb()).r, t.g, t.b, t.opacity) : new qe(); } function Fe(t, n, e, r) { return arguments.length === 1 ? Re(t) : new qe(t, n, e, r == null ? 1 : r); } function qe(t, n, e, r) { this.r = +t, this.g = +n, this.b = +e, this.opacity = +r; } function Ue() { return `#${Ye(this.r)}${Ye(this.g)}${Ye(this.b)}`; } function Ie() { const t = Oe(this.opacity); return `${t === 1 ? 'rgb(' : 'rgba('}${Be(this.r)}, ${Be(this.g)}, ${Be(this.b)}${t === 1 ? ')' : `, ${t})`}`; } function Oe(t) { return isNaN(t) ? 1 : Math.max(0, Math.min(1, t)); } function Be(t) { return Math.max(0, Math.min(255, Math.round(t) || 0)); } function Ye(t) { return ((t = Be(t)) < 16 ? '0' : '') + t.toString(16); } function Le(t, n, e, r) { return r <= 0 ? t = n = e = NaN : e <= 0 || e >= 1 ? t = n = NaN : n <= 0 && (t = NaN), new Xe(t, n, e, r); } function je(t) { if (t instanceof Xe) return new Xe(t.h, t.s, t.l, t.opacity); if (t instanceof ye || (t = ze(t)), !t) return new Xe(); if (t instanceof Xe) return t; const n = (t = t.rgb()).r / 255; const e = t.g / 255; const r = t.b / 255; const i = Math.min(n, e, r); const o = Math.max(n, e, r); let a = NaN; let u = o - i; const c = (o + i) / 2; return u ? (a = n === o ? (e - r) / u + 6 * (e < r) : e === o ? (r - n) / u + 2 : (n - e) / u + 4, u /= c < 0.5 ? o + i : 2 - o - i, a *= 60) : u = c > 0 && c < 1 ? 0 : a, new Xe(a, u, c, t.opacity); } function He(t, n, e, r) { return arguments.length === 1 ? je(t) : new Xe(t, n, e, r == null ? 1 : r); } function Xe(t, n, e, r) { this.h = +t, this.s = +n, this.l = +e, this.opacity = +r; } function Ge(t) { return (t = (t || 0) % 360) < 0 ? t + 360 : t; } function Ve(t) { return Math.max(0, Math.min(1, t || 0)); } function We(t, n, e) { return 255 * (t < 60 ? n + (e - n) * t / 60 : t < 180 ? e : t < 240 ? n + (e - n) * (240 - t) / 60 : n); }pe(ye, ze, {
    copy(t) { return Object.assign(new this.constructor(), this, t); }, displayable() { return this.rgb().displayable(); }, hex: Ce, formatHex: Ce, formatHex8() { return this.rgb().formatHex8(); }, formatHsl() { return je(this).formatHsl(); }, formatRgb: Pe, toString: Pe,
  }), pe(qe, Fe, ge(ye, {
    brighter(t) { return t = t == null ? _e : _e ** t, new qe(this.r * t, this.g * t, this.b * t, this.opacity); }, darker(t) { return t = t == null ? ve : ve ** t, new qe(this.r * t, this.g * t, this.b * t, this.opacity); }, rgb() { return this; }, clamp() { return new qe(Be(this.r), Be(this.g), Be(this.b), Oe(this.opacity)); }, displayable() { return this.r >= -0.5 && this.r < 255.5 && this.g >= -0.5 && this.g < 255.5 && this.b >= -0.5 && this.b < 255.5 && this.opacity >= 0 && this.opacity <= 1; }, hex: Ue, formatHex: Ue, formatHex8() { return `#${Ye(this.r)}${Ye(this.g)}${Ye(this.b)}${Ye(255 * (isNaN(this.opacity) ? 1 : this.opacity))}`; }, formatRgb: Ie, toString: Ie,
  })), pe(Xe, He, ge(ye, {
    brighter(t) { return t = t == null ? _e : _e ** t, new Xe(this.h, this.s, this.l * t, this.opacity); }, darker(t) { return t = t == null ? ve : ve ** t, new Xe(this.h, this.s, this.l * t, this.opacity); }, rgb() { const t = this.h % 360 + 360 * (this.h < 0); const n = isNaN(t) || isNaN(this.s) ? 0 : this.s; const e = this.l; const r = e + (e < 0.5 ? e : 1 - e) * n; const i = 2 * e - r; return new qe(We(t >= 240 ? t - 240 : t + 120, i, r), We(t, i, r), We(t < 120 ? t + 240 : t - 120, i, r), this.opacity); }, clamp() { return new Xe(Ge(this.h), Ve(this.s), Ve(this.l), Oe(this.opacity)); }, displayable() { return (this.s >= 0 && this.s <= 1 || isNaN(this.s)) && this.l >= 0 && this.l <= 1 && this.opacity >= 0 && this.opacity <= 1; }, formatHsl() { const t = Oe(this.opacity); return `${t === 1 ? 'hsl(' : 'hsla('}${Ge(this.h)}, ${100 * Ve(this.s)}%, ${100 * Ve(this.l)}%${t === 1 ? ')' : `, ${t})`}`; },
  })); const Ze = Math.PI / 180; const Ke = 180 / Math.PI; const Qe = 0.96422; const Je = 1; const tr = 0.82521; const nr = 4 / 29; const er = 6 / 29; const rr = 3 * er * er; const ir = er * er * er; function or(t) { if (t instanceof ur) return new ur(t.l, t.a, t.b, t.opacity); if (t instanceof pr) return gr(t); t instanceof qe || (t = Re(t)); let n; let e; const r = lr(t.r); const i = lr(t.g); const o = lr(t.b); const a = cr((0.2225045 * r + 0.7168786 * i + 0.0606169 * o) / Je); return r === i && i === o ? n = e = a : (n = cr((0.4360747 * r + 0.3850649 * i + 0.1430804 * o) / Qe), e = cr((0.0139322 * r + 0.0971045 * i + 0.7141733 * o) / tr)), new ur(116 * a - 16, 500 * (n - a), 200 * (a - e), t.opacity); } function ar(t, n, e, r) { return arguments.length === 1 ? or(t) : new ur(t, n, e, r == null ? 1 : r); } function ur(t, n, e, r) { this.l = +t, this.a = +n, this.b = +e, this.opacity = +r; } function cr(t) { return t > ir ? t ** (1 / 3) : t / rr + nr; } function fr(t) { return t > er ? t * t * t : rr * (t - nr); } function sr(t) { return 255 * (t <= 0.0031308 ? 12.92 * t : 1.055 * t ** (1 / 2.4) - 0.055); } function lr(t) { return (t /= 255) <= 0.04045 ? t / 12.92 : ((t + 0.055) / 1.055) ** 2.4; } function hr(t) { if (t instanceof pr) return new pr(t.h, t.c, t.l, t.opacity); if (t instanceof ur || (t = or(t)), t.a === 0 && t.b === 0) return new pr(NaN, t.l > 0 && t.l < 100 ? 0 : NaN, t.l, t.opacity); const n = Math.atan2(t.b, t.a) * Ke; return new pr(n < 0 ? n + 360 : n, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity); } function dr(t, n, e, r) { return arguments.length === 1 ? hr(t) : new pr(t, n, e, r == null ? 1 : r); } function pr(t, n, e, r) { this.h = +t, this.c = +n, this.l = +e, this.opacity = +r; } function gr(t) { if (isNaN(t.h)) return new ur(t.l, 0, 0, t.opacity); const n = t.h * Ze; return new ur(t.l, Math.cos(n) * t.c, Math.sin(n) * t.c, t.opacity); }pe(ur, ar, ge(ye, { brighter(t) { return new ur(this.l + 18 * (t == null ? 1 : t), this.a, this.b, this.opacity); }, darker(t) { return new ur(this.l - 18 * (t == null ? 1 : t), this.a, this.b, this.opacity); }, rgb() { let t = (this.l + 16) / 116; let n = isNaN(this.a) ? t : t + this.a / 500; let e = isNaN(this.b) ? t : t - this.b / 200; return new qe(sr(3.1338561 * (n = Qe * fr(n)) - 1.6168667 * (t = Je * fr(t)) - 0.4906146 * (e = tr * fr(e))), sr(-0.9787684 * n + 1.9161415 * t + 0.033454 * e), sr(0.0719453 * n - 0.2289914 * t + 1.4052427 * e), this.opacity); } })), pe(pr, dr, ge(ye, { brighter(t) { return new pr(this.h, this.c, this.l + 18 * (t == null ? 1 : t), this.opacity); }, darker(t) { return new pr(this.h, this.c, this.l - 18 * (t == null ? 1 : t), this.opacity); }, rgb() { return gr(this).rgb(); } })); const yr = -0.14861; const vr = 1.78277; const _r = -0.29227; const br = -0.90649; const mr = 1.97294; const xr = mr * br; const wr = mr * vr; const Mr = vr * _r - br * yr; function Tr(t, n, e, r) { return arguments.length === 1 ? (function (t) { if (t instanceof Ar) return new Ar(t.h, t.s, t.l, t.opacity); t instanceof qe || (t = Re(t)); const n = t.r / 255; const e = t.g / 255; const r = t.b / 255; const i = (Mr * r + xr * n - wr * e) / (Mr + xr - wr); const o = r - i; const a = (mr * (e - i) - _r * o) / br; const u = Math.sqrt(a * a + o * o) / (mr * i * (1 - i)); const c = u ? Math.atan2(a, o) * Ke - 120 : NaN; return new Ar(c < 0 ? c + 360 : c, u, i, t.opacity); }(t)) : new Ar(t, n, e, r == null ? 1 : r); } function Ar(t, n, e, r) { this.h = +t, this.s = +n, this.l = +e, this.opacity = +r; } function Sr(t, n, e, r, i) { const o = t * t; const a = o * t; return ((1 - 3 * t + 3 * o - a) * n + (4 - 6 * o + 3 * a) * e + (1 + 3 * t + 3 * o - 3 * a) * r + a * i) / 6; } function Er(t) { const n = t.length - 1; return function (e) { const r = e <= 0 ? e = 0 : e >= 1 ? (e = 1, n - 1) : Math.floor(e * n); const i = t[r]; const o = t[r + 1]; const a = r > 0 ? t[r - 1] : 2 * i - o; const u = r < n - 1 ? t[r + 2] : 2 * o - i; return Sr((e - r / n) * n, a, i, o, u); }; } function Nr(t) { const n = t.length; return function (e) { const r = Math.floor(((e %= 1) < 0 ? ++e : e) * n); const i = t[(r + n - 1) % n]; const o = t[r % n]; const a = t[(r + 1) % n]; const u = t[(r + 2) % n]; return Sr((e - r / n) * n, i, o, a, u); }; }pe(Ar, Tr, ge(ye, { brighter(t) { return t = t == null ? _e : _e ** t, new Ar(this.h, this.s, this.l * t, this.opacity); }, darker(t) { return t = t == null ? ve : ve ** t, new Ar(this.h, this.s, this.l * t, this.opacity); }, rgb() { const t = isNaN(this.h) ? 0 : (this.h + 120) * Ze; const n = +this.l; const e = isNaN(this.s) ? 0 : this.s * n * (1 - n); const r = Math.cos(t); const i = Math.sin(t); return new qe(255 * (n + e * (yr * r + vr * i)), 255 * (n + e * (_r * r + br * i)), 255 * (n + e * (mr * r)), this.opacity); } })); const kr = (t) => () => t; function Cr(t, n) { return function (e) { return t + e * n; }; } function Pr(t, n) { const e = n - t; return e ? Cr(t, e > 180 || e < -180 ? e - 360 * Math.round(e / 360) : e) : kr(isNaN(t) ? n : t); } function zr(t) { return (t = +t) == 1 ? $r : function (n, e) { return e - n ? (function (t, n, e) { return t **= e, n = n ** e - t, e = 1 / e, function (r) { return (t + r * n) ** e; }; }(n, e, t)) : kr(isNaN(n) ? e : n); }; } function $r(t, n) { const e = n - t; return e ? Cr(t, e) : kr(isNaN(t) ? n : t); } const Dr = (function t(n) { const e = zr(n); function r(t, n) { const r = e((t = Fe(t)).r, (n = Fe(n)).r); const i = e(t.g, n.g); const o = e(t.b, n.b); const a = $r(t.opacity, n.opacity); return function (n) { return t.r = r(n), t.g = i(n), t.b = o(n), t.opacity = a(n), `${t}`; }; } return r.gamma = t, r; }(1)); function Rr(t) { return function (n) { let e; let r; const i = n.length; let o = new Array(i); let a = new Array(i); let u = new Array(i); for (e = 0; e < i; ++e)r = Fe(n[e]), o[e] = r.r || 0, a[e] = r.g || 0, u[e] = r.b || 0; return o = t(o), a = t(a), u = t(u), r.opacity = 1, function (t) { return r.r = o(t), r.g = a(t), r.b = u(t), `${r}`; }; }; } const Fr = Rr(Er); const qr = Rr(Nr); function Ur(t, n) { n || (n = []); let e; const r = t ? Math.min(n.length, t.length) : 0; const i = n.slice(); return function (o) { for (e = 0; e < r; ++e)i[e] = t[e] * (1 - o) + n[e] * o; return i; }; } function Ir(t) { return ArrayBuffer.isView(t) && !(t instanceof DataView); } function Or(t, n) { let e; const r = n ? n.length : 0; const i = t ? Math.min(r, t.length) : 0; const o = new Array(i); const a = new Array(r); for (e = 0; e < i; ++e)o[e] = Gr(t[e], n[e]); for (;e < r; ++e)a[e] = n[e]; return function (t) { for (e = 0; e < i; ++e)a[e] = o[e](t); return a; }; } function Br(t, n) { const e = new Date(); return t = +t, n = +n, function (r) { return e.setTime(t * (1 - r) + n * r), e; }; } function Yr(t, n) { return t = +t, n = +n, function (e) { return t * (1 - e) + n * e; }; } function Lr(t, n) { let e; const r = {}; const i = {}; for (e in t !== null && typeof t === 'object' || (t = {}), n !== null && typeof n === 'object' || (n = {}), n)e in t ? r[e] = Gr(t[e], n[e]) : i[e] = n[e]; return function (t) { for (e in r)i[e] = r[e](t); return i; }; } const jr = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g; const Hr = new RegExp(jr.source, 'g'); function Xr(t, n) { let e; let r; let i; let o = jr.lastIndex = Hr.lastIndex = 0; let a = -1; const u = []; const c = []; for (t += '', n += ''; (e = jr.exec(t)) && (r = Hr.exec(n));)(i = r.index) > o && (i = n.slice(o, i), u[a] ? u[a] += i : u[++a] = i), (e = e[0]) === (r = r[0]) ? u[a] ? u[a] += r : u[++a] = r : (u[++a] = null, c.push({ i: a, x: Yr(e, r) })), o = Hr.lastIndex; return o < n.length && (i = n.slice(o), u[a] ? u[a] += i : u[++a] = i), u.length < 2 ? c[0] ? (function (t) { return function (n) { return `${t(n)}`; }; }(c[0].x)) : (function (t) { return function () { return t; }; }(n)) : (n = c.length, function (t) { for (var e, r = 0; r < n; ++r)u[(e = c[r]).i] = e.x(t); return u.join(''); }); } function Gr(t, n) { let e; const r = typeof n; return n == null || r === 'boolean' ? kr(n) : (r === 'number' ? Yr : r === 'string' ? (e = ze(n)) ? (n = e, Dr) : Xr : n instanceof ze ? Dr : n instanceof Date ? Br : Ir(n) ? Ur : Array.isArray(n) ? Or : typeof n.valueOf !== 'function' && typeof n.toString !== 'function' || isNaN(n) ? Lr : Yr)(t, n); } function Vr(t, n) { return t = +t, n = +n, function (e) { return Math.round(t * (1 - e) + n * e); }; } let Wr; const Zr = 180 / Math.PI; const Kr = {
    translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1,
  }; function Qr(t, n, e, r, i, o) {
    let a; let u; let c; return (a = Math.sqrt(t * t + n * n)) && (t /= a, n /= a), (c = t * e + n * r) && (e -= t * c, r -= n * c), (u = Math.sqrt(e * e + r * r)) && (e /= u, r /= u, c /= u), t * r < n * e && (t = -t, n = -n, c = -c, a = -a), {
      translateX: i, translateY: o, rotate: Math.atan2(n, t) * Zr, skewX: Math.atan(c) * Zr, scaleX: a, scaleY: u,
    };
  } function Jr(t, n, e, r) { function i(t) { return t.length ? `${t.pop()} ` : ''; } return function (o, a) { const u = []; const c = []; return o = t(o), a = t(a), (function (t, r, i, o, a, u) { if (t !== i || r !== o) { const c = a.push('translate(', null, n, null, e); u.push({ i: c - 4, x: Yr(t, i) }, { i: c - 2, x: Yr(r, o) }); } else (i || o) && a.push(`translate(${i}${n}${o}${e}`); }(o.translateX, o.translateY, a.translateX, a.translateY, u, c)), (function (t, n, e, o) { t !== n ? (t - n > 180 ? n += 360 : n - t > 180 && (t += 360), o.push({ i: e.push(`${i(e)}rotate(`, null, r) - 2, x: Yr(t, n) })) : n && e.push(`${i(e)}rotate(${n}${r}`); }(o.rotate, a.rotate, u, c)), (function (t, n, e, o) { t !== n ? o.push({ i: e.push(`${i(e)}skewX(`, null, r) - 2, x: Yr(t, n) }) : n && e.push(`${i(e)}skewX(${n}${r}`); }(o.skewX, a.skewX, u, c)), (function (t, n, e, r, o, a) { if (t !== e || n !== r) { const u = o.push(`${i(o)}scale(`, null, ',', null, ')'); a.push({ i: u - 4, x: Yr(t, e) }, { i: u - 2, x: Yr(n, r) }); } else e === 1 && r === 1 || o.push(`${i(o)}scale(${e},${r})`); }(o.scaleX, o.scaleY, a.scaleX, a.scaleY, u, c)), o = a = null, function (t) { for (var n, e = -1, r = c.length; ++e < r;)u[(n = c[e]).i] = n.x(t); return u.join(''); }; }; } const ti = Jr(((t) => { const n = new (typeof DOMMatrix === 'function' ? DOMMatrix : WebKitCSSMatrix)(`${t}`); return n.isIdentity ? Kr : Qr(n.a, n.b, n.c, n.d, n.e, n.f); }), 'px, ', 'px)', 'deg)'); const ni = Jr(((t) => (t == null ? Kr : (Wr || (Wr = document.createElementNS('http://www.w3.org/2000/svg', 'g')), Wr.setAttribute('transform', t), (t = Wr.transform.baseVal.consolidate()) ? Qr((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f) : Kr))), ', ', ')', ')'); function ei(t) { return ((t = Math.exp(t)) + 1 / t) / 2; } const ri = (function t(n, e, r) { function i(t, i) { let o; let a; const u = t[0]; const c = t[1]; const f = t[2]; const s = i[0]; const l = i[1]; const h = i[2]; const d = s - u; const p = l - c; const g = d * d + p * p; if (g < 1e-12)a = Math.log(h / f) / n, o = function (t) { return [u + t * d, c + t * p, f * Math.exp(n * t * a)]; }; else { const y = Math.sqrt(g); const v = (h * h - f * f + r * g) / (2 * f * e * y); const _ = (h * h - f * f - r * g) / (2 * h * e * y); const b = Math.log(Math.sqrt(v * v + 1) - v); const m = Math.log(Math.sqrt(_ * _ + 1) - _); a = (m - b) / n, o = function (t) { const r = t * a; const i = ei(b); const o = f / (e * y) * (i * (function (t) { return ((t = Math.exp(2 * t)) - 1) / (t + 1); }(n * r + b)) - (function (t) { return ((t = Math.exp(t)) - 1 / t) / 2; }(b))); return [u + o * d, c + o * p, f * i / ei(n * r + b)]; }; } return o.duration = 1e3 * a * n / Math.SQRT2, o; } return i.rho = function (n) { const e = Math.max(0.001, +n); const r = e * e; return t(e, r, r * r); }, i; }(Math.SQRT2, 2, 4)); function ii(t) { return function (n, e) { const r = t((n = He(n)).h, (e = He(e)).h); const i = $r(n.s, e.s); const o = $r(n.l, e.l); const a = $r(n.opacity, e.opacity); return function (t) { return n.h = r(t), n.s = i(t), n.l = o(t), n.opacity = a(t), `${n}`; }; }; } const oi = ii(Pr); const ai = ii($r); function ui(t) { return function (n, e) { const r = t((n = dr(n)).h, (e = dr(e)).h); const i = $r(n.c, e.c); const o = $r(n.l, e.l); const a = $r(n.opacity, e.opacity); return function (t) { return n.h = r(t), n.c = i(t), n.l = o(t), n.opacity = a(t), `${n}`; }; }; } const ci = ui(Pr); const fi = ui($r); function si(t) { return (function n(e) { function r(n, r) { const i = t((n = Tr(n)).h, (r = Tr(r)).h); const o = $r(n.s, r.s); const a = $r(n.l, r.l); const u = $r(n.opacity, r.opacity); return function (t) { return n.h = i(t), n.s = o(t), n.l = a(t ** e), n.opacity = u(t), `${n}`; }; } return e = +e, r.gamma = n, r; }(1)); } const li = si(Pr); const hi = si($r); function di(t, n) { void 0 === n && (n = t, t = Gr); for (var e = 0, r = n.length - 1, i = n[0], o = new Array(r < 0 ? 0 : r); e < r;)o[e] = t(i, i = n[++e]); return function (t) { const n = Math.max(0, Math.min(r - 1, Math.floor(t *= r))); return o[n](t - n); }; } let pi; let gi; let yi = 0; let vi = 0; let _i = 0; const bi = 1e3; let mi = 0; let xi = 0; let wi = 0; const Mi = typeof performance === 'object' && performance.now ? performance : Date; const Ti = typeof window === 'object' && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (t) { setTimeout(t, 17); }; function Ai() { return xi || (Ti(Si), xi = Mi.now() + wi); } function Si() { xi = 0; } function Ei() { this._call = this._time = this._next = null; } function Ni(t, n, e) { const r = new Ei(); return r.restart(t, n, e), r; } function ki() { Ai(), ++yi; for (var t, n = pi; n;)(t = xi - n._time) >= 0 && n._call.call(void 0, t), n = n._next; --yi; } function Ci() { xi = (mi = Mi.now()) + wi, yi = vi = 0; try { ki(); } finally { yi = 0, (function () { let t; let n; let e = pi; let r = 1 / 0; for (;e;)e._call ? (r > e._time && (r = e._time), t = e, e = e._next) : (n = e._next, e._next = null, e = t ? t._next = n : pi = n); gi = t, zi(r); }()), xi = 0; } } function Pi() { const t = Mi.now(); const n = t - mi; n > bi && (wi -= n, mi = t); } function zi(t) { yi || (vi && (vi = clearTimeout(vi)), t - xi > 24 ? (t < 1 / 0 && (vi = setTimeout(Ci, t - Mi.now() - wi)), _i && (_i = clearInterval(_i))) : (_i || (mi = Mi.now(), _i = setInterval(Pi, bi)), yi = 1, Ti(Ci))); } function $i(t, n, e) { const r = new Ei(); return n = n == null ? 0 : +n, r.restart(((e) => { r.stop(), t(e + n); }), n, e), r; }Ei.prototype = Ni.prototype = { constructor: Ei, restart(t, n, e) { if (typeof t !== 'function') throw new TypeError('callback is not a function'); e = (e == null ? Ai() : +e) + (n == null ? 0 : +n), this._next || gi === this || (gi ? gi._next = this : pi = this, gi = this), this._call = t, this._time = e, zi(); }, stop() { this._call && (this._call = null, this._time = 1 / 0, zi()); } }; const Di = $t('start', 'end', 'cancel', 'interrupt'); const Ri = []; const Fi = 0; const qi = 1; const Ui = 2; const Ii = 3; const Oi = 4; const Bi = 5; const Yi = 6; function Li(t, n, e, r, i, o) {
    const a = t.__transition; if (a) { if (e in a) return; } else t.__transition = {}; !(function (t, n, e) { let r; const i = t.__transition; function o(t) { e.state = qi, e.timer.restart(a, e.delay, e.time), e.delay <= t && a(t - e.delay); } function a(o) { let f; let s; let l; let h; if (e.state !== qi) return c(); for (f in i) if ((h = i[f]).name === e.name) { if (h.state === Ii) return $i(a); h.state === Oi ? (h.state = Yi, h.timer.stop(), h.on.call('interrupt', t, t.__data__, h.index, h.group), delete i[f]) : +f < n && (h.state = Yi, h.timer.stop(), h.on.call('cancel', t, t.__data__, h.index, h.group), delete i[f]); } if ($i((() => { e.state === Ii && (e.state = Oi, e.timer.restart(u, e.delay, e.time), u(o)); })), e.state = Ui, e.on.call('start', t, t.__data__, e.index, e.group), e.state === Ui) { for (e.state = Ii, r = new Array(l = e.tween.length), f = 0, s = -1; f < l; ++f)(h = e.tween[f].value.call(t, t.__data__, e.index, e.group)) && (r[++s] = h); r.length = s + 1; } } function u(n) { for (let i = n < e.duration ? e.ease.call(null, n / e.duration) : (e.timer.restart(c), e.state = Bi, 1), o = -1, a = r.length; ++o < a;)r[o].call(t, i); e.state === Bi && (e.on.call('end', t, t.__data__, e.index, e.group), c()); } function c() { for (const r in e.state = Yi, e.timer.stop(), delete i[n], i) return; delete t.__transition; }i[n] = e, e.timer = Ni(o, 0, e.time); }(t, e, {
      name: n, index: r, group: i, on: Di, tween: Ri, time: o.time, delay: o.delay, duration: o.duration, ease: o.ease, timer: null, state: Fi,
    }));
  } function ji(t, n) { const e = Xi(t, n); if (e.state > Fi) throw new Error('too late; already scheduled'); return e; } function Hi(t, n) { const e = Xi(t, n); if (e.state > Ii) throw new Error('too late; already running'); return e; } function Xi(t, n) { let e = t.__transition; if (!e || !(e = e[n])) throw new Error('transition not found'); return e; } function Gi(t, n) { let e; let r; let i; const o = t.__transition; let a = !0; if (o) { for (i in n = n == null ? null : `${n}`, o)(e = o[i]).name === n ? (r = e.state > Ui && e.state < Bi, e.state = Yi, e.timer.stop(), e.on.call(r ? 'interrupt' : 'cancel', t, t.__data__, e.index, e.group), delete o[i]) : a = !1; a && delete t.__transition; } } function Vi(t, n) { let e; let r; return function () { const i = Hi(this, t); const o = i.tween; if (o !== e) for (let a = 0, u = (r = e = o).length; a < u; ++a) if (r[a].name === n) { (r = r.slice()).splice(a, 1); break; }i.tween = r; }; } function Wi(t, n, e) { let r; let i; if (typeof e !== 'function') throw new Error(); return function () { const o = Hi(this, t); const a = o.tween; if (a !== r) { i = (r = a).slice(); for (var u = { name: n, value: e }, c = 0, f = i.length; c < f; ++c) if (i[c].name === n) { i[c] = u; break; }c === f && i.push(u); }o.tween = i; }; } function Zi(t, n, e) { const r = t._id; return t.each((function () { const t = Hi(this, r); (t.value || (t.value = {}))[n] = e.apply(this, arguments); })), function (t) { return Xi(t, r).value[n]; }; } function Ki(t, n) { let e; return (typeof n === 'number' ? Yr : n instanceof ze ? Dr : (e = ze(n)) ? (n = e, Dr) : Xr)(t, n); } function Qi(t) { return function () { this.removeAttribute(t); }; } function Ji(t) { return function () { this.removeAttributeNS(t.space, t.local); }; } function to(t, n, e) { let r; let i; const o = `${e}`; return function () { const a = this.getAttribute(t); return a === o ? null : a === r ? i : i = n(r = a, e); }; } function no(t, n, e) { let r; let i; const o = `${e}`; return function () { const a = this.getAttributeNS(t.space, t.local); return a === o ? null : a === r ? i : i = n(r = a, e); }; } function eo(t, n, e) { let r; let i; let o; return function () { let a; let u; const c = e(this); if (c != null) return (a = this.getAttribute(t)) === (u = `${c}`) ? null : a === r && u === i ? o : (i = u, o = n(r = a, c)); this.removeAttribute(t); }; } function ro(t, n, e) { let r; let i; let o; return function () { let a; let u; const c = e(this); if (c != null) return (a = this.getAttributeNS(t.space, t.local)) === (u = `${c}`) ? null : a === r && u === i ? o : (i = u, o = n(r = a, c)); this.removeAttributeNS(t.space, t.local); }; } function io(t, n) { let e; let r; function i() { const i = n.apply(this, arguments); return i !== r && (e = (r = i) && (function (t, n) { return function (e) { this.setAttributeNS(t.space, t.local, n.call(this, e)); }; }(t, i))), e; } return i._value = n, i; } function oo(t, n) { let e; let r; function i() { const i = n.apply(this, arguments); return i !== r && (e = (r = i) && (function (t, n) { return function (e) { this.setAttribute(t, n.call(this, e)); }; }(t, i))), e; } return i._value = n, i; } function ao(t, n) { return function () { ji(this, t).delay = +n.apply(this, arguments); }; } function uo(t, n) { return n = +n, function () { ji(this, t).delay = n; }; } function co(t, n) { return function () { Hi(this, t).duration = +n.apply(this, arguments); }; } function fo(t, n) { return n = +n, function () { Hi(this, t).duration = n; }; } const so = Wn.prototype.constructor; function lo(t) { return function () { this.style.removeProperty(t); }; } let ho = 0; function po(t, n, e, r) { this._groups = t, this._parents = n, this._name = e, this._id = r; } function go(t) { return Wn().transition(t); } function yo() { return ++ho; } const vo = Wn.prototype; po.prototype = go.prototype = {
    constructor: po,
    select(t) { const n = this._name; const e = this._id; typeof t !== 'function' && (t = jt(t)); for (var r = this._groups, i = r.length, o = new Array(i), a = 0; a < i; ++a) for (var u, c, f = r[a], s = f.length, l = o[a] = new Array(s), h = 0; h < s; ++h)(u = f[h]) && (c = t.call(u, u.__data__, h, f)) && ('__data__' in u && (c.__data__ = u.__data__), l[h] = c, Li(l[h], n, e, h, l, Xi(u, e))); return new po(o, this._parents, n, e); },
    selectAll(t) { const n = this._name; const e = this._id; typeof t !== 'function' && (t = Gt(t)); for (var r = this._groups, i = r.length, o = [], a = [], u = 0; u < i; ++u) for (var c, f = r[u], s = f.length, l = 0; l < s; ++l) if (c = f[l]) { for (var h, d = t.call(c, c.__data__, l, f), p = Xi(c, e), g = 0, y = d.length; g < y; ++g)(h = d[g]) && Li(h, n, e, g, d, p); o.push(d), a.push(c); } return new po(o, a, n, e); },
    selectChild: vo.selectChild,
    selectChildren: vo.selectChildren,
    filter(t) { typeof t !== 'function' && (t = Vt(t)); for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i) for (var o, a = n[i], u = a.length, c = r[i] = [], f = 0; f < u; ++f)(o = a[f]) && t.call(o, o.__data__, f, a) && c.push(o); return new po(r, this._parents, this._name, this._id); },
    merge(t) { if (t._id !== this._id) throw new Error(); for (var n = this._groups, e = t._groups, r = n.length, i = e.length, o = Math.min(r, i), a = new Array(r), u = 0; u < o; ++u) for (var c, f = n[u], s = e[u], l = f.length, h = a[u] = new Array(l), d = 0; d < l; ++d)(c = f[d] || s[d]) && (h[d] = c); for (;u < r; ++u)a[u] = n[u]; return new po(a, this._parents, this._name, this._id); },
    selection() { return new so(this._groups, this._parents); },
    transition() {
      for (var t = this._name, n = this._id, e = yo(), r = this._groups, i = r.length, o = 0; o < i; ++o) {
        for (var a, u = r[o], c = u.length, f = 0; f < c; ++f) {
          if (a = u[f]) {
            const s = Xi(a, n); Li(a, t, e, f, u, {
              time: s.time + s.delay + s.duration, delay: 0, duration: s.duration, ease: s.ease,
            });
          }
        }
      } return new po(r, this._parents, t, e);
    },
    call: vo.call,
    nodes: vo.nodes,
    node: vo.node,
    size: vo.size,
    empty: vo.empty,
    each: vo.each,
    on(t, n) { const e = this._id; return arguments.length < 2 ? Xi(this.node(), e).on.on(t) : this.each(function (t, n, e) { let r; let i; const o = (function (t) { return (`${t}`).trim().split(/^|\s+/).every(((t) => { const n = t.indexOf('.'); return n >= 0 && (t = t.slice(0, n)), !t || t === 'start'; })); }(n)) ? ji : Hi; return function () { const a = o(this, t); const u = a.on; u !== r && (i = (r = u).copy()).on(n, e), a.on = i; }; }(e, t, n)); },
    attr(t, n) { const e = It(t); const r = e === 'transform' ? ni : Ki; return this.attrTween(t, typeof n === 'function' ? (e.local ? ro : eo)(e, r, Zi(this, `attr.${t}`, n)) : n == null ? (e.local ? Ji : Qi)(e) : (e.local ? no : to)(e, r, n)); },
    attrTween(t, n) { let e = `attr.${t}`; if (arguments.length < 2) return (e = this.tween(e)) && e._value; if (n == null) return this.tween(e, null); if (typeof n !== 'function') throw new Error(); const r = It(t); return this.tween(e, (r.local ? io : oo)(r, n)); },
    style(t, n, e) { const r = (t += '') == 'transform' ? ti : Ki; return n == null ? this.styleTween(t, (function (t, n) { let e; let r; let i; return function () { const o = _n(this, t); const a = (this.style.removeProperty(t), _n(this, t)); return o === a ? null : o === e && a === r ? i : i = n(e = o, r = a); }; }(t, r))).on(`end.style.${t}`, lo(t)) : typeof n === 'function' ? this.styleTween(t, (function (t, n, e) { let r; let i; let o; return function () { const a = _n(this, t); let u = e(this); let c = `${u}`; return u == null && (this.style.removeProperty(t), c = u = _n(this, t)), a === c ? null : a === r && c === i ? o : (i = c, o = n(r = a, u)); }; }(t, r, Zi(this, `style.${t}`, n)))).each(function (t, n) { let e; let r; let i; let o; const a = `style.${n}`; const u = `end.${a}`; return function () { const c = Hi(this, t); const f = c.on; const s = c.value[a] == null ? o || (o = lo(n)) : void 0; f === e && i === s || (r = (e = f).copy()).on(u, i = s), c.on = r; }; }(this._id, t)) : this.styleTween(t, (function (t, n, e) { let r; let i; const o = `${e}`; return function () { const a = _n(this, t); return a === o ? null : a === r ? i : i = n(r = a, e); }; }(t, r, n)), e).on(`end.style.${t}`, null); },
    styleTween(t, n, e) { let r = `style.${t += ''}`; if (arguments.length < 2) return (r = this.tween(r)) && r._value; if (n == null) return this.tween(r, null); if (typeof n !== 'function') throw new Error(); return this.tween(r, (function (t, n, e) { let r; let i; function o() { const o = n.apply(this, arguments); return o !== i && (r = (i = o) && (function (t, n, e) { return function (r) { this.style.setProperty(t, n.call(this, r), e); }; }(t, o, e))), r; } return o._value = n, o; }(t, n, e == null ? '' : e))); },
    text(t) { return this.tween('text', typeof t === 'function' ? (function (t) { return function () { const n = t(this); this.textContent = n == null ? '' : n; }; }(Zi(this, 'text', t))) : (function (t) { return function () { this.textContent = t; }; }(t == null ? '' : `${t}`))); },
    textTween(t) { let n = 'text'; if (arguments.length < 1) return (n = this.tween(n)) && n._value; if (t == null) return this.tween(n, null); if (typeof t !== 'function') throw new Error(); return this.tween(n, (function (t) { let n; let e; function r() { const r = t.apply(this, arguments); return r !== e && (n = (e = r) && (function (t) { return function (n) { this.textContent = t.call(this, n); }; }(r))), n; } return r._value = t, r; }(t))); },
    remove() { return this.on('end.remove', (function (t) { return function () { const n = this.parentNode; for (const e in this.__transition) if (+e !== t) return; n && n.removeChild(this); }; }(this._id))); },
    tween(t, n) { const e = this._id; if (t += '', arguments.length < 2) { for (var r, i = Xi(this.node(), e).tween, o = 0, a = i.length; o < a; ++o) if ((r = i[o]).name === t) return r.value; return null; } return this.each((n == null ? Vi : Wi)(e, t, n)); },
    delay(t) { const n = this._id; return arguments.length ? this.each((typeof t === 'function' ? ao : uo)(n, t)) : Xi(this.node(), n).delay; },
    duration(t) { const n = this._id; return arguments.length ? this.each((typeof t === 'function' ? co : fo)(n, t)) : Xi(this.node(), n).duration; },
    ease(t) { const n = this._id; return arguments.length ? this.each(function (t, n) { if (typeof n !== 'function') throw new Error(); return function () { Hi(this, t).ease = n; }; }(n, t)) : Xi(this.node(), n).ease; },
    easeVarying(t) { if (typeof t !== 'function') throw new Error(); return this.each(function (t, n) { return function () { const e = n.apply(this, arguments); if (typeof e !== 'function') throw new Error(); Hi(this, t).ease = e; }; }(this._id, t)); },
    end() { let t; let n; const e = this; const r = e._id; let i = e.size(); return new Promise(((o, a) => { const u = { value: a }; const c = { value() { --i == 0 && o(); } }; e.each((function () { const e = Hi(this, r); const i = e.on; i !== t && ((n = (t = i).copy())._.cancel.push(u), n._.interrupt.push(u), n._.end.push(c)), e.on = n; })), i === 0 && o(); })); },
    [Symbol.iterator]: vo[Symbol.iterator],
  }; function _o(t) { return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2; } function bo(t) { return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2; } const mo = (function t(n) { function e(t) { return t ** n; } return n = +n, e.exponent = t, e; }(3)); const xo = (function t(n) { function e(t) { return 1 - (1 - t) ** n; } return n = +n, e.exponent = t, e; }(3)); const wo = (function t(n) { function e(t) { return ((t *= 2) <= 1 ? t ** n : 2 - (2 - t) ** n) / 2; } return n = +n, e.exponent = t, e; }(3)); const Mo = Math.PI; const To = Mo / 2; function Ao(t) { return (1 - Math.cos(Mo * t)) / 2; } function So(t) { return 1.0009775171065494 * (2 ** (-10 * t) - 0.0009765625); } function Eo(t) { return ((t *= 2) <= 1 ? So(1 - t) : 2 - So(t - 1)) / 2; } function No(t) { return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2; } const ko = 4 / 11; const Co = 6 / 11; const Po = 8 / 11; const zo = 3 / 4; const $o = 9 / 11; const Do = 10 / 11; const Ro = 15 / 16; const Fo = 21 / 22; const qo = 63 / 64; const Uo = 1 / ko / ko; function Io(t) { return (t = +t) < ko ? Uo * t * t : t < Po ? Uo * (t -= Co) * t + zo : t < Do ? Uo * (t -= $o) * t + Ro : Uo * (t -= Fo) * t + qo; } const Oo = 1.70158; const Bo = (function t(n) { function e(t) { return (t = +t) * t * (n * (t - 1) + t); } return n = +n, e.overshoot = t, e; }(Oo)); const Yo = (function t(n) { function e(t) { return --t * t * ((t + 1) * n + t) + 1; } return n = +n, e.overshoot = t, e; }(Oo)); const Lo = (function t(n) { function e(t) { return ((t *= 2) < 1 ? t * t * ((n + 1) * t - n) : (t -= 2) * t * ((n + 1) * t + n) + 2) / 2; } return n = +n, e.overshoot = t, e; }(Oo)); const jo = 2 * Math.PI; const Ho = (function t(n, e) { const r = Math.asin(1 / (n = Math.max(1, n))) * (e /= jo); function i(t) { return n * So(- --t) * Math.sin((r - t) / e); } return i.amplitude = function (n) { return t(n, e * jo); }, i.period = function (e) { return t(n, e); }, i; }(1, 0.3)); const Xo = (function t(n, e) { const r = Math.asin(1 / (n = Math.max(1, n))) * (e /= jo); function i(t) { return 1 - n * So(t = +t) * Math.sin((t + r) / e); } return i.amplitude = function (n) { return t(n, e * jo); }, i.period = function (e) { return t(n, e); }, i; }(1, 0.3)); const Go = (function t(n, e) { const r = Math.asin(1 / (n = Math.max(1, n))) * (e /= jo); function i(t) { return ((t = 2 * t - 1) < 0 ? n * So(-t) * Math.sin((r - t) / e) : 2 - n * So(t) * Math.sin((r + t) / e)) / 2; } return i.amplitude = function (n) { return t(n, e * jo); }, i.period = function (e) { return t(n, e); }, i; }(1, 0.3)); const Vo = {
    time: null, delay: 0, duration: 250, ease: bo,
  }; function Wo(t, n) { for (var e; !(e = t.__transition) || !(e = e[n]);) if (!(t = t.parentNode)) throw new Error(`transition ${n} not found`); return e; }Wn.prototype.interrupt = function (t) { return this.each((function () { Gi(this, t); })); }, Wn.prototype.transition = function (t) { let n; let e; t instanceof po ? (n = t._id, t = t._name) : (n = yo(), (e = Vo).time = Ai(), t = t == null ? null : `${t}`); for (var r = this._groups, i = r.length, o = 0; o < i; ++o) for (var a, u = r[o], c = u.length, f = 0; f < c; ++f)(a = u[f]) && Li(a, t, n, f, u, e || Wo(a, n)); return new po(r, this._parents, t, n); }; const Zo = [null]; const Ko = (t) => () => t; function Qo(t, {
    sourceEvent: n, target: e, selection: r, mode: i, dispatch: o,
  }) {
    Object.defineProperties(this, {
      type: { value: t, enumerable: !0, configurable: !0 }, sourceEvent: { value: n, enumerable: !0, configurable: !0 }, target: { value: e, enumerable: !0, configurable: !0 }, selection: { value: r, enumerable: !0, configurable: !0 }, mode: { value: i, enumerable: !0, configurable: !0 }, _: { value: o },
    });
  } function Jo(t) { t.preventDefault(), t.stopImmediatePropagation(); } const ta = { name: 'drag' }; const na = { name: 'space' }; const ea = { name: 'handle' }; const ra = { name: 'center' }; const { abs: ia, max: oa, min: aa } = Math; function ua(t) { return [+t[0], +t[1]]; } function ca(t) { return [ua(t[0]), ua(t[1])]; } const fa = {
    name: 'x', handles: ['w', 'e'].map(va), input(t, n) { return t == null ? null : [[+t[0], n[0][1]], [+t[1], n[1][1]]]; }, output(t) { return t && [t[0][0], t[1][0]]; },
  }; const sa = {
    name: 'y', handles: ['n', 's'].map(va), input(t, n) { return t == null ? null : [[n[0][0], +t[0]], [n[1][0], +t[1]]]; }, output(t) { return t && [t[0][1], t[1][1]]; },
  }; const la = {
    name: 'xy', handles: ['n', 'w', 'e', 's', 'nw', 'ne', 'sw', 'se'].map(va), input(t) { return t == null ? null : ca(t); }, output(t) { return t; },
  }; const ha = {
    overlay: 'crosshair', selection: 'move', n: 'ns-resize', e: 'ew-resize', s: 'ns-resize', w: 'ew-resize', nw: 'nwse-resize', ne: 'nesw-resize', se: 'nwse-resize', sw: 'nesw-resize',
  }; const da = {
    e: 'w', w: 'e', nw: 'ne', ne: 'nw', se: 'sw', sw: 'se',
  }; const pa = {
    n: 's', s: 'n', nw: 'sw', ne: 'se', se: 'ne', sw: 'nw',
  }; const ga = {
    overlay: 1, selection: 1, n: null, e: 1, s: null, w: -1, nw: -1, ne: 1, se: 1, sw: -1,
  }; const ya = {
    overlay: 1, selection: 1, n: -1, e: null, s: 1, w: null, nw: -1, ne: -1, se: 1, sw: 1,
  }; function va(t) { return { type: t }; } function _a(t) { return !t.ctrlKey && !t.button; } function ba() { let t = this.ownerSVGElement || this; return t.hasAttribute('viewBox') ? [[(t = t.viewBox.baseVal).x, t.y], [t.x + t.width, t.y + t.height]] : [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]]; } function ma() { return navigator.maxTouchPoints || 'ontouchstart' in this; } function xa(t) { for (;!t.__brush;) if (!(t = t.parentNode)) return; return t.__brush; } function wa(t) {
    let n; let e = ba; let r = _a; let i = ma; let o = !0; const a = $t('start', 'brush', 'end'); let u = 6; function c(n) {
      const e = n.property('__brush', g).selectAll('.overlay').data([va('overlay')]); e.enter().append('rect').attr('class', 'overlay').attr('pointer-events', 'all')
        .attr('cursor', ha.overlay)
        .merge(e)
        .each((function () {
          const t = xa(this).extent; Zn(this).attr('x', t[0][0]).attr('y', t[0][1]).attr('width', t[1][0] - t[0][0])
            .attr('height', t[1][1] - t[0][1]);
        })), n.selectAll('.selection').data([va('selection')]).enter().append('rect')
        .attr('class', 'selection')
        .attr('cursor', ha.selection)
        .attr('fill', '#777')
        .attr('fill-opacity', 0.3)
        .attr('stroke', '#fff')
        .attr('shape-rendering', 'crispEdges'); const r = n.selectAll('.handle').data(t.handles, ((t) => t.type)); r.exit().remove(), r.enter().append('rect').attr('class', ((t) => `handle handle--${t.type}`)).attr('cursor', ((t) => ha[t.type])), n.each(f).attr('fill', 'none').attr('pointer-events', 'all').on('mousedown.brush', h)
        .filter(i)
        .on('touchstart.brush', h)
        .on('touchmove.brush', d)
        .on('touchend.brush touchcancel.brush', p)
        .style('touch-action', 'none')
        .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');
    } function f() {
      const t = Zn(this); const n = xa(this).selection; n ? (t.selectAll('.selection').style('display', null).attr('x', n[0][0]).attr('y', n[0][1])
        .attr('width', n[1][0] - n[0][0])
        .attr('height', n[1][1] - n[0][1]), t.selectAll('.handle').style('display', null).attr('x', ((t) => (t.type[t.type.length - 1] === 'e' ? n[1][0] - u / 2 : n[0][0] - u / 2))).attr('y', ((t) => (t.type[0] === 's' ? n[1][1] - u / 2 : n[0][1] - u / 2)))
        .attr('width', ((t) => (t.type === 'n' || t.type === 's' ? n[1][0] - n[0][0] + u : u)))
        .attr('height', ((t) => (t.type === 'e' || t.type === 'w' ? n[1][1] - n[0][1] + u : u)))) : t.selectAll('.selection,.handle').style('display', 'none').attr('x', null).attr('y', null)
        .attr('width', null)
        .attr('height', null);
    } function s(t, n, e) { const r = t.__brush.emitter; return !r || e && r.clean ? new l(t, n, e) : r; } function l(t, n, e) { this.that = t, this.args = n, this.state = t.__brush, this.active = 0, this.clean = e; } function h(e) { if ((!n || e.touches) && r.apply(this, arguments)) { var i; var a; var u; var c; var l; var h; var d; var p; var g; var y; var v; var _ = this; var b = e.target.__data__.type; var m = (o && e.metaKey ? b = 'overlay' : b) === 'selection' ? ta : o && e.altKey ? ra : ea; var x = t === sa ? null : ga[b]; var w = t === fa ? null : ya[b]; var M = xa(_); const T = M.extent; var A = M.selection; var S = T[0][0]; var E = T[0][1]; var N = T[1][0]; var k = T[1][1]; var C = 0; var P = 0; var z = x && w && o && e.shiftKey; var $ = Array.from(e.touches || [e], ((t) => { const n = t.identifier; return (t = ne(t, _)).point0 = t.slice(), t.identifier = n, t; })); Gi(_); var D = s(_, arguments, !0).beforestart(); if (b === 'overlay') { A && (g = !0); const n = [$[0], $[1] || $[0]]; M.selection = A = [[i = t === sa ? S : aa(n[0][0], n[1][0]), u = t === fa ? E : aa(n[0][1], n[1][1])], [l = t === sa ? N : oa(n[0][0], n[1][0]), d = t === fa ? k : oa(n[0][1], n[1][1])]], $.length > 1 && I(e); } else i = A[0][0], u = A[0][1], l = A[1][0], d = A[1][1]; a = i, c = u, h = l, p = d; var R = Zn(_).attr('pointer-events', 'none'); var F = R.selectAll('.overlay').attr('cursor', ha[b]); if (e.touches)D.moved = U, D.ended = O; else { var q = Zn(e.view).on('mousemove.brush', U, !0).on('mouseup.brush', O, !0); o && q.on('keydown.brush', ((t) => { switch (t.keyCode) { case 16: z = x && w; break; case 18: m === ea && (x && (l = h - C * x, i = a + C * x), w && (d = p - P * w, u = c + P * w), m = ra, I(t)); break; case 32: m !== ea && m !== ra || (x < 0 ? l = h - C : x > 0 && (i = a - C), w < 0 ? d = p - P : w > 0 && (u = c - P), m = na, F.attr('cursor', ha.selection), I(t)); break; default: return; }Jo(t); }), !0).on('keyup.brush', ((t) => { switch (t.keyCode) { case 16: z && (y = v = z = !1, I(t)); break; case 18: m === ra && (x < 0 ? l = h : x > 0 && (i = a), w < 0 ? d = p : w > 0 && (u = c), m = ea, I(t)); break; case 32: m === na && (t.altKey ? (x && (l = h - C * x, i = a + C * x), w && (d = p - P * w, u = c + P * w), m = ra) : (x < 0 ? l = h : x > 0 && (i = a), w < 0 ? d = p : w > 0 && (u = c), m = ea), F.attr('cursor', ha[b]), I(t)); break; default: return; }Jo(t); }), !0), ae(e.view); }f.call(_), D.start(e, m.name); } function U(t) { for (const n of t.changedTouches || [t]) for (const t of $)t.identifier === n.identifier && (t.cur = ne(n, _)); if (z && !y && !v && $.length === 1) { const t = $[0]; ia(t.cur[0] - t[0]) > ia(t.cur[1] - t[1]) ? v = !0 : y = !0; } for (const t of $)t.cur && (t[0] = t.cur[0], t[1] = t.cur[1]); g = !0, Jo(t), I(t); } function I(t) { const n = $[0]; const e = n.point0; let r; switch (C = n[0] - e[0], P = n[1] - e[1], m) { case na: case ta: x && (C = oa(S - i, aa(N - l, C)), a = i + C, h = l + C), w && (P = oa(E - u, aa(k - d, P)), c = u + P, p = d + P); break; case ea: $[1] ? (x && (a = oa(S, aa(N, $[0][0])), h = oa(S, aa(N, $[1][0])), x = 1), w && (c = oa(E, aa(k, $[0][1])), p = oa(E, aa(k, $[1][1])), w = 1)) : (x < 0 ? (C = oa(S - i, aa(N - i, C)), a = i + C, h = l) : x > 0 && (C = oa(S - l, aa(N - l, C)), a = i, h = l + C), w < 0 ? (P = oa(E - u, aa(k - u, P)), c = u + P, p = d) : w > 0 && (P = oa(E - d, aa(k - d, P)), c = u, p = d + P)); break; case ra: x && (a = oa(S, aa(N, i - C * x)), h = oa(S, aa(N, l + C * x))), w && (c = oa(E, aa(k, u - P * w)), p = oa(E, aa(k, d + P * w))); }h < a && (x *= -1, r = i, i = l, l = r, r = a, a = h, h = r, b in da && F.attr('cursor', ha[b = da[b]])), p < c && (w *= -1, r = u, u = d, d = r, r = c, c = p, p = r, b in pa && F.attr('cursor', ha[b = pa[b]])), M.selection && (A = M.selection), y && (a = A[0][0], h = A[1][0]), v && (c = A[0][1], p = A[1][1]), A[0][0] === a && A[0][1] === c && A[1][0] === h && A[1][1] === p || (M.selection = [[a, c], [h, p]], f.call(_), D.brush(t, m.name)); } function O(t) { if ((function (t) { t.stopImmediatePropagation(); }(t)), t.touches) { if (t.touches.length) return; n && clearTimeout(n), n = setTimeout((() => { n = null; }), 500); } else ue(t.view, g), q.on('keydown.brush keyup.brush mousemove.brush mouseup.brush', null); R.attr('pointer-events', 'all'), F.attr('cursor', ha.overlay), M.selection && (A = M.selection), (function (t) { return t[0][0] === t[1][0] || t[0][1] === t[1][1]; }(A)) && (M.selection = null, f.call(_)), D.end(t, m.name); } } function d(t) { s(this, arguments).moved(t); } function p(t) { s(this, arguments).ended(t); } function g() { const n = this.__brush || { selection: null }; return n.extent = ca(e.apply(this, arguments)), n.dim = t, n; } return c.move = function (n, e, r) { n.tween ? n.on('start.brush', (function (t) { s(this, arguments).beforestart().start(t); })).on('interrupt.brush end.brush', (function (t) { s(this, arguments).end(t); })).tween('brush', (function () { const n = this; const r = n.__brush; const i = s(n, arguments); const o = r.selection; const a = t.input(typeof e === 'function' ? e.apply(this, arguments) : e, r.extent); const u = Gr(o, a); function c(t) { r.selection = t === 1 && a === null ? null : u(t), f.call(n), i.brush(); } return o !== null && a !== null ? c : c(1); })) : n.each((function () { const n = this; const i = arguments; const o = n.__brush; const a = t.input(typeof e === 'function' ? e.apply(n, i) : e, o.extent); const u = s(n, i).beforestart(); Gi(n), o.selection = a === null ? null : a, f.call(n), u.start(r).brush(r).end(r); })); }, c.clear = function (t, n) { c.move(t, null, n); }, l.prototype = {
      beforestart() { return ++this.active == 1 && (this.state.emitter = this, this.starting = !0), this; },
      start(t, n) { return this.starting ? (this.starting = !1, this.emit('start', t, n)) : this.emit('brush', t), this; },
      brush(t, n) { return this.emit('brush', t, n), this; },
      end(t, n) { return --this.active == 0 && (delete this.state.emitter, this.emit('end', t, n)), this; },
      emit(n, e, r) {
        const i = Zn(this.that).datum(); a.call(n, this.that, new Qo(n, {
          sourceEvent: e, target: c, selection: t.output(this.state.selection), mode: r, dispatch: a,
        }), i);
      },
    }, c.extent = function (t) { return arguments.length ? (e = typeof t === 'function' ? t : Ko(ca(t)), c) : e; }, c.filter = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : Ko(!!t), c) : r; }, c.touchable = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : Ko(!!t), c) : i; }, c.handleSize = function (t) { return arguments.length ? (u = +t, c) : u; }, c.keyModifiers = function (t) { return arguments.length ? (o = !!t, c) : o; }, c.on = function () { const t = a.on.apply(a, arguments); return t === a ? c : t; }, c;
  } const Ma = Math.abs; const Ta = Math.cos; const Aa = Math.sin; const Sa = Math.PI; const Ea = Sa / 2; const Na = 2 * Sa; const ka = Math.max; const Ca = 1e-12; function Pa(t, n) { return Array.from({ length: n - t }, ((n, e) => t + e)); } function za(t, n) {
    let e = 0; let r = null; let i = null; let o = null; function a(a) {
      let u; const c = a.length; const f = new Array(c); const s = Pa(0, c); let l = new Array(c * c); const h = new Array(c); let d = 0; a = Float64Array.from({ length: c * c }, n ? (t, n) => a[n % c][n / c | 0] : (t, n) => a[n / c | 0][n % c]); for (let n = 0; n < c; ++n) { let e = 0; for (let r = 0; r < c; ++r)e += a[n * c + r] + t * a[r * c + n]; d += f[n] = e; }u = (d = ka(0, Na - e * c) / d) ? e : Na / c; { let n = 0; r && s.sort(((t, n) => r(f[t], f[n]))); for (const e of s) {
        const r = n; if (t) {
          const t = Pa(1 + ~c, c).filter(((t) => (t < 0 ? a[~t * c + e] : a[e * c + t]))); i && t.sort(((t, n) => i(t < 0 ? -a[~t * c + e] : a[e * c + t], n < 0 ? -a[~n * c + e] : a[e * c + n]))); for (const r of t) {
            if (r < 0) {
              (l[~r * c + e] || (l[~r * c + e] = { source: null, target: null })).target = {
                index: e, startAngle: n, endAngle: n += a[~r * c + e] * d, value: a[~r * c + e],
              };
            } else {
              (l[e * c + r] || (l[e * c + r] = { source: null, target: null })).source = {
                index: e, startAngle: n, endAngle: n += a[e * c + r] * d, value: a[e * c + r],
              };
            }
          }h[e] = {
            index: e, startAngle: r, endAngle: n, value: f[e],
          };
        } else {
          const t = Pa(0, c).filter(((t) => a[e * c + t] || a[t * c + e])); i && t.sort(((t, n) => i(a[e * c + t], a[e * c + n]))); for (const r of t) {
            let t; if (e < r ? (t = l[e * c + r] || (l[e * c + r] = { source: null, target: null }), t.source = {
              index: e, startAngle: n, endAngle: n += a[e * c + r] * d, value: a[e * c + r],
            }) : (t = l[r * c + e] || (l[r * c + e] = { source: null, target: null }), t.target = {
              index: e, startAngle: n, endAngle: n += a[e * c + r] * d, value: a[e * c + r],
            }, e === r && (t.source = t.target)), t.source && t.target && t.source.value < t.target.value) { const n = t.source; t.source = t.target, t.target = n; }
          }h[e] = {
            index: e, startAngle: r, endAngle: n, value: f[e],
          };
        }n += u;
      } } return (l = Object.values(l)).groups = h, o ? l.sort(o) : l;
    } return a.padAngle = function (t) { return arguments.length ? (e = ka(0, t), a) : e; }, a.sortGroups = function (t) { return arguments.length ? (r = t, a) : r; }, a.sortSubgroups = function (t) { return arguments.length ? (i = t, a) : i; }, a.sortChords = function (t) { return arguments.length ? (t == null ? o = null : (n = t, o = function (t, e) { return n(t.source.value + t.target.value, e.source.value + e.target.value); })._ = t, a) : o && o._; let n; }, a;
  } const $a = Math.PI; const Da = 2 * $a; const Ra = 1e-6; const Fa = Da - Ra; function qa(t) { this._ += t[0]; for (let n = 1, e = t.length; n < e; ++n) this._ += arguments[n] + t[n]; } const Ua = class {
    constructor(t) { this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = '', this._append = t == null ? qa : (function (t) { const n = Math.floor(t); if (!(n >= 0)) throw new Error(`invalid digits: ${t}`); if (n > 15) return qa; const e = 10 ** n; return function (t) { this._ += t[0]; for (let n = 1, r = t.length; n < r; ++n) this._ += Math.round(arguments[n] * e) / e + t[n]; }; }(t)); }

    moveTo(t, n) { this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`; }

    closePath() { this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`); }

    lineTo(t, n) { this._append`L${this._x1 = +t},${this._y1 = +n}`; }

    quadraticCurveTo(t, n, e, r) { this._append`Q${+t},${+n},${this._x1 = +e},${this._y1 = +r}`; }

    bezierCurveTo(t, n, e, r, i, o) { this._append`C${+t},${+n},${+e},${+r},${this._x1 = +i},${this._y1 = +o}`; }

    arcTo(t, n, e, r, i) { if (t = +t, n = +n, e = +e, r = +r, (i = +i) < 0) throw new Error(`negative radius: ${i}`); const o = this._x1; const a = this._y1; const u = e - t; const c = r - n; const f = o - t; const s = a - n; const l = f * f + s * s; if (this._x1 === null) this._append`M${this._x1 = t},${this._y1 = n}`; else if (l > Ra) if (Math.abs(s * u - c * f) > Ra && i) { const h = e - o; const d = r - a; const p = u * u + c * c; const g = h * h + d * d; const y = Math.sqrt(p); const v = Math.sqrt(l); const _ = i * Math.tan(($a - Math.acos((p + l - g) / (2 * y * v))) / 2); const b = _ / v; const m = _ / y; Math.abs(b - 1) > Ra && this._append`L${t + b * f},${n + b * s}`, this._append`A${i},${i},0,0,${+(s * h > f * d)},${this._x1 = t + m * u},${this._y1 = n + m * c}`; } else this._append`L${this._x1 = t},${this._y1 = n}`; else; }

    arc(t, n, e, r, i, o) { if (t = +t, n = +n, o = !!o, (e = +e) < 0) throw new Error(`negative radius: ${e}`); const a = e * Math.cos(r); const u = e * Math.sin(r); const c = t + a; const f = n + u; const s = 1 ^ o; let l = o ? r - i : i - r; this._x1 === null ? this._append`M${c},${f}` : (Math.abs(this._x1 - c) > Ra || Math.abs(this._y1 - f) > Ra) && this._append`L${c},${f}`, e && (l < 0 && (l = l % Da + Da), l > Fa ? this._append`A${e},${e},0,1,${s},${t - a},${n - u}A${e},${e},0,1,${s},${this._x1 = c},${this._y1 = f}` : l > Ra && this._append`A${e},${e},0,${+(l >= $a)},${s},${this._x1 = t + e * Math.cos(i)},${this._y1 = n + e * Math.sin(i)}`); }

    rect(t, n, e, r) { this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${e = +e}v${+r}h${-e}Z`; }

    toString() { return this._; }
  }; function Ia() { return new Ua(); }Ia.prototype = Ua.prototype; const Oa = Array.prototype.slice; function Ba(t) { return function () { return t; }; } function Ya(t) { return t.source; } function La(t) { return t.target; } function ja(t) { return t.radius; } function Ha(t) { return t.startAngle; } function Xa(t) { return t.endAngle; } function Ga() { return 0; } function Va() { return 10; } function Wa(t) { let n = Ya; let e = La; let r = ja; let i = ja; let o = Ha; let a = Xa; let u = Ga; let c = null; function f() { let f; const s = n.apply(this, arguments); const l = e.apply(this, arguments); const h = u.apply(this, arguments) / 2; const d = Oa.call(arguments); const p = +r.apply(this, (d[0] = s, d)); let g = o.apply(this, d) - Ea; let y = a.apply(this, d) - Ea; const v = +i.apply(this, (d[0] = l, d)); let _ = o.apply(this, d) - Ea; let b = a.apply(this, d) - Ea; if (c || (c = f = Ia()), h > Ca && (Ma(y - g) > 2 * h + Ca ? y > g ? (g += h, y -= h) : (g -= h, y += h) : g = y = (g + y) / 2, Ma(b - _) > 2 * h + Ca ? b > _ ? (_ += h, b -= h) : (_ -= h, b += h) : _ = b = (_ + b) / 2), c.moveTo(p * Ta(g), p * Aa(g)), c.arc(0, 0, p, g, y), g !== _ || y !== b) if (t) { const m = v - +t.apply(this, arguments); const x = (_ + b) / 2; c.quadraticCurveTo(0, 0, m * Ta(_), m * Aa(_)), c.lineTo(v * Ta(x), v * Aa(x)), c.lineTo(m * Ta(b), m * Aa(b)); } else c.quadraticCurveTo(0, 0, v * Ta(_), v * Aa(_)), c.arc(0, 0, v, _, b); if (c.quadraticCurveTo(0, 0, p * Ta(g), p * Aa(g)), c.closePath(), f) return c = null, `${f}` || null; } return t && (f.headRadius = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : Ba(+n), f) : t; }), f.radius = function (t) { return arguments.length ? (r = i = typeof t === 'function' ? t : Ba(+t), f) : r; }, f.sourceRadius = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : Ba(+t), f) : r; }, f.targetRadius = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : Ba(+t), f) : i; }, f.startAngle = function (t) { return arguments.length ? (o = typeof t === 'function' ? t : Ba(+t), f) : o; }, f.endAngle = function (t) { return arguments.length ? (a = typeof t === 'function' ? t : Ba(+t), f) : a; }, f.padAngle = function (t) { return arguments.length ? (u = typeof t === 'function' ? t : Ba(+t), f) : u; }, f.source = function (t) { return arguments.length ? (n = t, f) : n; }, f.target = function (t) { return arguments.length ? (e = t, f) : e; }, f.context = function (t) { return arguments.length ? (c = t == null ? null : t, f) : c; }, f; } const Za = Array.prototype.slice; function Ka(t, n) { return t - n; } const Qa = (t) => () => t; function Ja(t, n) { for (var e, r = -1, i = n.length; ++r < i;) if (e = tu(t, n[r])) return e; return 0; } function tu(t, n) { for (var e = n[0], r = n[1], i = -1, o = 0, a = t.length, u = a - 1; o < a; u = o++) { const c = t[o]; const f = c[0]; const s = c[1]; const l = t[u]; const h = l[0]; const d = l[1]; if (nu(c, l, n)) return 0; s > r != d > r && e < (h - f) * (r - s) / (d - s) + f && (i = -i); } return i; } function nu(t, n, e) { let r; let i; let o; let a; return (function (t, n, e) { return (n[0] - t[0]) * (e[1] - t[1]) == (e[0] - t[0]) * (n[1] - t[1]); }(t, n, e)) && (i = t[r = +(t[0] === n[0])], o = e[r], a = n[r], i <= o && o <= a || a <= o && o <= i); } function eu() {} const ru = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []]; function iu() { let t = 1; let n = 1; let e = K; let r = u; function i(t) { let n = e(t); if (Array.isArray(n))n = n.slice().sort(Ka); else { const e = M(t, ou); for (n = G(...Z(e[0], e[1], n), n); n[n.length - 1] >= e[1];)n.pop(); for (;n[1] < e[0];)n.shift(); } return n.map(((n) => o(t, n))); } function o(e, i) { const o = i == null ? NaN : +i; if (isNaN(o)) throw new Error(`invalid value: ${i}`); const u = []; const c = []; return (function (e, r, i) { let o; let u; let c; let f; let s; let l; const h = new Array(); const d = new Array(); o = u = -1, f = au(e[0], r), ru[f << 1].forEach(p); for (;++o < t - 1;)c = f, f = au(e[o + 1], r), ru[c | f << 1].forEach(p); ru[f | 0].forEach(p); for (;++u < n - 1;) { for (o = -1, f = au(e[u * t + t], r), s = au(e[u * t], r), ru[f << 1 | s << 2].forEach(p); ++o < t - 1;)c = f, f = au(e[u * t + t + o + 1], r), l = s, s = au(e[u * t + o + 1], r), ru[c | f << 1 | s << 2 | l << 3].forEach(p); ru[f | s << 3].forEach(p); }o = -1, s = e[u * t] >= r, ru[s << 2].forEach(p); for (;++o < t - 1;)l = s, s = au(e[u * t + o + 1], r), ru[s << 2 | l << 3].forEach(p); function p(t) { let n; let e; const r = [t[0][0] + o, t[0][1] + u]; const c = [t[1][0] + o, t[1][1] + u]; const f = a(r); const s = a(c); (n = d[f]) ? (e = h[s]) ? (delete d[n.end], delete h[e.start], n === e ? (n.ring.push(c), i(n.ring)) : h[n.start] = d[e.end] = { start: n.start, end: e.end, ring: n.ring.concat(e.ring) }) : (delete d[n.end], n.ring.push(c), d[n.end = s] = n) : (n = h[s]) ? (e = d[f]) ? (delete h[n.start], delete d[e.end], n === e ? (n.ring.push(c), i(n.ring)) : h[e.start] = d[n.end] = { start: e.start, end: n.end, ring: e.ring.concat(n.ring) }) : (delete h[n.start], n.ring.unshift(r), h[n.start = f] = n) : h[f] = d[s] = { start: f, end: s, ring: [r, c] }; }ru[s << 3].forEach(p); }(e, o, ((t) => { r(t, e, o), (function (t) { for (var n = 0, e = t.length, r = t[e - 1][1] * t[0][0] - t[e - 1][0] * t[0][1]; ++n < e;)r += t[n - 1][1] * t[n][0] - t[n - 1][0] * t[n][1]; return r; }(t)) > 0 ? u.push([t]) : c.push(t); }))), c.forEach(((t) => { for (var n, e = 0, r = u.length; e < r; ++e) if (Ja((n = u[e])[0], t) !== -1) return void n.push(t); })), { type: 'MultiPolygon', value: i, coordinates: u }; } function a(n) { return 2 * n[0] + n[1] * (t + 1) * 4; } function u(e, r, i) { e.forEach(((e) => { const o = e[0]; const a = e[1]; const u = 0 | o; const c = 0 | a; const f = uu(r[c * t + u]); o > 0 && o < t && u === o && (e[0] = cu(o, uu(r[c * t + u - 1]), f, i)), a > 0 && a < n && c === a && (e[1] = cu(a, uu(r[(c - 1) * t + u]), f, i)); })); } return i.contour = o, i.size = function (e) { if (!arguments.length) return [t, n]; const r = Math.floor(e[0]); const o = Math.floor(e[1]); if (!(r >= 0 && o >= 0)) throw new Error('invalid size'); return t = r, n = o, i; }, i.thresholds = function (t) { return arguments.length ? (e = typeof t === 'function' ? t : Array.isArray(t) ? Qa(Za.call(t)) : Qa(t), i) : e; }, i.smooth = function (t) { return arguments.length ? (r = t ? u : eu, i) : r === u; }, i; } function ou(t) { return isFinite(t) ? t : NaN; } function au(t, n) { return t != null && +t >= n; } function uu(t) { return t == null || isNaN(t = +t) ? -1 / 0 : t; } function cu(t, n, e, r) { const i = r - n; const o = e - n; const a = isFinite(i) || isFinite(o) ? i / o : Math.sign(i) / Math.sign(o); return isNaN(a) ? t : t + a - 0.5; } function fu(t) { return t[0]; } function su(t) { return t[1]; } function lu() { return 1; } const hu = 134217729; const du = 33306690738754706e-32; function pu(t, n, e, r, i) { let o; let a; let u; let c; let f = n[0]; let s = r[0]; let l = 0; let h = 0; s > f == s > -f ? (o = f, f = n[++l]) : (o = s, s = r[++h]); let d = 0; if (l < t && h < e) for (s > f == s > -f ? (a = f + o, u = o - (a - f), f = n[++l]) : (a = s + o, u = o - (a - s), s = r[++h]), o = a, u !== 0 && (i[d++] = u); l < t && h < e;)s > f == s > -f ? (a = o + f, c = a - o, u = o - (a - c) + (f - c), f = n[++l]) : (a = o + s, c = a - o, u = o - (a - c) + (s - c), s = r[++h]), o = a, u !== 0 && (i[d++] = u); for (;l < t;)a = o + f, c = a - o, u = o - (a - c) + (f - c), f = n[++l], o = a, u !== 0 && (i[d++] = u); for (;h < e;)a = o + s, c = a - o, u = o - (a - c) + (s - c), s = r[++h], o = a, u !== 0 && (i[d++] = u); return o === 0 && d !== 0 || (i[d++] = o), d; } function gu(t) { return new Float64Array(t); } const yu = 22204460492503146e-32; const vu = 11093356479670487e-47; const _u = gu(4); const bu = gu(8); const mu = gu(12); const xu = gu(16); const wu = gu(4); function Mu(t, n, e, r, i, o) { const a = (n - o) * (e - i); const u = (t - i) * (r - o); const c = a - u; const f = Math.abs(a + u); return Math.abs(c) >= 33306690738754716e-32 * f ? c : -(function (t, n, e, r, i, o, a) { let u; let c; let f; let s; let l; let h; let d; let p; let g; let y; let v; let _; let b; let m; let x; let w; let M; let T; const A = t - i; const S = e - i; const E = n - o; const N = r - o; m = A * N, h = hu * A, d = h - (h - A), p = A - d, h = hu * N, g = h - (h - N), y = N - g, x = p * y - (m - d * g - p * g - d * y), w = E * S, h = hu * E, d = h - (h - E), p = E - d, h = hu * S, g = h - (h - S), y = S - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, _u[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, _u[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, _u[2] = _ - (T - l) + (v - l), _u[3] = T; let k = (function (t, n) { let e = n[0]; for (let r = 1; r < t; r++)e += n[r]; return e; }(4, _u)); let C = yu * a; if (k >= C || -k >= C) return k; if (l = t - A, u = t - (A + l) + (l - i), l = e - S, f = e - (S + l) + (l - i), l = n - E, c = n - (E + l) + (l - o), l = r - N, s = r - (N + l) + (l - o), u === 0 && c === 0 && f === 0 && s === 0) return k; if (C = vu * a + du * Math.abs(k), k += A * s + N * u - (E * f + S * c), k >= C || -k >= C) return k; m = u * N, h = hu * u, d = h - (h - u), p = u - d, h = hu * N, g = h - (h - N), y = N - g, x = p * y - (m - d * g - p * g - d * y), w = c * S, h = hu * c, d = h - (h - c), p = c - d, h = hu * S, g = h - (h - S), y = S - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, wu[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, wu[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, wu[2] = _ - (T - l) + (v - l), wu[3] = T; const P = pu(4, _u, 4, wu, bu); m = A * s, h = hu * A, d = h - (h - A), p = A - d, h = hu * s, g = h - (h - s), y = s - g, x = p * y - (m - d * g - p * g - d * y), w = E * f, h = hu * E, d = h - (h - E), p = E - d, h = hu * f, g = h - (h - f), y = f - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, wu[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, wu[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, wu[2] = _ - (T - l) + (v - l), wu[3] = T; const z = pu(P, bu, 4, wu, mu); m = u * s, h = hu * u, d = h - (h - u), p = u - d, h = hu * s, g = h - (h - s), y = s - g, x = p * y - (m - d * g - p * g - d * y), w = c * f, h = hu * c, d = h - (h - c), p = c - d, h = hu * f, g = h - (h - f), y = f - g, M = p * y - (w - d * g - p * g - d * y), v = x - M, l = x - v, wu[0] = x - (v + l) + (l - M), _ = m + v, l = _ - m, b = m - (_ - l) + (v - l), v = b - w, l = b - v, wu[1] = b - (v + l) + (l - w), T = _ + v, l = T - _, wu[2] = _ - (T - l) + (v - l), wu[3] = T; const $ = pu(z, mu, 4, wu, xu); return xu[$ - 1]; }(t, n, e, r, i, o, f)); } const Tu = 2 ** -52; const Au = new Uint32Array(512); class Su {
    static from(t, n = zu, e = $u) { const r = t.length; const i = new Float64Array(2 * r); for (let o = 0; o < r; o++) { const r = t[o]; i[2 * o] = n(r), i[2 * o + 1] = e(r); } return new Su(i); }

    constructor(t) { const n = t.length >> 1; if (n > 0 && typeof t[0] !== 'number') throw new Error('Expected coords to contain numbers.'); this.coords = t; const e = Math.max(2 * n - 5, 0); this._triangles = new Uint32Array(3 * e), this._halfedges = new Int32Array(3 * e), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update(); }

    update() {
      const {
        coords: t, _hullPrev: n, _hullNext: e, _hullTri: r, _hullHash: i,
      } = this; const o = t.length >> 1; let a = 1 / 0; let u = 1 / 0; let c = -1 / 0; let f = -1 / 0; for (let n = 0; n < o; n++) { const e = t[2 * n]; const r = t[2 * n + 1]; e < a && (a = e), r < u && (u = r), e > c && (c = e), r > f && (f = r), this._ids[n] = n; } const s = (a + c) / 2; const l = (u + f) / 2; let h; let d; let p; for (let n = 0, e = 1 / 0; n < o; n++) { const r = Eu(s, l, t[2 * n], t[2 * n + 1]); r < e && (h = n, e = r); } const g = t[2 * h]; const y = t[2 * h + 1]; for (let n = 0, e = 1 / 0; n < o; n++) { if (n === h) continue; const r = Eu(g, y, t[2 * n], t[2 * n + 1]); r < e && r > 0 && (d = n, e = r); } let v = t[2 * d]; let _ = t[2 * d + 1]; let b = 1 / 0; for (let n = 0; n < o; n++) { if (n === h || n === d) continue; const e = ku(g, y, v, _, t[2 * n], t[2 * n + 1]); e < b && (p = n, b = e); } let m = t[2 * p]; let x = t[2 * p + 1]; if (b === 1 / 0) { for (let n = 0; n < o; n++) this._dists[n] = t[2 * n] - t[0] || t[2 * n + 1] - t[1]; Cu(this._ids, this._dists, 0, o - 1); const n = new Uint32Array(o); let e = 0; for (let t = 0, r = -1 / 0; t < o; t++) { const i = this._ids[t]; const o = this._dists[i]; o > r && (n[e++] = i, r = o); } return this.hull = n.subarray(0, e), this.triangles = new Uint32Array(0), void (this.halfedges = new Uint32Array(0)); } if (Mu(g, y, v, _, m, x) < 0) { const t = d; const n = v; const e = _; d = p, v = m, _ = x, p = t, m = n, x = e; } const w = (function (t, n, e, r, i, o) { const a = e - t; const u = r - n; const c = i - t; const f = o - n; const s = a * a + u * u; const l = c * c + f * f; const h = 0.5 / (a * f - u * c); const d = t + (f * s - u * l) * h; const p = n + (a * l - c * s) * h; return { x: d, y: p }; }(g, y, v, _, m, x)); this._cx = w.x, this._cy = w.y; for (let n = 0; n < o; n++) this._dists[n] = Eu(t[2 * n], t[2 * n + 1], w.x, w.y); Cu(this._ids, this._dists, 0, o - 1), this._hullStart = h; let M = 3; e[h] = n[p] = d, e[d] = n[h] = p, e[p] = n[d] = h, r[h] = 0, r[d] = 1, r[p] = 2, i.fill(-1), i[this._hashKey(g, y)] = h, i[this._hashKey(v, _)] = d, i[this._hashKey(m, x)] = p, this.trianglesLen = 0, this._addTriangle(h, d, p, -1, -1, -1); for (let o, a, u = 0; u < this._ids.length; u++) { const c = this._ids[u]; const f = t[2 * c]; const s = t[2 * c + 1]; if (u > 0 && Math.abs(f - o) <= Tu && Math.abs(s - a) <= Tu) continue; if (o = f, a = s, c === h || c === d || c === p) continue; let l = 0; for (let t = 0, n = this._hashKey(f, s); t < this._hashSize && (l = i[(n + t) % this._hashSize], l === -1 || l === e[l]); t++);l = n[l]; let g; let y = l; for (;g = e[y], Mu(f, s, t[2 * y], t[2 * y + 1], t[2 * g], t[2 * g + 1]) >= 0;) if (y = g, y === l) { y = -1; break; } if (y === -1) continue; let v = this._addTriangle(y, c, e[y], -1, -1, r[y]); r[c] = this._legalize(v + 2), r[y] = v, M++; let _ = e[y]; for (;g = e[_], Mu(f, s, t[2 * _], t[2 * _ + 1], t[2 * g], t[2 * g + 1]) < 0;)v = this._addTriangle(_, c, g, r[c], -1, r[_]), r[c] = this._legalize(v + 2), e[_] = _, M--, _ = g; if (y === l) for (;g = n[y], Mu(f, s, t[2 * g], t[2 * g + 1], t[2 * y], t[2 * y + 1]) < 0;)v = this._addTriangle(g, c, y, -1, r[y], r[g]), this._legalize(v + 2), r[g] = v, e[y] = y, M--, y = g; this._hullStart = n[c] = y, e[y] = n[_] = c, e[c] = _, i[this._hashKey(f, s)] = c, i[this._hashKey(t[2 * y], t[2 * y + 1])] = y; } this.hull = new Uint32Array(M); for (let t = 0, n = this._hullStart; t < M; t++) this.hull[t] = n, n = e[n]; this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }

    _hashKey(t, n) { return Math.floor((function (t, n) { const e = t / (Math.abs(t) + Math.abs(n)); return (n > 0 ? 3 - e : 1 + e) / 4; }(t - this._cx, n - this._cy)) * this._hashSize) % this._hashSize; }

    _legalize(t) { const { _triangles: n, _halfedges: e, coords: r } = this; let i = 0; let o = 0; for (;;) { const a = e[t]; const u = t - t % 3; if (o = u + (t + 2) % 3, a === -1) { if (i === 0) break; t = Au[--i]; continue; } const c = a - a % 3; const f = u + (t + 1) % 3; const s = c + (a + 2) % 3; const l = n[o]; const h = n[t]; const d = n[f]; const p = n[s]; if (Nu(r[2 * l], r[2 * l + 1], r[2 * h], r[2 * h + 1], r[2 * d], r[2 * d + 1], r[2 * p], r[2 * p + 1])) { n[t] = p, n[a] = l; const r = e[s]; if (r === -1) { let n = this._hullStart; do { if (this._hullTri[n] === s) { this._hullTri[n] = t; break; }n = this._hullPrev[n]; } while (n !== this._hullStart); } this._link(t, r), this._link(a, e[o]), this._link(o, s); const u = c + (a + 1) % 3; i < Au.length && (Au[i++] = u); } else { if (i === 0) break; t = Au[--i]; } } return o; }

    _link(t, n) { this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t); }

    _addTriangle(t, n, e, r, i, o) { const a = this.trianglesLen; return this._triangles[a] = t, this._triangles[a + 1] = n, this._triangles[a + 2] = e, this._link(a, r), this._link(a + 1, i), this._link(a + 2, o), this.trianglesLen += 3, a; }
  } function Eu(t, n, e, r) { const i = t - e; const o = n - r; return i * i + o * o; } function Nu(t, n, e, r, i, o, a, u) { const c = t - a; const f = n - u; const s = e - a; const l = r - u; const h = i - a; const d = o - u; const p = s * s + l * l; const g = h * h + d * d; return c * (l * g - p * d) - f * (s * g - p * h) + (c * c + f * f) * (s * d - l * h) < 0; } function ku(t, n, e, r, i, o) { const a = e - t; const u = r - n; const c = i - t; const f = o - n; const s = a * a + u * u; const l = c * c + f * f; const h = 0.5 / (a * f - u * c); const d = (f * s - u * l) * h; const p = (a * l - c * s) * h; return d * d + p * p; } function Cu(t, n, e, r) { if (r - e <= 20) for (let i = e + 1; i <= r; i++) { const r = t[i]; const o = n[r]; let a = i - 1; for (;a >= e && n[t[a]] > o;)t[a + 1] = t[a--]; t[a + 1] = r; } else { let i = e + 1; let o = r; Pu(t, e + r >> 1, i), n[t[e]] > n[t[r]] && Pu(t, e, r), n[t[i]] > n[t[r]] && Pu(t, i, r), n[t[e]] > n[t[i]] && Pu(t, e, i); const a = t[i]; const u = n[a]; for (;;) { do { i++; } while (n[t[i]] < u); do { o--; } while (n[t[o]] > u); if (o < i) break; Pu(t, i, o); }t[e + 1] = t[o], t[o] = a, r - i + 1 >= o - e ? (Cu(t, n, i, r), Cu(t, n, e, o - 1)) : (Cu(t, n, e, o - 1), Cu(t, n, i, r)); } } function Pu(t, n, e) { const r = t[n]; t[n] = t[e], t[e] = r; } function zu(t) { return t[0]; } function $u(t) { return t[1]; } const Du = 1e-6; class Ru {
    constructor() { this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = ''; }

    moveTo(t, n) { this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`; }

    closePath() { this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += 'Z'); }

    lineTo(t, n) { this._ += `L${this._x1 = +t},${this._y1 = +n}`; }

    arc(t, n, e) { const r = (t = +t) + (e = +e); const i = n = +n; if (e < 0) throw new Error('negative radius'); this._x1 === null ? this._ += `M${r},${i}` : (Math.abs(this._x1 - r) > Du || Math.abs(this._y1 - i) > Du) && (this._ += `L${r},${i}`), e && (this._ += `A${e},${e},0,1,1,${t - e},${n}A${e},${e},0,1,1,${this._x1 = r},${this._y1 = i}`); }

    rect(t, n, e, r) { this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+e}v${+r}h${-e}Z`; }

    value() { return this._ || null; }
  } class Fu {
    constructor() { this._ = []; }

    moveTo(t, n) { this._.push([t, n]); }

    closePath() { this._.push(this._[0].slice()); }

    lineTo(t, n) { this._.push([t, n]); }

    value() { return this._.length ? this._ : null; }
  } class qu {
    constructor(t, [n, e, r, i] = [0, 0, 960, 500]) { if (!((r = +r) >= (n = +n) && (i = +i) >= (e = +e))) throw new Error('invalid bounds'); this.delaunay = t, this._circumcenters = new Float64Array(2 * t.points.length), this.vectors = new Float64Array(2 * t.points.length), this.xmax = r, this.xmin = n, this.ymax = i, this.ymin = e, this._init(); }

    update() { return this.delaunay.update(), this._init(), this; }

    _init() { const { delaunay: { points: t, hull: n, triangles: e }, vectors: r } = this; let i; let o; const a = this.circumcenters = this._circumcenters.subarray(0, e.length / 3 * 2); for (let r, u, c = 0, f = 0, s = e.length; c < s; c += 3, f += 2) { const s = 2 * e[c]; const l = 2 * e[c + 1]; const h = 2 * e[c + 2]; const d = t[s]; const p = t[s + 1]; const g = t[l]; const y = t[l + 1]; const v = t[h]; const _ = t[h + 1]; const b = g - d; const m = y - p; const x = v - d; const w = _ - p; const M = 2 * (b * w - m * x); if (Math.abs(M) < 1e-9) { if (void 0 === i) { i = o = 0; for (const e of n)i += t[2 * e], o += t[2 * e + 1]; i /= n.length, o /= n.length; } const e = 1e9 * Math.sign((i - d) * w - (o - p) * x); r = (d + v) / 2 - e * w, u = (p + _) / 2 + e * x; } else { const t = 1 / M; const n = b * b + m * m; const e = x * x + w * w; r = d + (w * n - m * e) * t, u = p + (b * e - x * n) * t; }a[f] = r, a[f + 1] = u; } let u; let c; let f; let s = n[n.length - 1]; let l = 4 * s; let h = t[2 * s]; let d = t[2 * s + 1]; r.fill(0); for (let e = 0; e < n.length; ++e)s = n[e], u = l, c = h, f = d, l = 4 * s, h = t[2 * s], d = t[2 * s + 1], r[u + 2] = r[l] = f - d, r[u + 3] = r[l + 1] = h - c; }

    render(t) { const n = t == null ? t = new Ru() : void 0; const { delaunay: { halfedges: e, inedges: r, hull: i }, circumcenters: o, vectors: a } = this; if (i.length <= 1) return null; for (let n = 0, r = e.length; n < r; ++n) { const r = e[n]; if (r < n) continue; const i = 2 * Math.floor(n / 3); const a = 2 * Math.floor(r / 3); const u = o[i]; const c = o[i + 1]; const f = o[a]; const s = o[a + 1]; this._renderSegment(u, c, f, s, t); } let u; let c = i[i.length - 1]; for (let n = 0; n < i.length; ++n) { u = c, c = i[n]; const e = 2 * Math.floor(r[c] / 3); const f = o[e]; const s = o[e + 1]; const l = 4 * u; const h = this._project(f, s, a[l + 2], a[l + 3]); h && this._renderSegment(f, s, h[0], h[1], t); } return n && n.value(); }

    renderBounds(t) { const n = t == null ? t = new Ru() : void 0; return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value(); }

    renderCell(t, n) { const e = n == null ? n = new Ru() : void 0; const r = this._clip(t); if (r === null || !r.length) return; n.moveTo(r[0], r[1]); let i = r.length; for (;r[0] === r[i - 2] && r[1] === r[i - 1] && i > 1;)i -= 2; for (let t = 2; t < i; t += 2)r[t] === r[t - 2] && r[t + 1] === r[t - 1] || n.lineTo(r[t], r[t + 1]); return n.closePath(), e && e.value(); }

    * cellPolygons() { const { delaunay: { points: t } } = this; for (let n = 0, e = t.length / 2; n < e; ++n) { const t = this.cellPolygon(n); t && (t.index = n, yield t); } }

    cellPolygon(t) { const n = new Fu(); return this.renderCell(t, n), n.value(); }

    _renderSegment(t, n, e, r, i) { let o; const a = this._regioncode(t, n); const u = this._regioncode(e, r); a === 0 && u === 0 ? (i.moveTo(t, n), i.lineTo(e, r)) : (o = this._clipSegment(t, n, e, r, a, u)) && (i.moveTo(o[0], o[1]), i.lineTo(o[2], o[3])); }

    contains(t, n, e) { return (n = +n) == n && (e = +e) == e && this.delaunay._step(t, n, e) === t; }

    * neighbors(t) { const n = this._clip(t); if (n) for (const e of this.delaunay.neighbors(t)) { const t = this._clip(e); if (t)t:for (let r = 0, i = n.length; r < i; r += 2) for (let o = 0, a = t.length; o < a; o += 2) if (n[r] === t[o] && n[r + 1] === t[o + 1] && n[(r + 2) % i] === t[(o + a - 2) % a] && n[(r + 3) % i] === t[(o + a - 1) % a]) { yield e; break t; } } }

    _cell(t) { const { circumcenters: n, delaunay: { inedges: e, halfedges: r, triangles: i } } = this; const o = e[t]; if (o === -1) return null; const a = []; let u = o; do { const e = Math.floor(u / 3); if (a.push(n[2 * e], n[2 * e + 1]), u = u % 3 == 2 ? u - 2 : u + 1, i[u] !== t) break; u = r[u]; } while (u !== o && u !== -1); return a; }

    _clip(t) { if (t === 0 && this.delaunay.hull.length === 1) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin]; const n = this._cell(t); if (n === null) return null; const { vectors: e } = this; const r = 4 * t; return this._simplify(e[r] || e[r + 1] ? this._clipInfinite(t, n, e[r], e[r + 1], e[r + 2], e[r + 3]) : this._clipFinite(t, n)); }

    _clipFinite(t, n) { const e = n.length; let r; let i; let o; let a; let u = null; let c = n[e - 2]; let f = n[e - 1]; let s = this._regioncode(c, f); let l = 0; for (let h = 0; h < e; h += 2) if (r = c, i = f, c = n[h], f = n[h + 1], o = s, s = this._regioncode(c, f), o === 0 && s === 0)a = l, l = 0, u ? u.push(c, f) : u = [c, f]; else { let n; let e; let h; let d; let p; if (o === 0) { if ((n = this._clipSegment(r, i, c, f, o, s)) === null) continue; [e, h, d, p] = n; } else { if ((n = this._clipSegment(c, f, r, i, s, o)) === null) continue; [d, p, e, h] = n, a = l, l = this._edgecode(e, h), a && l && this._edge(t, a, l, u, u.length), u ? u.push(e, h) : u = [e, h]; }a = l, l = this._edgecode(d, p), a && l && this._edge(t, a, l, u, u.length), u ? u.push(d, p) : u = [d, p]; } if (u)a = l, l = this._edgecode(u[0], u[1]), a && l && this._edge(t, a, l, u, u.length); else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin]; return u; }

    _clipSegment(t, n, e, r, i, o) { const a = i < o; for (a && ([t, n, e, r, i, o] = [e, r, t, n, o, i]); ;) { if (i === 0 && o === 0) return a ? [e, r, t, n] : [t, n, e, r]; if (i & o) return null; let u; let c; const f = i || o; 8 & f ? (u = t + (e - t) * (this.ymax - n) / (r - n), c = this.ymax) : 4 & f ? (u = t + (e - t) * (this.ymin - n) / (r - n), c = this.ymin) : 2 & f ? (c = n + (r - n) * (this.xmax - t) / (e - t), u = this.xmax) : (c = n + (r - n) * (this.xmin - t) / (e - t), u = this.xmin), i ? (t = u, n = c, i = this._regioncode(t, n)) : (e = u, r = c, o = this._regioncode(e, r)); } }

    _clipInfinite(t, n, e, r, i, o) { let a; let u = Array.from(n); if ((a = this._project(u[0], u[1], e, r)) && u.unshift(a[0], a[1]), (a = this._project(u[u.length - 2], u[u.length - 1], i, o)) && u.push(a[0], a[1]), u = this._clipFinite(t, u)) for (let n, e = 0, r = u.length, i = this._edgecode(u[r - 2], u[r - 1]); e < r; e += 2)n = i, i = this._edgecode(u[e], u[e + 1]), n && i && (e = this._edge(t, n, i, u, e), r = u.length); else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (u = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]); return u; }

    _edge(t, n, e, r, i) { for (;n !== e;) { let e; let o; switch (n) { case 5: n = 4; continue; case 4: n = 6, e = this.xmax, o = this.ymin; break; case 6: n = 2; continue; case 2: n = 10, e = this.xmax, o = this.ymax; break; case 10: n = 8; continue; case 8: n = 9, e = this.xmin, o = this.ymax; break; case 9: n = 1; continue; case 1: n = 5, e = this.xmin, o = this.ymin; }r[i] === e && r[i + 1] === o || !this.contains(t, e, o) || (r.splice(i, 0, e, o), i += 2); } return i; }

    _project(t, n, e, r) { let i; let o; let a; let u = 1 / 0; if (r < 0) { if (n <= this.ymin) return null; (i = (this.ymin - n) / r) < u && (a = this.ymin, o = t + (u = i) * e); } else if (r > 0) { if (n >= this.ymax) return null; (i = (this.ymax - n) / r) < u && (a = this.ymax, o = t + (u = i) * e); } if (e > 0) { if (t >= this.xmax) return null; (i = (this.xmax - t) / e) < u && (o = this.xmax, a = n + (u = i) * r); } else if (e < 0) { if (t <= this.xmin) return null; (i = (this.xmin - t) / e) < u && (o = this.xmin, a = n + (u = i) * r); } return [o, a]; }

    _edgecode(t, n) { return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0); }

    _regioncode(t, n) { return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0); }

    _simplify(t) { if (t && t.length > 4) { for (let n = 0; n < t.length; n += 2) { const e = (n + 2) % t.length; const r = (n + 4) % t.length; (t[n] === t[e] && t[e] === t[r] || t[n + 1] === t[e + 1] && t[e + 1] === t[r + 1]) && (t.splice(e, 2), n -= 2); }t.length || (t = null); } return t; }
  } const Uu = 2 * Math.PI; const Iu = Math.pow; function Ou(t) { return t[0]; } function Bu(t) { return t[1]; } function Yu(t, n, e) { return [t + Math.sin(t + n) * e, n + Math.cos(t - n) * e]; } class Lu {
    static from(t, n = Ou, e = Bu, r) { return new Lu('length' in t ? (function (t, n, e, r) { const i = t.length; const o = new Float64Array(2 * i); for (let a = 0; a < i; ++a) { const i = t[a]; o[2 * a] = n.call(r, i, a, t), o[2 * a + 1] = e.call(r, i, a, t); } return o; }(t, n, e, r)) : Float64Array.from(function* (t, n, e, r) { let i = 0; for (const o of t) yield n.call(r, o, i, t), yield e.call(r, o, i, t), ++i; }(t, n, e, r))); }

    constructor(t) { this._delaunator = new Su(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init(); }

    update() { return this._delaunator.update(), this._init(), this; }

    _init() { const t = this._delaunator; const n = this.points; if (t.hull && t.hull.length > 2 && (function (t) { const { triangles: n, coords: e } = t; for (let t = 0; t < n.length; t += 3) { const r = 2 * n[t]; const i = 2 * n[t + 1]; const o = 2 * n[t + 2]; if ((e[o] - e[r]) * (e[i + 1] - e[r + 1]) - (e[i] - e[r]) * (e[o + 1] - e[r + 1]) > 1e-10) return !1; } return !0; }(t))) { this.collinear = Int32Array.from({ length: n.length / 2 }, ((t, n) => n)).sort(((t, e) => n[2 * t] - n[2 * e] || n[2 * t + 1] - n[2 * e + 1])); const t = this.collinear[0]; const e = this.collinear[this.collinear.length - 1]; const r = [n[2 * t], n[2 * t + 1], n[2 * e], n[2 * e + 1]]; const i = 1e-8 * Math.hypot(r[3] - r[1], r[2] - r[0]); for (let t = 0, e = n.length / 2; t < e; ++t) { const e = Yu(n[2 * t], n[2 * t + 1], i); n[2 * t] = e[0], n[2 * t + 1] = e[1]; } this._delaunator = new Su(n); } else delete this.collinear; const e = this.halfedges = this._delaunator.halfedges; const r = this.hull = this._delaunator.hull; const i = this.triangles = this._delaunator.triangles; const o = this.inedges.fill(-1); const a = this._hullIndex.fill(-1); for (let t = 0, n = e.length; t < n; ++t) { const n = i[t % 3 == 2 ? t - 2 : t + 1]; e[t] !== -1 && o[n] !== -1 || (o[n] = t); } for (let t = 0, n = r.length; t < n; ++t)a[r[t]] = t; r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], o[r[0]] = 1, r.length === 2 && (o[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1])); }

    voronoi(t) { return new qu(this, t); }

    * neighbors(t) {
      const {
        inedges: n, hull: e, _hullIndex: r, halfedges: i, triangles: o, collinear: a,
      } = this; if (a) { const n = a.indexOf(t); return n > 0 && (yield a[n - 1]), void (n < a.length - 1 && (yield a[n + 1])); } const u = n[t]; if (u === -1) return; let c = u; let f = -1; do { if (yield f = o[c], c = c % 3 == 2 ? c - 2 : c + 1, o[c] !== t) return; if (c = i[c], c === -1) { const n = e[(r[t] + 1) % e.length]; return void (n !== f && (yield n)); } } while (c !== u);
    }

    find(t, n, e = 0) { if ((t = +t) != t || (n = +n) != n) return -1; const r = e; let i; for (;(i = this._step(e, t, n)) >= 0 && i !== e && i !== r;)e = i; return i; }

    _step(t, n, e) {
      const {
        inedges: r, hull: i, _hullIndex: o, halfedges: a, triangles: u, points: c,
      } = this; if (r[t] === -1 || !c.length) return (t + 1) % (c.length >> 1); let f = t; let s = (n - c[2 * t]) ** 2 + (e - c[2 * t + 1]) ** 2; const l = r[t]; let h = l; do { const r = u[h]; const l = (n - c[2 * r]) ** 2 + (e - c[2 * r + 1]) ** 2; if (l < s && (s = l, f = r), h = h % 3 == 2 ? h - 2 : h + 1, u[h] !== t) break; if (h = a[h], h === -1) { if (h = i[(o[t] + 1) % i.length], h !== r && (n - c[2 * h]) ** 2 + (e - c[2 * h + 1]) ** 2 < s) return h; break; } } while (h !== l); return f;
    }

    render(t) { const n = t == null ? t = new Ru() : void 0; const { points: e, halfedges: r, triangles: i } = this; for (let n = 0, o = r.length; n < o; ++n) { const o = r[n]; if (o < n) continue; const a = 2 * i[n]; const u = 2 * i[o]; t.moveTo(e[a], e[a + 1]), t.lineTo(e[u], e[u + 1]); } return this.renderHull(t), n && n.value(); }

    renderPoints(t, n) { void 0 !== n || t && typeof t.moveTo === 'function' || (n = t, t = null), n = n == null ? 2 : +n; const e = t == null ? t = new Ru() : void 0; const { points: r } = this; for (let e = 0, i = r.length; e < i; e += 2) { const i = r[e]; const o = r[e + 1]; t.moveTo(i + n, o), t.arc(i, o, n, 0, Uu); } return e && e.value(); }

    renderHull(t) { const n = t == null ? t = new Ru() : void 0; const { hull: e, points: r } = this; const i = 2 * e[0]; const o = e.length; t.moveTo(r[i], r[i + 1]); for (let n = 1; n < o; ++n) { const i = 2 * e[n]; t.lineTo(r[i], r[i + 1]); } return t.closePath(), n && n.value(); }

    hullPolygon() { const t = new Fu(); return this.renderHull(t), t.value(); }

    renderTriangle(t, n) { const e = n == null ? n = new Ru() : void 0; const { points: r, triangles: i } = this; const o = 2 * i[t *= 3]; const a = 2 * i[t + 1]; const u = 2 * i[t + 2]; return n.moveTo(r[o], r[o + 1]), n.lineTo(r[a], r[a + 1]), n.lineTo(r[u], r[u + 1]), n.closePath(), e && e.value(); }

    * trianglePolygons() { const { triangles: t } = this; for (let n = 0, e = t.length / 3; n < e; ++n) yield this.trianglePolygon(n); }

    trianglePolygon(t) { const n = new Fu(); return this.renderTriangle(t, n), n.value(); }
  } const ju = {}; const Hu = {}; const Xu = 34; const Gu = 10; const Vu = 13; function Wu(t) { return new Function('d', `return {${t.map(((t, n) => `${JSON.stringify(t)}: d[${n}] || ""`)).join(',')}}`); } function Zu(t) { const n = Object.create(null); const e = []; return t.forEach(((t) => { for (const r in t)r in n || e.push(n[r] = r); })), e; } function Ku(t, n) { const e = `${t}`; const r = e.length; return r < n ? new Array(n - r + 1).join(0) + e : e; } function Qu(t) { let n; const e = t.getUTCHours(); const r = t.getUTCMinutes(); const i = t.getUTCSeconds(); const o = t.getUTCMilliseconds(); return isNaN(t) ? 'Invalid Date' : `${(n = t.getUTCFullYear()) < 0 ? `-${Ku(-n, 6)}` : n > 9999 ? `+${Ku(n, 6)}` : Ku(n, 4)}-${Ku(t.getUTCMonth() + 1, 2)}-${Ku(t.getUTCDate(), 2)}${o ? `T${Ku(e, 2)}:${Ku(r, 2)}:${Ku(i, 2)}.${Ku(o, 3)}Z` : i ? `T${Ku(e, 2)}:${Ku(r, 2)}:${Ku(i, 2)}Z` : r || e ? `T${Ku(e, 2)}:${Ku(r, 2)}Z` : ''}`; } function Ju(t) {
    const n = new RegExp(`["${t}\n\r]`); const e = t.charCodeAt(0); function r(t, n) { let r; const i = []; let o = t.length; let a = 0; let u = 0; let c = o <= 0; let f = !1; function s() { if (c) return Hu; if (f) return f = !1, ju; let n; let r; const i = a; if (t.charCodeAt(i) === Xu) { for (;a++ < o && t.charCodeAt(a) !== Xu || t.charCodeAt(++a) === Xu;);return (n = a) >= o ? c = !0 : (r = t.charCodeAt(a++)) === Gu ? f = !0 : r === Vu && (f = !0, t.charCodeAt(a) === Gu && ++a), t.slice(i + 1, n - 1).replace(/""/g, '"'); } for (;a < o;) { if ((r = t.charCodeAt(n = a++)) === Gu)f = !0; else if (r === Vu)f = !0, t.charCodeAt(a) === Gu && ++a; else if (r !== e) continue; return t.slice(i, n); } return c = !0, t.slice(i, o); } for (t.charCodeAt(o - 1) === Gu && --o, t.charCodeAt(o - 1) === Vu && --o; (r = s()) !== Hu;) { for (var l = []; r !== ju && r !== Hu;)l.push(r), r = s(); n && (l = n(l, u++)) == null || i.push(l); } return i; } function i(n, e) { return n.map(((n) => e.map(((t) => a(n[t]))).join(t))); } function o(n) { return n.map(a).join(t); } function a(t) { return t == null ? '' : t instanceof Date ? Qu(t) : n.test(t += '') ? `"${t.replace(/"/g, '""')}"` : t; } return {
      parse(t, n) { let e; let i; const o = r(t, ((t, r) => { if (e) return e(t, r - 1); i = t, e = n ? (function (t, n) { const e = Wu(t); return function (r, i) { return n(e(r), i, t); }; }(t, n)) : Wu(t); })); return o.columns = i || [], o; }, parseRows: r, format(n, e) { return e == null && (e = Zu(n)), [e.map(a).join(t)].concat(i(n, e)).join('\n'); }, formatBody(t, n) { return n == null && (n = Zu(t)), i(t, n).join('\n'); }, formatRows(t) { return t.map(o).join('\n'); }, formatRow: o, formatValue: a,
    };
  } const tc = Ju(','); const nc = tc.parse; const ec = tc.parseRows; const rc = tc.format; const ic = tc.formatBody; const oc = tc.formatRows; const ac = tc.formatRow; const uc = tc.formatValue; const cc = Ju('\t'); const fc = cc.parse; const sc = cc.parseRows; const lc = cc.format; const hc = cc.formatBody; const dc = cc.formatRows; const pc = cc.formatRow; const gc = cc.formatValue; const yc = new Date('2019-01-01T00:00').getHours() || new Date('2019-07-01T00:00').getHours(); function vc(t) { if (!t.ok) throw new Error(`${t.status} ${t.statusText}`); return t.blob(); } function _c(t) { if (!t.ok) throw new Error(`${t.status} ${t.statusText}`); return t.arrayBuffer(); } function bc(t) { if (!t.ok) throw new Error(`${t.status} ${t.statusText}`); return t.text(); } function mc(t, n) { return fetch(t, n).then(bc); } function xc(t) { return function (n, e, r) { return arguments.length === 2 && typeof e === 'function' && (r = e, e = void 0), mc(n, e).then(((n) => t(n, r))); }; } const wc = xc(nc); const Mc = xc(fc); function Tc(t) { if (!t.ok) throw new Error(`${t.status} ${t.statusText}`); if (t.status !== 204 && t.status !== 205) return t.json(); } function Ac(t) { return (n, e) => mc(n, e).then(((n) => (new DOMParser()).parseFromString(n, t))); } const Sc = Ac('application/xml'); const Ec = Ac('text/html'); const Nc = Ac('image/svg+xml'); function kc(t, n, e, r) { if (isNaN(n) || isNaN(e)) return t; let i; let o; let a; let u; let c; let f; let s; let l; let h; let d = t._root; const p = { data: r }; let g = t._x0; let y = t._y0; let v = t._x1; let _ = t._y1; if (!d) return t._root = p, t; for (;d.length;) if ((f = n >= (o = (g + v) / 2)) ? g = o : v = o, (s = e >= (a = (y + _) / 2)) ? y = a : _ = a, i = d, !(d = d[l = s << 1 | f])) return i[l] = p, t; if (u = +t._x.call(null, d.data), c = +t._y.call(null, d.data), n === u && e === c) return p.next = d, i ? i[l] = p : t._root = p, t; do { i = i ? i[l] = new Array(4) : t._root = new Array(4), (f = n >= (o = (g + v) / 2)) ? g = o : v = o, (s = e >= (a = (y + _) / 2)) ? y = a : _ = a; } while ((l = s << 1 | f) == (h = (c >= a) << 1 | u >= o)); return i[h] = d, i[l] = p, t; } function Cc(t, n, e, r, i) { this.node = t, this.x0 = n, this.y0 = e, this.x1 = r, this.y1 = i; } function Pc(t) { return t[0]; } function zc(t) { return t[1]; } function $c(t, n, e) { const r = new Dc(n == null ? Pc : n, e == null ? zc : e, NaN, NaN, NaN, NaN); return t == null ? r : r.addAll(t); } function Dc(t, n, e, r, i, o) { this._x = t, this._y = n, this._x0 = e, this._y0 = r, this._x1 = i, this._y1 = o, this._root = void 0; } function Rc(t) { for (var n = { data: t.data }, e = n; t = t.next;)e = e.next = { data: t.data }; return n; } const Fc = $c.prototype = Dc.prototype; function qc(t) { return function () { return t; }; } function Uc(t) { return 1e-6 * (t() - 0.5); } function Ic(t) { return t.x + t.vx; } function Oc(t) { return t.y + t.vy; } function Bc(t) { return t.index; } function Yc(t, n) { const e = t.get(n); if (!e) throw new Error(`node not found: ${n}`); return e; }Fc.copy = function () { let t; let n; const e = new Dc(this._x, this._y, this._x0, this._y0, this._x1, this._y1); let r = this._root; if (!r) return e; if (!r.length) return e._root = Rc(r), e; for (t = [{ source: r, target: e._root = new Array(4) }]; r = t.pop();) for (let i = 0; i < 4; ++i)(n = r.source[i]) && (n.length ? t.push({ source: n, target: r.target[i] = new Array(4) }) : r.target[i] = Rc(n)); return e; }, Fc.add = function (t) { const n = +this._x.call(null, t); const e = +this._y.call(null, t); return kc(this.cover(n, e), n, e, t); }, Fc.addAll = function (t) { let n; let e; let r; let i; const o = t.length; const a = new Array(o); const u = new Array(o); let c = 1 / 0; let f = 1 / 0; let s = -1 / 0; let l = -1 / 0; for (e = 0; e < o; ++e)isNaN(r = +this._x.call(null, n = t[e])) || isNaN(i = +this._y.call(null, n)) || (a[e] = r, u[e] = i, r < c && (c = r), r > s && (s = r), i < f && (f = i), i > l && (l = i)); if (c > s || f > l) return this; for (this.cover(c, f).cover(s, l), e = 0; e < o; ++e)kc(this, a[e], u[e], t[e]); return this; }, Fc.cover = function (t, n) { if (isNaN(t = +t) || isNaN(n = +n)) return this; let e = this._x0; let r = this._y0; let i = this._x1; let o = this._y1; if (isNaN(e))i = (e = Math.floor(t)) + 1, o = (r = Math.floor(n)) + 1; else { for (var a, u, c = i - e || 1, f = this._root; e > t || t >= i || r > n || n >= o;) switch (u = (n < r) << 1 | t < e, (a = new Array(4))[u] = f, f = a, c *= 2, u) { case 0: i = e + c, o = r + c; break; case 1: e = i - c, o = r + c; break; case 2: i = e + c, r = o - c; break; case 3: e = i - c, r = o - c; } this._root && this._root.length && (this._root = f); } return this._x0 = e, this._y0 = r, this._x1 = i, this._y1 = o, this; }, Fc.data = function () { const t = []; return this.visit(((n) => { if (!n.length) do { t.push(n.data); } while (n = n.next); })), t; }, Fc.extent = function (t) { return arguments.length ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]]; }, Fc.find = function (t, n, e) { let r; let i; let o; let a; let u; let c; let f; let s = this._x0; let l = this._y0; let h = this._x1; let d = this._y1; const p = []; let g = this._root; for (g && p.push(new Cc(g, s, l, h, d)), e == null ? e = 1 / 0 : (s = t - e, l = n - e, h = t + e, d = n + e, e *= e); c = p.pop();) if (!(!(g = c.node) || (i = c.x0) > h || (o = c.y0) > d || (a = c.x1) < s || (u = c.y1) < l)) if (g.length) { const y = (i + a) / 2; const v = (o + u) / 2; p.push(new Cc(g[3], y, v, a, u), new Cc(g[2], i, v, y, u), new Cc(g[1], y, o, a, v), new Cc(g[0], i, o, y, v)), (f = (n >= v) << 1 | t >= y) && (c = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - f], p[p.length - 1 - f] = c); } else { const _ = t - +this._x.call(null, g.data); const b = n - +this._y.call(null, g.data); const m = _ * _ + b * b; if (m < e) { const x = Math.sqrt(e = m); s = t - x, l = n - x, h = t + x, d = n + x, r = g.data; } } return r; }, Fc.remove = function (t) { if (isNaN(o = +this._x.call(null, t)) || isNaN(a = +this._y.call(null, t))) return this; let n; let e; let r; let i; let o; let a; let u; let c; let f; let s; let l; let h; let d = this._root; let p = this._x0; let g = this._y0; let y = this._x1; let v = this._y1; if (!d) return this; if (d.length) for (;;) { if ((f = o >= (u = (p + y) / 2)) ? p = u : y = u, (s = a >= (c = (g + v) / 2)) ? g = c : v = c, n = d, !(d = d[l = s << 1 | f])) return this; if (!d.length) break; (n[l + 1 & 3] || n[l + 2 & 3] || n[l + 3 & 3]) && (e = n, h = l); } for (;d.data !== t;) if (r = d, !(d = d.next)) return this; return (i = d.next) && delete d.next, r ? (i ? r.next = i : delete r.next, this) : n ? (i ? n[l] = i : delete n[l], (d = n[0] || n[1] || n[2] || n[3]) && d === (n[3] || n[2] || n[1] || n[0]) && !d.length && (e ? e[h] = d : this._root = d), this) : (this._root = i, this); }, Fc.removeAll = function (t) { for (let n = 0, e = t.length; n < e; ++n) this.remove(t[n]); return this; }, Fc.root = function () { return this._root; }, Fc.size = function () { let t = 0; return this.visit(((n) => { if (!n.length) do { ++t; } while (n = n.next); })), t; }, Fc.visit = function (t) { let n; let e; let r; let i; let o; let a; const u = []; let c = this._root; for (c && u.push(new Cc(c, this._x0, this._y0, this._x1, this._y1)); n = u.pop();) if (!t(c = n.node, r = n.x0, i = n.y0, o = n.x1, a = n.y1) && c.length) { const f = (r + o) / 2; const s = (i + a) / 2; (e = c[3]) && u.push(new Cc(e, f, s, o, a)), (e = c[2]) && u.push(new Cc(e, r, s, f, a)), (e = c[1]) && u.push(new Cc(e, f, i, o, s)), (e = c[0]) && u.push(new Cc(e, r, i, f, s)); } return this; }, Fc.visitAfter = function (t) { let n; const e = []; const r = []; for (this._root && e.push(new Cc(this._root, this._x0, this._y0, this._x1, this._y1)); n = e.pop();) { const i = n.node; if (i.length) { var o; const a = n.x0; const u = n.y0; const c = n.x1; const f = n.y1; const s = (a + c) / 2; const l = (u + f) / 2; (o = i[0]) && e.push(new Cc(o, a, u, s, l)), (o = i[1]) && e.push(new Cc(o, s, u, c, l)), (o = i[2]) && e.push(new Cc(o, a, l, s, f)), (o = i[3]) && e.push(new Cc(o, s, l, c, f)); }r.push(n); } for (;n = r.pop();)t(n.node, n.x0, n.y0, n.x1, n.y1); return this; }, Fc.x = function (t) { return arguments.length ? (this._x = t, this) : this._x; }, Fc.y = function (t) { return arguments.length ? (this._y = t, this) : this._y; }; const Lc = 1664525; const jc = 1013904223; const Hc = 4294967296; function Xc(t) { return t.x; } function Gc(t) { return t.y; } const Vc = Math.PI * (3 - Math.sqrt(5)); function Wc(t, n) { if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf('e')) < 0) return null; let e; const r = t.slice(0, e); return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(e + 1)]; } function Zc(t) { return (t = Wc(Math.abs(t))) ? t[1] : NaN; } let Kc; const Qc = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i; function Jc(t) {
    if (!(n = Qc.exec(t))) throw new Error(`invalid format: ${t}`); let n; return new tf({
      fill: n[1], align: n[2], sign: n[3], symbol: n[4], zero: n[5], width: n[6], comma: n[7], precision: n[8] && n[8].slice(1), trim: n[9], type: n[10],
    });
  } function tf(t) { this.fill = void 0 === t.fill ? ' ' : `${t.fill}`, this.align = void 0 === t.align ? '>' : `${t.align}`, this.sign = void 0 === t.sign ? '-' : `${t.sign}`, this.symbol = void 0 === t.symbol ? '' : `${t.symbol}`, this.zero = !!t.zero, this.width = void 0 === t.width ? void 0 : +t.width, this.comma = !!t.comma, this.precision = void 0 === t.precision ? void 0 : +t.precision, this.trim = !!t.trim, this.type = void 0 === t.type ? '' : `${t.type}`; } function nf(t, n) { const e = Wc(t, n); if (!e) return `${t}`; const r = e[0]; const i = e[1]; return i < 0 ? `0.${new Array(-i).join('0')}${r}` : r.length > i + 1 ? `${r.slice(0, i + 1)}.${r.slice(i + 1)}` : r + new Array(i - r.length + 2).join('0'); }Jc.prototype = tf.prototype, tf.prototype.toString = function () { return this.fill + this.align + this.sign + this.symbol + (this.zero ? '0' : '') + (void 0 === this.width ? '' : Math.max(1, 0 | this.width)) + (this.comma ? ',' : '') + (void 0 === this.precision ? '' : `.${Math.max(0, 0 | this.precision)}`) + (this.trim ? '~' : '') + this.type; }; const ef = {
    '%': (t, n) => (100 * t).toFixed(n), b: (t) => Math.round(t).toString(2), c: (t) => `${t}`, d(t) { return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString('en').replace(/,/g, '') : t.toString(10); }, e: (t, n) => t.toExponential(n), f: (t, n) => t.toFixed(n), g: (t, n) => t.toPrecision(n), o: (t) => Math.round(t).toString(8), p: (t, n) => nf(100 * t, n), r: nf, s(t, n) { const e = Wc(t, n); if (!e) return `${t}`; const r = e[0]; const i = e[1]; const o = i - (Kc = 3 * Math.max(-8, Math.min(8, Math.floor(i / 3)))) + 1; const a = r.length; return o === a ? r : o > a ? r + new Array(o - a + 1).join('0') : o > 0 ? `${r.slice(0, o)}.${r.slice(o)}` : `0.${new Array(1 - o).join('0')}${Wc(t, Math.max(0, n + o - 1))[0]}`; }, X: (t) => Math.round(t).toString(16).toUpperCase(), x: (t) => Math.round(t).toString(16),
  }; function rf(t) { return t; } let of; const af = Array.prototype.map; const uf = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']; function cf(t) { let n; let e; const r = void 0 === t.grouping || void 0 === t.thousands ? rf : (n = af.call(t.grouping, Number), e = `${t.thousands}`, function (t, r) { for (var i = t.length, o = [], a = 0, u = n[0], c = 0; i > 0 && u > 0 && (c + u + 1 > r && (u = Math.max(1, r - c)), o.push(t.substring(i -= u, i + u)), !((c += u + 1) > r));)u = n[a = (a + 1) % n.length]; return o.reverse().join(e); }); const i = void 0 === t.currency ? '' : `${t.currency[0]}`; const o = void 0 === t.currency ? '' : `${t.currency[1]}`; const a = void 0 === t.decimal ? '.' : `${t.decimal}`; const u = void 0 === t.numerals ? rf : (function (t) { return function (n) { return n.replace(/[0-9]/g, ((n) => t[+n])); }; }(af.call(t.numerals, String))); const c = void 0 === t.percent ? '%' : `${t.percent}`; const f = void 0 === t.minus ? '' : `${t.minus}`; const s = void 0 === t.nan ? 'NaN' : `${t.nan}`; function l(t) { let n = (t = Jc(t)).fill; let e = t.align; const l = t.sign; const h = t.symbol; let d = t.zero; const p = t.width; let g = t.comma; let y = t.precision; let v = t.trim; let _ = t.type; _ === 'n' ? (g = !0, _ = 'g') : ef[_] || (void 0 === y && (y = 12), v = !0, _ = 'g'), (d || n === '0' && e === '=') && (d = !0, n = '0', e = '='); const b = h === '$' ? i : h === '#' && /[boxX]/.test(_) ? `0${_.toLowerCase()}` : ''; const m = h === '$' ? o : /[%p]/.test(_) ? c : ''; const x = ef[_]; const w = /[defgprs%]/.test(_); function M(t) { let i; let o; let c; let h = b; let M = m; if (_ === 'c')M = x(t) + M, t = ''; else { let T = (t = +t) < 0 || 1 / t < 0; if (t = isNaN(t) ? s : x(Math.abs(t), y), v && (t = (function (t) { t:for (var n, e = t.length, r = 1, i = -1; r < e; ++r) switch (t[r]) { case '.': i = n = r; break; case '0': i === 0 && (i = r), n = r; break; default: if (!+t[r]) break t; i > 0 && (i = 0); } return i > 0 ? t.slice(0, i) + t.slice(n + 1) : t; }(t))), T && +t == 0 && l !== '+' && (T = !1), h = (T ? l === '(' ? l : f : l === '-' || l === '(' ? '' : l) + h, M = (_ === 's' ? uf[8 + Kc / 3] : '') + M + (T && l === '(' ? ')' : ''), w) for (i = -1, o = t.length; ++i < o;) if ((c = t.charCodeAt(i)) < 48 || c > 57) { M = (c === 46 ? a + t.slice(i + 1) : t.slice(i)) + M, t = t.slice(0, i); break; } }g && !d && (t = r(t, 1 / 0)); let A = h.length + t.length + M.length; let S = A < p ? new Array(p - A + 1).join(n) : ''; switch (g && d && (t = r(S + t, S.length ? p - M.length : 1 / 0), S = ''), e) { case '<': t = h + t + M + S; break; case '=': t = h + S + t + M; break; case '^': t = S.slice(0, A = S.length >> 1) + h + t + M + S.slice(A); break; default: t = S + h + t + M; } return u(t); } return y = void 0 === y ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, y)) : Math.max(0, Math.min(20, y)), M.toString = function () { return `${t}`; }, M; } return { format: l, formatPrefix(t, n) { const e = l(((t = Jc(t)).type = 'f', t)); const r = 3 * Math.max(-8, Math.min(8, Math.floor(Zc(n) / 3))); const i = 10 ** -r; const o = uf[8 + r / 3]; return function (t) { return e(i * t) + o; }; } }; } function ff(n) { return of = cf(n), t.format = of.format, t.formatPrefix = of.formatPrefix, of; } function sf(t) { return Math.max(0, -Zc(Math.abs(t))); } function lf(t, n) { return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(Zc(n) / 3))) - Zc(Math.abs(t))); } function hf(t, n) { return t = Math.abs(t), n = Math.abs(n) - t, Math.max(0, Zc(n) - Zc(t)) + 1; }t.format = void 0, t.formatPrefix = void 0, ff({ thousands: ',', grouping: [3], currency: ['$', ''] }); const df = 1e-6; const pf = 1e-12; const gf = Math.PI; const yf = gf / 2; const vf = gf / 4; const _f = 2 * gf; const bf = 180 / gf; const mf = gf / 180; const xf = Math.abs; const wf = Math.atan; const Mf = Math.atan2; const Tf = Math.cos; const Af = Math.ceil; const Sf = Math.exp; const Ef = Math.hypot; const Nf = Math.log; const kf = Math.pow; const Cf = Math.sin; const Pf = Math.sign || function (t) { return t > 0 ? 1 : t < 0 ? -1 : 0; }; const zf = Math.sqrt; const $f = Math.tan; function Df(t) { return t > 1 ? 0 : t < -1 ? gf : Math.acos(t); } function Rf(t) { return t > 1 ? yf : t < -1 ? -yf : Math.asin(t); } function Ff(t) { return (t = Cf(t / 2)) * t; } function qf() {} function Uf(t, n) { t && Of.hasOwnProperty(t.type) && Of[t.type](t, n); } const If = { Feature(t, n) { Uf(t.geometry, n); }, FeatureCollection(t, n) { for (let e = t.features, r = -1, i = e.length; ++r < i;)Uf(e[r].geometry, n); } }; var Of = {
    Sphere(t, n) { n.sphere(); }, Point(t, n) { t = t.coordinates, n.point(t[0], t[1], t[2]); }, MultiPoint(t, n) { for (let e = t.coordinates, r = -1, i = e.length; ++r < i;)t = e[r], n.point(t[0], t[1], t[2]); }, LineString(t, n) { Bf(t.coordinates, n, 0); }, MultiLineString(t, n) { for (let e = t.coordinates, r = -1, i = e.length; ++r < i;)Bf(e[r], n, 0); }, Polygon(t, n) { Yf(t.coordinates, n); }, MultiPolygon(t, n) { for (let e = t.coordinates, r = -1, i = e.length; ++r < i;)Yf(e[r], n); }, GeometryCollection(t, n) { for (let e = t.geometries, r = -1, i = e.length; ++r < i;)Uf(e[r], n); },
  }; function Bf(t, n, e) { let r; let i = -1; const o = t.length - e; for (n.lineStart(); ++i < o;)r = t[i], n.point(r[0], r[1], r[2]); n.lineEnd(); } function Yf(t, n) { let e = -1; const r = t.length; for (n.polygonStart(); ++e < r;)Bf(t[e], n, 1); n.polygonEnd(); } function Lf(t, n) { t && If.hasOwnProperty(t.type) ? If[t.type](t, n) : Uf(t, n); } let jf; let Hf; let Xf; let Gf; let Vf; let Wf; let Zf; let Kf; let Qf; let Jf; let ts; let ns; let es; let rs; let is; let os; let as = new T(); let us = new T(); var cs = {
    point: qf, lineStart: qf, lineEnd: qf, polygonStart() { as = new T(), cs.lineStart = fs, cs.lineEnd = ss; }, polygonEnd() { const t = +as; us.add(t < 0 ? _f + t : t), this.lineStart = this.lineEnd = this.point = qf; }, sphere() { us.add(_f); },
  }; function fs() { cs.point = ls; } function ss() { hs(jf, Hf); } function ls(t, n) { cs.point = hs, jf = t, Hf = n, Xf = t *= mf, Gf = Tf(n = (n *= mf) / 2 + vf), Vf = Cf(n); } function hs(t, n) { const e = (t *= mf) - Xf; const r = e >= 0 ? 1 : -1; const i = r * e; const o = Tf(n = (n *= mf) / 2 + vf); const a = Cf(n); const u = Vf * a; const c = Gf * o + u * Tf(i); const f = u * r * Cf(i); as.add(Mf(f, c)), Xf = t, Gf = o, Vf = a; } function ds(t) { return [Mf(t[1], t[0]), Rf(t[2])]; } function ps(t) { const n = t[0]; const e = t[1]; const r = Tf(e); return [r * Tf(n), r * Cf(n), Cf(e)]; } function gs(t, n) { return t[0] * n[0] + t[1] * n[1] + t[2] * n[2]; } function ys(t, n) { return [t[1] * n[2] - t[2] * n[1], t[2] * n[0] - t[0] * n[2], t[0] * n[1] - t[1] * n[0]]; } function vs(t, n) { t[0] += n[0], t[1] += n[1], t[2] += n[2]; } function _s(t, n) { return [t[0] * n, t[1] * n, t[2] * n]; } function bs(t) { const n = zf(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]); t[0] /= n, t[1] /= n, t[2] /= n; } let ms; let xs; let ws; let Ms; let Ts; let As; let Ss; let Es; let Ns; let ks; let Cs; let Ps; let zs; let $s; let Ds; let Rs; var Fs = {
    point: qs, lineStart: Is, lineEnd: Os, polygonStart() { Fs.point = Bs, Fs.lineStart = Ys, Fs.lineEnd = Ls, rs = new T(), cs.polygonStart(); }, polygonEnd() { cs.polygonEnd(), Fs.point = qs, Fs.lineStart = Is, Fs.lineEnd = Os, as < 0 ? (Wf = -(Kf = 180), Zf = -(Qf = 90)) : rs > df ? Qf = 90 : rs < -df && (Zf = -90), os[0] = Wf, os[1] = Kf; }, sphere() { Wf = -(Kf = 180), Zf = -(Qf = 90); },
  }; function qs(t, n) { is.push(os = [Wf = t, Kf = t]), n < Zf && (Zf = n), n > Qf && (Qf = n); } function Us(t, n) { const e = ps([t * mf, n * mf]); if (es) { const r = ys(es, e); let i = ys([r[1], -r[0], 0], r); bs(i), i = ds(i); let o; const a = t - Jf; const u = a > 0 ? 1 : -1; let c = i[0] * bf * u; const f = xf(a) > 180; f ^ (u * Jf < c && c < u * t) ? (o = i[1] * bf) > Qf && (Qf = o) : f ^ (u * Jf < (c = (c + 360) % 360 - 180) && c < u * t) ? (o = -i[1] * bf) < Zf && (Zf = o) : (n < Zf && (Zf = n), n > Qf && (Qf = n)), f ? t < Jf ? js(Wf, t) > js(Wf, Kf) && (Kf = t) : js(t, Kf) > js(Wf, Kf) && (Wf = t) : Kf >= Wf ? (t < Wf && (Wf = t), t > Kf && (Kf = t)) : t > Jf ? js(Wf, t) > js(Wf, Kf) && (Kf = t) : js(t, Kf) > js(Wf, Kf) && (Wf = t); } else is.push(os = [Wf = t, Kf = t]); n < Zf && (Zf = n), n > Qf && (Qf = n), es = e, Jf = t; } function Is() { Fs.point = Us; } function Os() { os[0] = Wf, os[1] = Kf, Fs.point = qs, es = null; } function Bs(t, n) { if (es) { const e = t - Jf; rs.add(xf(e) > 180 ? e + (e > 0 ? 360 : -360) : e); } else ts = t, ns = n; cs.point(t, n), Us(t, n); } function Ys() { cs.lineStart(); } function Ls() { Bs(ts, ns), cs.lineEnd(), xf(rs) > df && (Wf = -(Kf = 180)), os[0] = Wf, os[1] = Kf, es = null; } function js(t, n) { return (n -= t) < 0 ? n + 360 : n; } function Hs(t, n) { return t[0] - n[0]; } function Xs(t, n) { return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n; } var Gs = {
    sphere: qf, point: Vs, lineStart: Zs, lineEnd: Js, polygonStart() { Gs.lineStart = tl, Gs.lineEnd = nl; }, polygonEnd() { Gs.lineStart = Zs, Gs.lineEnd = Js; },
  }; function Vs(t, n) { t *= mf; const e = Tf(n *= mf); Ws(e * Tf(t), e * Cf(t), Cf(n)); } function Ws(t, n, e) { ++ms, ws += (t - ws) / ms, Ms += (n - Ms) / ms, Ts += (e - Ts) / ms; } function Zs() { Gs.point = Ks; } function Ks(t, n) { t *= mf; const e = Tf(n *= mf); $s = e * Tf(t), Ds = e * Cf(t), Rs = Cf(n), Gs.point = Qs, Ws($s, Ds, Rs); } function Qs(t, n) { t *= mf; const e = Tf(n *= mf); const r = e * Tf(t); const i = e * Cf(t); const o = Cf(n); var a = Mf(zf((a = Ds * o - Rs * i) * a + (a = Rs * r - $s * o) * a + (a = $s * i - Ds * r) * a), $s * r + Ds * i + Rs * o); xs += a, As += a * ($s + ($s = r)), Ss += a * (Ds + (Ds = i)), Es += a * (Rs + (Rs = o)), Ws($s, Ds, Rs); } function Js() { Gs.point = Vs; } function tl() { Gs.point = el; } function nl() { rl(Ps, zs), Gs.point = Vs; } function el(t, n) { Ps = t, zs = n, t *= mf, n *= mf, Gs.point = rl; const e = Tf(n); $s = e * Tf(t), Ds = e * Cf(t), Rs = Cf(n), Ws($s, Ds, Rs); } function rl(t, n) { t *= mf; const e = Tf(n *= mf); const r = e * Tf(t); const i = e * Cf(t); const o = Cf(n); const a = Ds * o - Rs * i; const u = Rs * r - $s * o; const c = $s * i - Ds * r; const f = Ef(a, u, c); const s = Rf(f); const l = f && -s / f; Ns.add(l * a), ks.add(l * u), Cs.add(l * c), xs += s, As += s * ($s + ($s = r)), Ss += s * (Ds + (Ds = i)), Es += s * (Rs + (Rs = o)), Ws($s, Ds, Rs); } function il(t) { return function () { return t; }; } function ol(t, n) { function e(e, r) { return e = t(e, r), n(e[0], e[1]); } return t.invert && n.invert && (e.invert = function (e, r) { return (e = n.invert(e, r)) && t.invert(e[0], e[1]); }), e; } function al(t, n) { return xf(t) > gf && (t -= Math.round(t / _f) * _f), [t, n]; } function ul(t, n, e) { return (t %= _f) ? n || e ? ol(fl(t), sl(n, e)) : fl(t) : n || e ? sl(n, e) : al; } function cl(t) { return function (n, e) { return xf(n += t) > gf && (n -= Math.round(n / _f) * _f), [n, e]; }; } function fl(t) { const n = cl(t); return n.invert = cl(-t), n; } function sl(t, n) { const e = Tf(t); const r = Cf(t); const i = Tf(n); const o = Cf(n); function a(t, n) { const a = Tf(n); const u = Tf(t) * a; const c = Cf(t) * a; const f = Cf(n); const s = f * e + u * r; return [Mf(c * i - s * o, u * e - f * r), Rf(s * i + c * o)]; } return a.invert = function (t, n) { const a = Tf(n); const u = Tf(t) * a; const c = Cf(t) * a; const f = Cf(n); const s = f * i - c * o; return [Mf(c * i + f * o, u * e + s * r), Rf(s * e - u * r)]; }, a; } function ll(t) { function n(n) { return (n = t(n[0] * mf, n[1] * mf))[0] *= bf, n[1] *= bf, n; } return t = ul(t[0] * mf, t[1] * mf, t.length > 2 ? t[2] * mf : 0), n.invert = function (n) { return (n = t.invert(n[0] * mf, n[1] * mf))[0] *= bf, n[1] *= bf, n; }, n; } function hl(t, n, e, r, i, o) { if (e) { const a = Tf(n); const u = Cf(n); const c = r * e; i == null ? (i = n + r * _f, o = n - c / 2) : (i = dl(a, i), o = dl(a, o), (r > 0 ? i < o : i > o) && (i += r * _f)); for (var f, s = i; r > 0 ? s > o : s < o; s -= c)f = ds([a, -u * Tf(s), -u * Cf(s)]), t.point(f[0], f[1]); } } function dl(t, n) { (n = ps(n))[0] -= t, bs(n); const e = Df(-n[1]); return ((-n[2] < 0 ? -e : e) + _f - df) % _f; } function pl() {
    let t; let n = []; return {
      point(n, e, r) { t.push([n, e, r]); }, lineStart() { n.push(t = []); }, lineEnd: qf, rejoin() { n.length > 1 && n.push(n.pop().concat(n.shift())); }, result() { const e = n; return n = [], t = null, e; },
    };
  } function gl(t, n) { return xf(t[0] - n[0]) < df && xf(t[1] - n[1]) < df; } function yl(t, n, e, r) { this.x = t, this.z = n, this.o = e, this.e = r, this.v = !1, this.n = this.p = null; } function vl(t, n, e, r, i) { let o; let a; const u = []; const c = []; if (t.forEach(((t) => { if (!((n = t.length - 1) <= 0)) { var n; let e; let r = t[0]; const a = t[n]; if (gl(r, a)) { if (!r[2] && !a[2]) { for (i.lineStart(), o = 0; o < n; ++o)i.point((r = t[o])[0], r[1]); return void i.lineEnd(); }a[0] += 2 * df; }u.push(e = new yl(r, t, null, !0)), c.push(e.o = new yl(r, null, e, !1)), u.push(e = new yl(a, t, null, !1)), c.push(e.o = new yl(a, null, e, !0)); } })), u.length) { for (c.sort(n), _l(u), _l(c), o = 0, a = c.length; o < a; ++o)c[o].e = e = !e; for (var f, s, l = u[0]; ;) { for (var h = l, d = !0; h.v;) if ((h = h.n) === l) return; f = h.z, i.lineStart(); do { if (h.v = h.o.v = !0, h.e) { if (d) for (o = 0, a = f.length; o < a; ++o)i.point((s = f[o])[0], s[1]); else r(h.x, h.n.x, 1, i); h = h.n; } else { if (d) for (f = h.p.z, o = f.length - 1; o >= 0; --o)i.point((s = f[o])[0], s[1]); else r(h.x, h.p.x, -1, i); h = h.p; }f = (h = h.o).z, d = !d; } while (!h.v); i.lineEnd(); } } } function _l(t) { if (n = t.length) { for (var n, e, r = 0, i = t[0]; ++r < n;)i.n = e = t[r], e.p = i, i = e; i.n = e = t[0], e.p = i; } } function bl(t) { return xf(t[0]) <= gf ? t[0] : Pf(t[0]) * ((xf(t[0]) + gf) % _f - gf); } function ml(t, n) { const e = bl(n); let r = n[1]; const i = Cf(r); const o = [Cf(e), -Tf(e), 0]; let a = 0; let u = 0; const c = new T(); i === 1 ? r = yf + df : i === -1 && (r = -yf - df); for (let f = 0, s = t.length; f < s; ++f) if (h = (l = t[f]).length) for (var l, h, d = l[h - 1], p = bl(d), g = d[1] / 2 + vf, y = Cf(g), v = Tf(g), _ = 0; _ < h; ++_, p = m, y = w, v = M, d = b) { var b = l[_]; var m = bl(b); const x = b[1] / 2 + vf; var w = Cf(x); var M = Tf(x); const A = m - p; const S = A >= 0 ? 1 : -1; const E = S * A; const N = E > gf; const k = y * w; if (c.add(Mf(k * S * Cf(E), v * M + k * Tf(E))), a += N ? A + S * _f : A, N ^ p >= e ^ m >= e) { const C = ys(ps(d), ps(b)); bs(C); const P = ys(o, C); bs(P); const z = (N ^ A >= 0 ? -1 : 1) * Rf(P[2]); (r > z || r === z && (C[0] || C[1])) && (u += N ^ A >= 0 ? 1 : -1); } } return (a < -df || a < df && c < -pf) ^ 1 & u; } function xl(t, n, e, r) {
    return function (i) {
      let o; let a; let u; const c = n(i); const f = pl(); const s = n(f); let l = !1; var h = {
        point: d, lineStart: g, lineEnd: y, polygonStart() { h.point = v, h.lineStart = _, h.lineEnd = b, a = [], o = []; }, polygonEnd() { h.point = d, h.lineStart = g, h.lineEnd = y, a = ft(a); const t = ml(o, r); a.length ? (l || (i.polygonStart(), l = !0), vl(a, Ml, t, e, i)) : t && (l || (i.polygonStart(), l = !0), i.lineStart(), e(null, null, 1, i), i.lineEnd()), l && (i.polygonEnd(), l = !1), a = o = null; }, sphere() { i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd(); },
      }; function d(n, e) { t(n, e) && i.point(n, e); } function p(t, n) { c.point(t, n); } function g() { h.point = p, c.lineStart(); } function y() { h.point = d, c.lineEnd(); } function v(t, n) { u.push([t, n]), s.point(t, n); } function _() { s.lineStart(), u = []; } function b() { v(u[0][0], u[0][1]), s.lineEnd(); let t; let n; let e; let r; const c = s.clean(); const h = f.result(); const d = h.length; if (u.pop(), o.push(u), u = null, d) if (1 & c) { if ((n = (e = h[0]).length - 1) > 0) { for (l || (i.polygonStart(), l = !0), i.lineStart(), t = 0; t < n; ++t)i.point((r = e[t])[0], r[1]); i.lineEnd(); } } else d > 1 && 2 & c && h.push(h.pop().concat(h.shift())), a.push(h.filter(wl)); } return h;
    };
  } function wl(t) { return t.length > 1; } function Ml(t, n) { return ((t = t.x)[0] < 0 ? t[1] - yf - df : yf - t[1]) - ((n = n.x)[0] < 0 ? n[1] - yf - df : yf - n[1]); }al.invert = al; const Tl = xl((() => !0), ((t) => {
    let n; let e = NaN; let r = NaN; let i = NaN; return {
      lineStart() { t.lineStart(), n = 1; }, point(o, a) { const u = o > 0 ? gf : -gf; const c = xf(o - e); xf(c - gf) < df ? (t.point(e, r = (r + a) / 2 > 0 ? yf : -yf), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(u, r), t.point(o, r), n = 0) : i !== u && c >= gf && (xf(e - i) < df && (e -= i * df), xf(o - u) < df && (o -= u * df), r = (function (t, n, e, r) { let i; let o; const a = Cf(t - e); return xf(a) > df ? wf((Cf(n) * (o = Tf(r)) * Cf(e) - Cf(r) * (i = Tf(n)) * Cf(t)) / (i * o * a)) : (n + r) / 2; }(e, r, o, a)), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(u, r), n = 0), t.point(e = o, r = a), i = u; }, lineEnd() { t.lineEnd(), e = r = NaN; }, clean() { return 2 - n; },
    };
  }), ((t, n, e, r) => { let i; if (t == null)i = e * yf, r.point(-gf, i), r.point(0, i), r.point(gf, i), r.point(gf, 0), r.point(gf, -i), r.point(0, -i), r.point(-gf, -i), r.point(-gf, 0), r.point(-gf, i); else if (xf(t[0] - n[0]) > df) { const o = t[0] < n[0] ? gf : -gf; i = e * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i); } else r.point(n[0], n[1]); }), [-gf, -yf]); function Al(t) {
    const n = Tf(t); const e = 2 * mf; const r = n > 0; const i = xf(n) > df; function o(t, e) { return Tf(t) * Tf(e) > n; } function a(t, e, r) { const i = [1, 0, 0]; const o = ys(ps(t), ps(e)); const a = gs(o, o); const u = o[0]; const c = a - u * u; if (!c) return !r && t; const f = n * a / c; const s = -n * u / c; const l = ys(i, o); const h = _s(i, f); vs(h, _s(o, s)); const d = l; const p = gs(h, d); const g = gs(d, d); const y = p * p - g * (gs(h, h) - 1); if (!(y < 0)) { const v = zf(y); let _ = _s(d, (-p - v) / g); if (vs(_, h), _ = ds(_), !r) return _; let b; let m = t[0]; let x = e[0]; let w = t[1]; let M = e[1]; x < m && (b = m, m = x, x = b); const T = x - m; const A = xf(T - gf) < df; if (!A && M < w && (b = w, w = M, M = b), A || T < df ? A ? w + M > 0 ^ _[1] < (xf(_[0] - m) < df ? w : M) : w <= _[1] && _[1] <= M : T > gf ^ (m <= _[0] && _[0] <= x)) { const S = _s(d, (-p + v) / g); return vs(S, h), [_, ds(S)]; } } } function u(n, e) { const i = r ? t : gf - t; let o = 0; return n < -i ? o |= 1 : n > i && (o |= 2), e < -i ? o |= 4 : e > i && (o |= 8), o; } return xl(o, ((t) => {
      let n; let e; let c; let f; let s; return {
        lineStart() { f = c = !1, s = 1; }, point(l, h) { let d; const p = [l, h]; const g = o(l, h); const y = r ? g ? 0 : u(l, h) : g ? u(l + (l < 0 ? gf : -gf), h) : 0; if (!n && (f = c = g) && t.lineStart(), g !== c && (!(d = a(n, p)) || gl(n, d) || gl(p, d)) && (p[2] = 1), g !== c)s = 0, g ? (t.lineStart(), d = a(p, n), t.point(d[0], d[1])) : (d = a(n, p), t.point(d[0], d[1], 2), t.lineEnd()), n = d; else if (i && n && r ^ g) { let v; y & e || !(v = a(p, n, !0)) || (s = 0, r ? (t.lineStart(), t.point(v[0][0], v[0][1]), t.point(v[1][0], v[1][1]), t.lineEnd()) : (t.point(v[1][0], v[1][1]), t.lineEnd(), t.lineStart(), t.point(v[0][0], v[0][1], 3))); }!g || n && gl(n, p) || t.point(p[0], p[1]), n = p, c = g, e = y; }, lineEnd() { c && t.lineEnd(), n = null; }, clean() { return s | (f && c) << 1; },
      };
    }), ((n, r, i, o) => { hl(o, t, e, i, n, r); }), r ? [0, -t] : [-gf, t - gf]);
  } let Sl; let El; let Nl; let kl; const Cl = 1e9; const Pl = -Cl; function zl(t, n, e, r) {
    function i(i, o) { return t <= i && i <= e && n <= o && o <= r; } function o(i, o, u, f) { let s = 0; let l = 0; if (i == null || (s = a(i, u)) !== (l = a(o, u)) || c(i, o) < 0 ^ u > 0) do { f.point(s === 0 || s === 3 ? t : e, s > 1 ? r : n); } while ((s = (s + u + 4) % 4) !== l); else f.point(o[0], o[1]); } function a(r, i) { return xf(r[0] - t) < df ? i > 0 ? 0 : 3 : xf(r[0] - e) < df ? i > 0 ? 2 : 1 : xf(r[1] - n) < df ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2; } function u(t, n) { return c(t.x, n.x); } function c(t, n) { const e = a(t, 1); const r = a(n, 1); return e !== r ? e - r : e === 0 ? n[1] - t[1] : e === 1 ? t[0] - n[0] : e === 2 ? t[1] - n[1] : n[0] - t[0]; } return function (a) {
      let c; let f; let s; let l; let h; let d; let p; let g; let y; let v; let _; let b = a; const m = pl(); var x = {
        point: w, lineStart() { x.point = M, f && f.push(s = []); v = !0, y = !1, p = g = NaN; }, lineEnd() { c && (M(l, h), d && y && m.rejoin(), c.push(m.result())); x.point = w, y && b.lineEnd(); }, polygonStart() { b = m, c = [], f = [], _ = !0; }, polygonEnd() { const n = (function () { for (var n = 0, e = 0, i = f.length; e < i; ++e) for (var o, a, u = f[e], c = 1, s = u.length, l = u[0], h = l[0], d = l[1]; c < s; ++c)o = h, a = d, h = (l = u[c])[0], d = l[1], a <= r ? d > r && (h - o) * (r - a) > (d - a) * (t - o) && ++n : d <= r && (h - o) * (r - a) < (d - a) * (t - o) && --n; return n; }()); const e = _ && n; const i = (c = ft(c)).length; (e || i) && (a.polygonStart(), e && (a.lineStart(), o(null, null, 1, a), a.lineEnd()), i && vl(c, u, n, o, a), a.polygonEnd()); b = a, c = f = s = null; },
      }; function w(t, n) { i(t, n) && b.point(t, n); } function M(o, a) { const u = i(o, a); if (f && s.push([o, a]), v)l = o, h = a, d = u, v = !1, u && (b.lineStart(), b.point(o, a)); else if (u && y)b.point(o, a); else { const c = [p = Math.max(Pl, Math.min(Cl, p)), g = Math.max(Pl, Math.min(Cl, g))]; const m = [o = Math.max(Pl, Math.min(Cl, o)), a = Math.max(Pl, Math.min(Cl, a))]; !(function (t, n, e, r, i, o) { let a; const u = t[0]; const c = t[1]; let f = 0; let s = 1; const l = n[0] - u; const h = n[1] - c; if (a = e - u, l || !(a > 0)) { if (a /= l, l < 0) { if (a < f) return; a < s && (s = a); } else if (l > 0) { if (a > s) return; a > f && (f = a); } if (a = i - u, l || !(a < 0)) { if (a /= l, l < 0) { if (a > s) return; a > f && (f = a); } else if (l > 0) { if (a < f) return; a < s && (s = a); } if (a = r - c, h || !(a > 0)) { if (a /= h, h < 0) { if (a < f) return; a < s && (s = a); } else if (h > 0) { if (a > s) return; a > f && (f = a); } if (a = o - c, h || !(a < 0)) { if (a /= h, h < 0) { if (a > s) return; a > f && (f = a); } else if (h > 0) { if (a < f) return; a < s && (s = a); } return f > 0 && (t[0] = u + f * l, t[1] = c + f * h), s < 1 && (n[0] = u + s * l, n[1] = c + s * h), !0; } } } } }(c, m, t, n, e, r)) ? u && (b.lineStart(), b.point(o, a), _ = !1) : (y || (b.lineStart(), b.point(c[0], c[1])), b.point(m[0], m[1]), u || b.lineEnd(), _ = !1); }p = o, g = a, y = u; } return x;
    };
  } var $l = {
    sphere: qf, point: qf, lineStart() { $l.point = Rl, $l.lineEnd = Dl; }, lineEnd: qf, polygonStart: qf, polygonEnd: qf,
  }; function Dl() { $l.point = $l.lineEnd = qf; } function Rl(t, n) { El = t *= mf, Nl = Cf(n *= mf), kl = Tf(n), $l.point = Fl; } function Fl(t, n) { t *= mf; const e = Cf(n *= mf); const r = Tf(n); const i = xf(t - El); const o = Tf(i); const a = r * Cf(i); const u = kl * e - Nl * r * o; const c = Nl * e + kl * r * o; Sl.add(Mf(zf(a * a + u * u), c)), El = t, Nl = e, kl = r; } function ql(t) { return Sl = new T(), Lf(t, $l), +Sl; } const Ul = [null, null]; const Il = { type: 'LineString', coordinates: Ul }; function Ol(t, n) { return Ul[0] = t, Ul[1] = n, ql(Il); } const Bl = { Feature(t, n) { return Ll(t.geometry, n); }, FeatureCollection(t, n) { for (let e = t.features, r = -1, i = e.length; ++r < i;) if (Ll(e[r].geometry, n)) return !0; return !1; } }; const Yl = {
    Sphere() { return !0; }, Point(t, n) { return jl(t.coordinates, n); }, MultiPoint(t, n) { for (let e = t.coordinates, r = -1, i = e.length; ++r < i;) if (jl(e[r], n)) return !0; return !1; }, LineString(t, n) { return Hl(t.coordinates, n); }, MultiLineString(t, n) { for (let e = t.coordinates, r = -1, i = e.length; ++r < i;) if (Hl(e[r], n)) return !0; return !1; }, Polygon(t, n) { return Xl(t.coordinates, n); }, MultiPolygon(t, n) { for (let e = t.coordinates, r = -1, i = e.length; ++r < i;) if (Xl(e[r], n)) return !0; return !1; }, GeometryCollection(t, n) { for (let e = t.geometries, r = -1, i = e.length; ++r < i;) if (Ll(e[r], n)) return !0; return !1; },
  }; function Ll(t, n) { return !(!t || !Yl.hasOwnProperty(t.type)) && Yl[t.type](t, n); } function jl(t, n) { return Ol(t, n) === 0; } function Hl(t, n) { for (var e, r, i, o = 0, a = t.length; o < a; o++) { if ((r = Ol(t[o], n)) === 0) return !0; if (o > 0 && (i = Ol(t[o], t[o - 1])) > 0 && e <= i && r <= i && (e + r - i) * (1 - ((e - r) / i) ** 2) < pf * i) return !0; e = r; } return !1; } function Xl(t, n) { return !!ml(t.map(Gl), Vl(n)); } function Gl(t) { return (t = t.map(Vl)).pop(), t; } function Vl(t) { return [t[0] * mf, t[1] * mf]; } function Wl(t, n, e) { const r = lt(t, n - df, e).concat(n); return function (t) { return r.map(((n) => [t, n])); }; } function Zl(t, n, e) { const r = lt(t, n - df, e).concat(n); return function (t) { return r.map(((n) => [n, t])); }; } function Kl() {
    let t; let n; let e; let r; let i; let o; let a; let u; let c; let f; let s; let l; let h = 10; let d = h; let p = 90; let g = 360; let y = 2.5; function v() { return { type: 'MultiLineString', coordinates: _() }; } function _() {
      return lt(Af(r / p) * p, e, p).map(s).concat(lt(Af(u / g) * g, a, g).map(l)).concat(lt(Af(n / h) * h, t, h).filter(((t) => xf(t % p) > df)).map(c))
        .concat(lt(Af(o / d) * d, i, d).filter(((t) => xf(t % g) > df)).map(f));
    } return v.lines = function () { return _().map(((t) => ({ type: 'LineString', coordinates: t }))); }, v.outline = function () { return { type: 'Polygon', coordinates: [s(r).concat(l(a).slice(1), s(e).reverse().slice(1), l(u).reverse().slice(1))] }; }, v.extent = function (t) { return arguments.length ? v.extentMajor(t).extentMinor(t) : v.extentMinor(); }, v.extentMajor = function (t) { return arguments.length ? (r = +t[0][0], e = +t[1][0], u = +t[0][1], a = +t[1][1], r > e && (t = r, r = e, e = t), u > a && (t = u, u = a, a = t), v.precision(y)) : [[r, u], [e, a]]; }, v.extentMinor = function (e) { return arguments.length ? (n = +e[0][0], t = +e[1][0], o = +e[0][1], i = +e[1][1], n > t && (e = n, n = t, t = e), o > i && (e = o, o = i, i = e), v.precision(y)) : [[n, o], [t, i]]; }, v.step = function (t) { return arguments.length ? v.stepMajor(t).stepMinor(t) : v.stepMinor(); }, v.stepMajor = function (t) { return arguments.length ? (p = +t[0], g = +t[1], v) : [p, g]; }, v.stepMinor = function (t) { return arguments.length ? (h = +t[0], d = +t[1], v) : [h, d]; }, v.precision = function (h) { return arguments.length ? (y = +h, c = Wl(o, i, 90), f = Zl(n, t, y), s = Wl(u, a, 90), l = Zl(r, e, y), v) : y; }, v.extentMajor([[-180, -90 + df], [180, 90 - df]]).extentMinor([[-180, -80 - df], [180, 80 + df]]);
  } let Ql; let Jl; let th; let nh; const eh = (t) => t; let rh = new T(); let ih = new T(); var oh = {
    point: qf, lineStart: qf, lineEnd: qf, polygonStart() { oh.lineStart = ah, oh.lineEnd = fh; }, polygonEnd() { oh.lineStart = oh.lineEnd = oh.point = qf, rh.add(xf(ih)), ih = new T(); }, result() { const t = rh / 2; return rh = new T(), t; },
  }; function ah() { oh.point = uh; } function uh(t, n) { oh.point = ch, Ql = th = t, Jl = nh = n; } function ch(t, n) { ih.add(nh * t - th * n), th = t, nh = n; } function fh() { ch(Ql, Jl); } const sh = oh; let lh = 1 / 0; let hh = lh; let dh = -lh; let ph = dh; const gh = {
    point(t, n) { t < lh && (lh = t); t > dh && (dh = t); n < hh && (hh = n); n > ph && (ph = n); }, lineStart: qf, lineEnd: qf, polygonStart: qf, polygonEnd: qf, result() { const t = [[lh, hh], [dh, ph]]; return dh = ph = -(hh = lh = 1 / 0), t; },
  }; let yh; let vh; let _h; let bh; const mh = gh; let xh = 0; let wh = 0; let Mh = 0; let Th = 0; let Ah = 0; let Sh = 0; let Eh = 0; let Nh = 0; let kh = 0; var Ch = {
    point: Ph, lineStart: zh, lineEnd: Rh, polygonStart() { Ch.lineStart = Fh, Ch.lineEnd = qh; }, polygonEnd() { Ch.point = Ph, Ch.lineStart = zh, Ch.lineEnd = Rh; }, result() { const t = kh ? [Eh / kh, Nh / kh] : Sh ? [Th / Sh, Ah / Sh] : Mh ? [xh / Mh, wh / Mh] : [NaN, NaN]; return xh = wh = Mh = Th = Ah = Sh = Eh = Nh = kh = 0, t; },
  }; function Ph(t, n) { xh += t, wh += n, ++Mh; } function zh() { Ch.point = $h; } function $h(t, n) { Ch.point = Dh, Ph(_h = t, bh = n); } function Dh(t, n) { const e = t - _h; const r = n - bh; const i = zf(e * e + r * r); Th += i * (_h + t) / 2, Ah += i * (bh + n) / 2, Sh += i, Ph(_h = t, bh = n); } function Rh() { Ch.point = Ph; } function Fh() { Ch.point = Uh; } function qh() { Ih(yh, vh); } function Uh(t, n) { Ch.point = Ih, Ph(yh = _h = t, vh = bh = n); } function Ih(t, n) { const e = t - _h; const r = n - bh; let i = zf(e * e + r * r); Th += i * (_h + t) / 2, Ah += i * (bh + n) / 2, Sh += i, Eh += (i = bh * t - _h * n) * (_h + t), Nh += i * (bh + n), kh += 3 * i, Ph(_h = t, bh = n); } const Oh = Ch; function Bh(t) { this._context = t; }Bh.prototype = {
    _radius: 4.5, pointRadius(t) { return this._radius = t, this; }, polygonStart() { this._line = 0; }, polygonEnd() { this._line = NaN; }, lineStart() { this._point = 0; }, lineEnd() { this._line === 0 && this._context.closePath(), this._point = NaN; }, point(t, n) { switch (this._point) { case 0: this._context.moveTo(t, n), this._point = 1; break; case 1: this._context.lineTo(t, n); break; default: this._context.moveTo(t + this._radius, n), this._context.arc(t, n, this._radius, 0, _f); } }, result: qf,
  }; let Yh; let Lh; let jh; let Hh; let Xh; let Gh = new T(); var Vh = {
    point: qf, lineStart() { Vh.point = Wh; }, lineEnd() { Yh && Zh(Lh, jh), Vh.point = qf; }, polygonStart() { Yh = !0; }, polygonEnd() { Yh = null; }, result() { const t = +Gh; return Gh = new T(), t; },
  }; function Wh(t, n) { Vh.point = Zh, Lh = Hh = t, jh = Xh = n; } function Zh(t, n) { Hh -= t, Xh -= n, Gh.add(zf(Hh * Hh + Xh * Xh)), Hh = t, Xh = n; } const Kh = Vh; let Qh; let Jh; let td; let nd; class ed {
    constructor(t) { this._append = t == null ? rd : (function (t) { const n = Math.floor(t); if (!(n >= 0)) throw new RangeError(`invalid digits: ${t}`); if (n > 15) return rd; if (n !== Qh) { const t = 10 ** n; Qh = n, Jh = function (n) { let e = 1; this._ += n[0]; for (const r = n.length; e < r; ++e) this._ += Math.round(arguments[e] * t) / t + n[e]; }; } return Jh; }(t)), this._radius = 4.5, this._ = ''; }

    pointRadius(t) { return this._radius = +t, this; }

    polygonStart() { this._line = 0; }

    polygonEnd() { this._line = NaN; }

    lineStart() { this._point = 0; }

    lineEnd() { this._line === 0 && (this._ += 'Z'), this._point = NaN; }

    point(t, n) { switch (this._point) { case 0: this._append`M${t},${n}`, this._point = 1; break; case 1: this._append`L${t},${n}`; break; default: if (this._append`M${t},${n}`, this._radius !== td || this._append !== Jh) { const t = this._radius; const n = this._; this._ = '', this._append`m0,${t}a${t},${t} 0 1,1 0,${-2 * t}a${t},${t} 0 1,1 0,${2 * t}z`, td = t, Jh = this._append, nd = this._, this._ = n; } this._ += nd; } }

    result() { const t = this._; return this._ = '', t.length ? t : null; }
  } function rd(t) { let n = 1; this._ += t[0]; for (const e = t.length; n < e; ++n) this._ += arguments[n] + t[n]; } function id(t) { return function (n) { const e = new od(); for (const r in t)e[r] = t[r]; return e.stream = n, e; }; } function od() {} function ad(t, n, e) { const r = t.clipExtent && t.clipExtent(); return t.scale(150).translate([0, 0]), r != null && t.clipExtent(null), Lf(e, t.stream(mh)), n(mh.result()), r != null && t.clipExtent(r), t; } function ud(t, n, e) { return ad(t, ((e) => { const r = n[1][0] - n[0][0]; const i = n[1][1] - n[0][1]; const o = Math.min(r / (e[1][0] - e[0][0]), i / (e[1][1] - e[0][1])); const a = +n[0][0] + (r - o * (e[1][0] + e[0][0])) / 2; const u = +n[0][1] + (i - o * (e[1][1] + e[0][1])) / 2; t.scale(150 * o).translate([a, u]); }), e); } function cd(t, n, e) { return ud(t, [[0, 0], n], e); } function fd(t, n, e) { return ad(t, ((e) => { const r = +n; const i = r / (e[1][0] - e[0][0]); const o = (r - i * (e[1][0] + e[0][0])) / 2; const a = -i * e[0][1]; t.scale(150 * i).translate([o, a]); }), e); } function sd(t, n, e) { return ad(t, ((e) => { const r = +n; const i = r / (e[1][1] - e[0][1]); const o = -i * e[0][0]; const a = (r - i * (e[1][1] + e[0][1])) / 2; t.scale(150 * i).translate([o, a]); }), e); }od.prototype = {
    constructor: od, point(t, n) { this.stream.point(t, n); }, sphere() { this.stream.sphere(); }, lineStart() { this.stream.lineStart(); }, lineEnd() { this.stream.lineEnd(); }, polygonStart() { this.stream.polygonStart(); }, polygonEnd() { this.stream.polygonEnd(); },
  }; const ld = 16; const hd = Tf(30 * mf); function dd(t, n) {
    return +n ? (function (t, n) {
      function e(r, i, o, a, u, c, f, s, l, h, d, p, g, y) { const v = f - r; const _ = s - i; const b = v * v + _ * _; if (b > 4 * n && g--) { let m = a + h; let x = u + d; let w = c + p; const M = zf(m * m + x * x + w * w); const T = Rf(w /= M); const A = xf(xf(w) - 1) < df || xf(o - l) < df ? (o + l) / 2 : Mf(x, m); const S = t(A, T); const E = S[0]; const N = S[1]; const k = E - r; const C = N - i; const P = _ * k - v * C; (P * P / b > n || xf((v * k + _ * C) / b - 0.5) > 0.3 || a * h + u * d + c * p < hd) && (e(r, i, o, a, u, c, E, N, A, m /= M, x /= M, w, g, y), y.point(E, N), e(E, N, A, m, x, w, f, s, l, h, d, p, g, y)); } } return function (n) {
        let r; let i; let o; let a; let u; let c; let f; let s; let l; let h; let d; let p; var g = {
          point: y, lineStart: v, lineEnd: b, polygonStart() { n.polygonStart(), g.lineStart = m; }, polygonEnd() { n.polygonEnd(), g.lineStart = v; },
        }; function y(e, r) { e = t(e, r), n.point(e[0], e[1]); } function v() { s = NaN, g.point = _, n.lineStart(); } function _(r, i) { const o = ps([r, i]); const a = t(r, i); e(s, l, f, h, d, p, s = a[0], l = a[1], f = r, h = o[0], d = o[1], p = o[2], ld, n), n.point(s, l); } function b() { g.point = y, n.lineEnd(); } function m() { v(), g.point = x, g.lineEnd = w; } function x(t, n) { _(r = t, n), i = s, o = l, a = h, u = d, c = p, g.point = _; } function w() { e(s, l, f, h, d, p, i, o, r, a, u, c, ld, n), g.lineEnd = b, b(); } return g;
      };
    }(t, n)) : (function (t) { return id({ point(n, e) { n = t(n, e), this.stream.point(n[0], n[1]); } }); }(t));
  } const pd = id({ point(t, n) { this.stream.point(t * mf, n * mf); } }); function gd(t, n, e, r, i, o) { if (!o) return (function (t, n, e, r, i) { function o(o, a) { return [n + t * (o *= r), e - t * (a *= i)]; } return o.invert = function (o, a) { return [(o - n) / t * r, (e - a) / t * i]; }, o; }(t, n, e, r, i)); const a = Tf(o); const u = Cf(o); const c = a * t; const f = u * t; const s = a / t; const l = u / t; const h = (u * e - a * n) / t; const d = (u * n + a * e) / t; function p(t, o) { return [c * (t *= r) - f * (o *= i) + n, e - f * t - c * o]; } return p.invert = function (t, n) { return [r * (s * t - l * n + h), i * (d - l * t - s * n)]; }, p; } function yd(t) { return vd((() => t))(); } function vd(t) { let n; let e; let r; let i; let o; let a; let u; let c; let f; let s; let l = 150; let h = 480; let d = 250; let p = 0; let g = 0; let y = 0; let v = 0; let _ = 0; let b = 0; let m = 1; let x = 1; let w = null; let M = Tl; let T = null; let A = eh; let S = 0.5; function E(t) { return c(t[0] * mf, t[1] * mf); } function N(t) { return (t = c.invert(t[0], t[1])) && [t[0] * bf, t[1] * bf]; } function k() { const t = gd(l, 0, 0, m, x, b).apply(null, n(p, g)); const r = gd(l, h - t[0], d - t[1], m, x, b); return e = ul(y, v, _), u = ol(n, r), c = ol(e, u), a = dd(u, S), C(); } function C() { return f = s = null, E; } return E.stream = function (t) { return f && s === t ? f : f = pd((function (t) { return id({ point(n, e) { const r = t(n, e); return this.stream.point(r[0], r[1]); } }); }(e))(M(a(A(s = t))))); }, E.preclip = function (t) { return arguments.length ? (M = t, w = void 0, C()) : M; }, E.postclip = function (t) { return arguments.length ? (A = t, T = r = i = o = null, C()) : A; }, E.clipAngle = function (t) { return arguments.length ? (M = +t ? Al(w = t * mf) : (w = null, Tl), C()) : w * bf; }, E.clipExtent = function (t) { return arguments.length ? (A = t == null ? (T = r = i = o = null, eh) : zl(T = +t[0][0], r = +t[0][1], i = +t[1][0], o = +t[1][1]), C()) : T == null ? null : [[T, r], [i, o]]; }, E.scale = function (t) { return arguments.length ? (l = +t, k()) : l; }, E.translate = function (t) { return arguments.length ? (h = +t[0], d = +t[1], k()) : [h, d]; }, E.center = function (t) { return arguments.length ? (p = t[0] % 360 * mf, g = t[1] % 360 * mf, k()) : [p * bf, g * bf]; }, E.rotate = function (t) { return arguments.length ? (y = t[0] % 360 * mf, v = t[1] % 360 * mf, _ = t.length > 2 ? t[2] % 360 * mf : 0, k()) : [y * bf, v * bf, _ * bf]; }, E.angle = function (t) { return arguments.length ? (b = t % 360 * mf, k()) : b * bf; }, E.reflectX = function (t) { return arguments.length ? (m = t ? -1 : 1, k()) : m < 0; }, E.reflectY = function (t) { return arguments.length ? (x = t ? -1 : 1, k()) : x < 0; }, E.precision = function (t) { return arguments.length ? (a = dd(u, S = t * t), C()) : zf(S); }, E.fitExtent = function (t, n) { return ud(E, t, n); }, E.fitSize = function (t, n) { return cd(E, t, n); }, E.fitWidth = function (t, n) { return fd(E, t, n); }, E.fitHeight = function (t, n) { return sd(E, t, n); }, function () { return n = t.apply(this, arguments), E.invert = n.invert && N, k(); }; } function _d(t) { let n = 0; let e = gf / 3; const r = vd(t); const i = r(n, e); return i.parallels = function (t) { return arguments.length ? r(n = t[0] * mf, e = t[1] * mf) : [n * bf, e * bf]; }, i; } function bd(t, n) { const e = Cf(t); const r = (e + Cf(n)) / 2; if (xf(r) < df) return (function (t) { const n = Tf(t); function e(t, e) { return [t * n, Cf(e) / n]; } return e.invert = function (t, e) { return [t / n, Rf(e * n)]; }, e; }(t)); const i = 1 + e * (2 * r - e); const o = zf(i) / r; function a(t, n) { const e = zf(i - 2 * r * Cf(n)) / r; return [e * Cf(t *= r), o - e * Tf(t)]; } return a.invert = function (t, n) { const e = o - n; let a = Mf(t, xf(e)) * Pf(e); return e * r < 0 && (a -= gf * Pf(t) * Pf(e)), [a / r, Rf((i - (t * t + e * e) * r * r) / (2 * r))]; }, a; } function md() { return _d(bd).scale(155.424).center([0, 33.6442]); } function xd() {
    return md().parallels([29.5, 45.5]).scale(1070).translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
  } function wd(t) { return function (n, e) { const r = Tf(n); const i = Tf(e); const o = t(r * i); return o === 1 / 0 ? [2, 0] : [o * i * Cf(n), o * Cf(e)]; }; } function Md(t) { return function (n, e) { const r = zf(n * n + e * e); const i = t(r); const o = Cf(i); const a = Tf(i); return [Mf(n * o, r * a), Rf(r && e * o / r)]; }; } const Td = wd(((t) => zf(2 / (1 + t)))); Td.invert = Md(((t) => 2 * Rf(t / 2))); const Ad = wd(((t) => (t = Df(t)) && t / Cf(t))); function Sd(t, n) { return [t, Nf($f((yf + n) / 2))]; } function Ed(t) { let n; let e; let r; const i = yd(t); const o = i.center; const a = i.scale; const u = i.translate; const c = i.clipExtent; let f = null; function s() { const o = gf * a(); const u = i(ll(i.rotate()).invert([0, 0])); return c(f == null ? [[u[0] - o, u[1] - o], [u[0] + o, u[1] + o]] : t === Sd ? [[Math.max(u[0] - o, f), n], [Math.min(u[0] + o, e), r]] : [[f, Math.max(u[1] - o, n)], [e, Math.min(u[1] + o, r)]]); } return i.scale = function (t) { return arguments.length ? (a(t), s()) : a(); }, i.translate = function (t) { return arguments.length ? (u(t), s()) : u(); }, i.center = function (t) { return arguments.length ? (o(t), s()) : o(); }, i.clipExtent = function (t) { return arguments.length ? (t == null ? f = n = e = r = null : (f = +t[0][0], n = +t[0][1], e = +t[1][0], r = +t[1][1]), s()) : f == null ? null : [[f, n], [e, r]]; }, s(); } function Nd(t) { return $f((yf + t) / 2); } function kd(t, n) { const e = Tf(t); const r = t === n ? Cf(t) : Nf(e / Tf(n)) / Nf(Nd(n) / Nd(t)); const i = e * Nd(t) ** r / r; if (!r) return Sd; function o(t, n) { i > 0 ? n < -yf + df && (n = -yf + df) : n > yf - df && (n = yf - df); const e = i / Nd(n) ** r; return [e * Cf(r * t), i - e * Tf(r * t)]; } return o.invert = function (t, n) { const e = i - n; const o = Pf(r) * zf(t * t + e * e); let a = Mf(t, xf(e)) * Pf(e); return e * r < 0 && (a -= gf * Pf(t) * Pf(e)), [a / r, 2 * wf((i / o) ** (1 / r)) - yf]; }, o; } function Cd(t, n) { return [t, n]; } function Pd(t, n) { const e = Tf(t); const r = t === n ? Cf(t) : (e - Tf(n)) / (n - t); const i = e / r + t; if (xf(r) < df) return Cd; function o(t, n) { const e = i - n; const o = r * t; return [e * Cf(o), i - e * Tf(o)]; } return o.invert = function (t, n) { const e = i - n; let o = Mf(t, xf(e)) * Pf(e); return e * r < 0 && (o -= gf * Pf(t) * Pf(e)), [o / r, i - Pf(r) * zf(t * t + e * e)]; }, o; }Ad.invert = Md(((t) => t)), Sd.invert = function (t, n) { return [t, 2 * wf(Sf(n)) - yf]; }, Cd.invert = Cd; const zd = 1.340264; const $d = -0.081106; const Dd = 893e-6; const Rd = 0.003796; const Fd = zf(3) / 2; function qd(t, n) { const e = Rf(Fd * Cf(n)); const r = e * e; const i = r * r * r; return [t * Tf(e) / (Fd * (zd + 3 * $d * r + i * (7 * Dd + 9 * Rd * r))), e * (zd + $d * r + i * (Dd + Rd * r))]; } function Ud(t, n) { const e = Tf(n); const r = Tf(t) * e; return [e * Cf(t) / r, Cf(n) / r]; } function Id(t, n) { const e = n * n; const r = e * e; return [t * (0.8707 - 0.131979 * e + r * (r * (0.003971 * e - 0.001529 * r) - 0.013791)), n * (1.007226 + e * (0.015085 + r * (0.028874 * e - 0.044475 - 0.005916 * r)))]; } function Od(t, n) { return [Tf(n) * Cf(t), Cf(n)]; } function Bd(t, n) { const e = Tf(n); const r = 1 + Tf(t) * e; return [e * Cf(t) / r, Cf(n) / r]; } function Yd(t, n) { return [Nf($f((yf + n) / 2)), -t]; } function Ld(t, n) { return t.parent === n.parent ? 1 : 2; } function jd(t, n) { return t + n.x; } function Hd(t, n) { return Math.max(t, n.y); } function Xd(t) { let n = 0; const e = t.children; let r = e && e.length; if (r) for (;--r >= 0;)n += e[r].value; else n = 1; t.value = n; } function Gd(t, n) { t instanceof Map ? (t = [void 0, t], void 0 === n && (n = Wd)) : void 0 === n && (n = Vd); for (var e, r, i, o, a, u = new Qd(t), c = [u]; e = c.pop();) if ((i = n(e.data)) && (a = (i = Array.from(i)).length)) for (e.children = i, o = a - 1; o >= 0; --o)c.push(r = i[o] = new Qd(i[o])), r.parent = e, r.depth = e.depth + 1; return u.eachBefore(Kd); } function Vd(t) { return t.children; } function Wd(t) { return Array.isArray(t) ? t[1] : null; } function Zd(t) { void 0 !== t.data.value && (t.value = t.data.value), t.data = t.data.data; } function Kd(t) { let n = 0; do { t.height = n; } while ((t = t.parent) && t.height < ++n); } function Qd(t) { this.data = t, this.depth = this.height = 0, this.parent = null; } function Jd(t) { return t == null ? null : tp(t); } function tp(t) { if (typeof t !== 'function') throw new Error(); return t; } function np() { return 0; } function ep(t) { return function () { return t; }; }qd.invert = function (t, n) { for (var e, r = n, i = r * r, o = i * i * i, a = 0; a < 12 && (o = (i = (r -= e = (r * (zd + $d * i + o * (Dd + Rd * i)) - n) / (zd + 3 * $d * i + o * (7 * Dd + 9 * Rd * i))) * r) * i * i, !(xf(e) < pf)); ++a);return [Fd * t * (zd + 3 * $d * i + o * (7 * Dd + 9 * Rd * i)) / Tf(r), Rf(Cf(r) / Fd)]; }, Ud.invert = Md(wf), Id.invert = function (t, n) { let e; let r = n; let i = 25; do { var o = r * r; const a = o * o; r -= e = (r * (1.007226 + o * (0.015085 + a * (0.028874 * o - 0.044475 - 0.005916 * a))) - n) / (1.007226 + o * (0.045255 + a * (0.259866 * o - 0.311325 - 0.005916 * 11 * a))); } while (xf(e) > df && --i > 0); return [t / (0.8707 + (o = r * r) * (o * (o * o * o * (0.003971 - 0.001529 * o) - 0.013791) - 0.131979)), r]; }, Od.invert = Md(Rf), Bd.invert = Md(((t) => 2 * wf(t))), Yd.invert = function (t, n) { return [-n, 2 * wf(Sf(t)) - yf]; }, Qd.prototype = Gd.prototype = {
    constructor: Qd, count() { return this.eachAfter(Xd); }, each(t, n) { let e = -1; for (const r of this)t.call(n, r, ++e, this); return this; }, eachAfter(t, n) { for (var e, r, i, o = this, a = [o], u = [], c = -1; o = a.pop();) if (u.push(o), e = o.children) for (r = 0, i = e.length; r < i; ++r)a.push(e[r]); for (;o = u.pop();)t.call(n, o, ++c, this); return this; }, eachBefore(t, n) { for (var e, r, i = this, o = [i], a = -1; i = o.pop();) if (t.call(n, i, ++a, this), e = i.children) for (r = e.length - 1; r >= 0; --r)o.push(e[r]); return this; }, find(t, n) { let e = -1; for (const r of this) if (t.call(n, r, ++e, this)) return r; }, sum(t) { return this.eachAfter(((n) => { for (var e = +t(n.data) || 0, r = n.children, i = r && r.length; --i >= 0;)e += r[i].value; n.value = e; })); }, sort(t) { return this.eachBefore(((n) => { n.children && n.children.sort(t); })); }, path(t) { for (var n = this, e = (function (t, n) { if (t === n) return t; const e = t.ancestors(); const r = n.ancestors(); let i = null; t = e.pop(), n = r.pop(); for (;t === n;)i = t, t = e.pop(), n = r.pop(); return i; }(n, t)), r = [n]; n !== e;)n = n.parent, r.push(n); for (let i = r.length; t !== e;)r.splice(i, 0, t), t = t.parent; return r; }, ancestors() { for (var t = this, n = [t]; t = t.parent;)n.push(t); return n; }, descendants() { return Array.from(this); }, leaves() { const t = []; return this.eachBefore(((n) => { n.children || t.push(n); })), t; }, links() { const t = this; const n = []; return t.each(((e) => { e !== t && n.push({ source: e.parent, target: e }); })), n; }, copy() { return Gd(this).eachBefore(Zd); }, * [Symbol.iterator]() { let t; let n; let e; let r; let i = this; let o = [i]; do { for (t = o.reverse(), o = []; i = t.pop();) if (yield i, n = i.children) for (e = 0, r = n.length; e < r; ++e)o.push(n[e]); } while (o.length); },
  }; const rp = 1664525; const ip = 1013904223; const op = 4294967296; function ap() { let t = 1; return () => (t = (rp * t + ip) % op) / op; } function up(t, n) { for (var e, r, i = 0, o = (t = (function (t, n) { let e; let r; let i = t.length; for (;i;)r = n() * i-- | 0, e = t[i], t[i] = t[r], t[r] = e; return t; }(Array.from(t), n))).length, a = []; i < o;)e = t[i], r && sp(r, e) ? ++i : (r = hp(a = cp(a, e)), i = 0); return r; } function cp(t, n) { let e; let r; if (lp(n, t)) return [n]; for (e = 0; e < t.length; ++e) if (fp(n, t[e]) && lp(dp(t[e], n), t)) return [t[e], n]; for (e = 0; e < t.length - 1; ++e) for (r = e + 1; r < t.length; ++r) if (fp(dp(t[e], t[r]), n) && fp(dp(t[e], n), t[r]) && fp(dp(t[r], n), t[e]) && lp(pp(t[e], t[r], n), t)) return [t[e], t[r], n]; throw new Error(); } function fp(t, n) { const e = t.r - n.r; const r = n.x - t.x; const i = n.y - t.y; return e < 0 || e * e < r * r + i * i; } function sp(t, n) { const e = t.r - n.r + 1e-9 * Math.max(t.r, n.r, 1); const r = n.x - t.x; const i = n.y - t.y; return e > 0 && e * e > r * r + i * i; } function lp(t, n) { for (let e = 0; e < n.length; ++e) if (!sp(t, n[e])) return !1; return !0; } function hp(t) { switch (t.length) { case 1: return (function (t) { return { x: t.x, y: t.y, r: t.r }; }(t[0])); case 2: return dp(t[0], t[1]); case 3: return pp(t[0], t[1], t[2]); } } function dp(t, n) { const e = t.x; const r = t.y; const i = t.r; const o = n.x; const a = n.y; const u = n.r; const c = o - e; const f = a - r; const s = u - i; const l = Math.sqrt(c * c + f * f); return { x: (e + o + c / l * s) / 2, y: (r + a + f / l * s) / 2, r: (l + i + u) / 2 }; } function pp(t, n, e) { const r = t.x; const i = t.y; const o = t.r; const a = n.x; const u = n.y; const c = n.r; const f = e.x; const s = e.y; const l = e.r; const h = r - a; const d = r - f; const p = i - u; const g = i - s; const y = c - o; const v = l - o; const _ = r * r + i * i - o * o; const b = _ - a * a - u * u + c * c; const m = _ - f * f - s * s + l * l; const x = d * p - h * g; const w = (p * m - g * b) / (2 * x) - r; const M = (g * y - p * v) / x; const T = (d * b - h * m) / (2 * x) - i; const A = (h * v - d * y) / x; const S = M * M + A * A - 1; const E = 2 * (o + w * M + T * A); const N = w * w + T * T - o * o; const k = -(Math.abs(S) > 1e-6 ? (E + Math.sqrt(E * E - 4 * S * N)) / (2 * S) : N / E); return { x: r + w + M * k, y: i + T + A * k, r: k }; } function gp(t, n, e) { let r; let i; let o; let a; const u = t.x - n.x; const c = t.y - n.y; const f = u * u + c * c; f ? (i = n.r + e.r, i *= i, a = t.r + e.r, i > (a *= a) ? (r = (f + a - i) / (2 * f), o = Math.sqrt(Math.max(0, a / f - r * r)), e.x = t.x - r * u - o * c, e.y = t.y - r * c + o * u) : (r = (f + i - a) / (2 * f), o = Math.sqrt(Math.max(0, i / f - r * r)), e.x = n.x + r * u - o * c, e.y = n.y + r * c + o * u)) : (e.x = n.x + e.r, e.y = n.y); } function yp(t, n) { const e = t.r + n.r - 1e-6; const r = n.x - t.x; const i = n.y - t.y; return e > 0 && e * e > r * r + i * i; } function vp(t) { const n = t._; const e = t.next._; const r = n.r + e.r; const i = (n.x * e.r + e.x * n.r) / r; const o = (n.y * e.r + e.y * n.r) / r; return i * i + o * o; } function _p(t) { this._ = t, this.next = null, this.previous = null; } function bp(t, n) { if (!(o = (t = (function (t) { return typeof t === 'object' && 'length' in t ? t : Array.from(t); }(t))).length)) return 0; let e; let r; let i; let o; let a; let u; let c; let f; let s; let l; let h; if ((e = t[0]).x = 0, e.y = 0, !(o > 1)) return e.r; if (r = t[1], e.x = -r.r, r.x = e.r, r.y = 0, !(o > 2)) return e.r + r.r; gp(r, e, i = t[2]), e = new _p(e), r = new _p(r), i = new _p(i), e.next = i.previous = r, r.next = e.previous = i, i.next = r.previous = e; t:for (c = 3; c < o; ++c) { gp(e._, r._, i = t[c]), i = new _p(i), f = r.next, s = e.previous, l = r._.r, h = e._.r; do { if (l <= h) { if (yp(f._, i._)) { r = f, e.next = r, r.previous = e, --c; continue t; }l += f._.r, f = f.next; } else { if (yp(s._, i._)) { (e = s).next = r, r.previous = e, --c; continue t; }h += s._.r, s = s.previous; } } while (f !== s.next); for (i.previous = e, i.next = r, e.next = r.previous = r = i, a = vp(e); (i = i.next) !== r;)(u = vp(i)) < a && (e = i, a = u); r = e.next; } for (e = [r._], i = r; (i = i.next) !== r;)e.push(i._); for (i = up(e, n), c = 0; c < o; ++c)(e = t[c]).x -= i.x, e.y -= i.y; return i.r; } function mp(t) { return Math.sqrt(t.value); } function xp(t) { return function (n) { n.children || (n.r = Math.max(0, +t(n) || 0)); }; } function wp(t, n, e) { return function (r) { if (i = r.children) { var i; let o; let a; const u = i.length; const c = t(r) * n || 0; if (c) for (o = 0; o < u; ++o)i[o].r += c; if (a = bp(i, e), c) for (o = 0; o < u; ++o)i[o].r -= c; r.r = a + c; } }; } function Mp(t) { return function (n) { const e = n.parent; n.r *= t, e && (n.x = e.x + t * n.x, n.y = e.y + t * n.y); }; } function Tp(t) { t.x0 = Math.round(t.x0), t.y0 = Math.round(t.y0), t.x1 = Math.round(t.x1), t.y1 = Math.round(t.y1); } function Ap(t, n, e, r, i) { for (var o, a = t.children, u = -1, c = a.length, f = t.value && (r - n) / t.value; ++u < c;)(o = a[u]).y0 = e, o.y1 = i, o.x0 = n, o.x1 = n += o.value * f; } const Sp = { depth: -1 }; const Ep = {}; const Np = {}; function kp(t) { return t.id; } function Cp(t) { return t.parentId; } function Pp(t) { let n = t.length; if (n < 2) return ''; for (;--n > 1 && !zp(t, n););return t.slice(0, n); } function zp(t, n) { if (t[n] === '/') { let e = 0; for (;n > 0 && t[--n] === '\\';)++e; if (!(1 & e)) return !0; } return !1; } function $p(t, n) { return t.parent === n.parent ? 1 : 2; } function Dp(t) { const n = t.children; return n ? n[0] : t.t; } function Rp(t) { const n = t.children; return n ? n[n.length - 1] : t.t; } function Fp(t, n, e) { const r = e / (n.i - t.i); n.c -= r, n.s += e, t.c += r, n.z += e, n.m += e; } function qp(t, n, e) { return t.a.parent === n.parent ? t.a : e; } function Up(t, n) { this._ = t, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = n; } function Ip(t, n, e, r, i) { for (var o, a = t.children, u = -1, c = a.length, f = t.value && (i - e) / t.value; ++u < c;)(o = a[u]).x0 = n, o.x1 = r, o.y0 = e, o.y1 = e += o.value * f; }Up.prototype = Object.create(Qd.prototype); const Op = (1 + Math.sqrt(5)) / 2; function Bp(t, n, e, r, i, o) { for (var a, u, c, f, s, l, h, d, p, g, y, v = [], _ = n.children, b = 0, m = 0, x = _.length, w = n.value; b < x;) { c = i - e, f = o - r; do { s = _[m++].value; } while (!s && m < x); for (l = h = s, y = s * s * (g = Math.max(f / c, c / f) / (w * t)), p = Math.max(h / y, y / l); m < x; ++m) { if (s += u = _[m].value, u < l && (l = u), u > h && (h = u), y = s * s * g, (d = Math.max(h / y, y / l)) > p) { s -= u; break; }p = d; }v.push(a = { value: s, dice: c < f, children: _.slice(b, m) }), a.dice ? Ap(a, e, r, i, w ? r += f * s / w : o) : Ip(a, e, r, w ? e += c * s / w : i, o), w -= s, b = m; } return v; } const Yp = (function t(n) { function e(t, e, r, i, o) { Bp(n, t, e, r, i, o); } return e.ratio = function (n) { return t((n = +n) > 1 ? n : 1); }, e; }(Op)); const Lp = (function t(n) { function e(t, e, r, i, o) { if ((a = t._squarify) && a.ratio === n) for (var a, u, c, f, s, l = -1, h = a.length, d = t.value; ++l < h;) { for (c = (u = a[l]).children, f = u.value = 0, s = c.length; f < s; ++f)u.value += c[f].value; u.dice ? Ap(u, e, r, i, d ? r += (o - r) * u.value / d : o) : Ip(u, e, r, d ? e += (i - e) * u.value / d : i, o), d -= u.value; } else t._squarify = a = Bp(n, t, e, r, i, o), a.ratio = n; } return e.ratio = function (n) { return t((n = +n) > 1 ? n : 1); }, e; }(Op)); function jp(t, n, e) { return (n[0] - t[0]) * (e[1] - t[1]) - (n[1] - t[1]) * (e[0] - t[0]); } function Hp(t, n) { return t[0] - n[0] || t[1] - n[1]; } function Xp(t) { const n = t.length; const e = [0, 1]; let r; let i = 2; for (r = 2; r < n; ++r) { for (;i > 1 && jp(t[e[i - 2]], t[e[i - 1]], t[r]) <= 0;)--i; e[i++] = r; } return e.slice(0, i); } const Gp = Math.random; const Vp = (function t(n) { function e(t, e) { return t = t == null ? 0 : +t, e = e == null ? 1 : +e, arguments.length === 1 ? (e = t, t = 0) : e -= t, function () { return n() * e + t; }; } return e.source = t, e; }(Gp)); const Wp = (function t(n) { function e(t, e) { return arguments.length < 2 && (e = t, t = 0), t = Math.floor(t), e = Math.floor(e) - t, function () { return Math.floor(n() * e + t); }; } return e.source = t, e; }(Gp)); const Zp = (function t(n) { function e(t, e) { let r; let i; return t = t == null ? 0 : +t, e = e == null ? 1 : +e, function () { let o; if (r != null)o = r, r = null; else do { r = 2 * n() - 1, o = 2 * n() - 1, i = r * r + o * o; } while (!i || i > 1); return t + e * o * Math.sqrt(-2 * Math.log(i) / i); }; } return e.source = t, e; }(Gp)); const Kp = (function t(n) { const e = Zp.source(n); function r() { const t = e.apply(this, arguments); return function () { return Math.exp(t()); }; } return r.source = t, r; }(Gp)); const Qp = (function t(n) { function e(t) { return (t = +t) <= 0 ? () => 0 : function () { for (var e = 0, r = t; r > 1; --r)e += n(); return e + r * n(); }; } return e.source = t, e; }(Gp)); const Jp = (function t(n) { const e = Qp.source(n); function r(t) { if ((t = +t) == 0) return n; const r = e(t); return function () { return r() / t; }; } return r.source = t, r; }(Gp)); const tg = (function t(n) { function e(t) { return function () { return -Math.log1p(-n()) / t; }; } return e.source = t, e; }(Gp)); const ng = (function t(n) { function e(t) { if ((t = +t) < 0) throw new RangeError('invalid alpha'); return t = 1 / -t, function () { return (1 - n()) ** t; }; } return e.source = t, e; }(Gp)); const eg = (function t(n) { function e(t) { if ((t = +t) < 0 || t > 1) throw new RangeError('invalid p'); return function () { return Math.floor(n() + t); }; } return e.source = t, e; }(Gp)); const rg = (function t(n) { function e(t) { if ((t = +t) < 0 || t > 1) throw new RangeError('invalid p'); return t === 0 ? () => 1 / 0 : t === 1 ? () => 1 : (t = Math.log1p(-t), function () { return 1 + Math.floor(Math.log1p(-n()) / t); }); } return e.source = t, e; }(Gp)); const ig = (function t(n) { const e = Zp.source(n)(); function r(t, r) { if ((t = +t) < 0) throw new RangeError('invalid k'); if (t === 0) return () => 0; if (r = r == null ? 1 : +r, t === 1) return () => -Math.log1p(-n()) * r; const i = (t < 1 ? t + 1 : t) - 1 / 3; const o = 1 / (3 * Math.sqrt(i)); const a = t < 1 ? () => n() ** (1 / t) : () => 1; return function () { do { do { var t = e(); var u = 1 + o * t; } while (u <= 0); u *= u * u; var c = 1 - n(); } while (c >= 1 - 0.0331 * t * t * t * t && Math.log(c) >= 0.5 * t * t + i * (1 - u + Math.log(u))); return i * u * a() * r; }; } return r.source = t, r; }(Gp)); const og = (function t(n) { const e = ig.source(n); function r(t, n) { const r = e(t); const i = e(n); return function () { const t = r(); return t === 0 ? 0 : t / (t + i()); }; } return r.source = t, r; }(Gp)); const ag = (function t(n) { const e = rg.source(n); const r = og.source(n); function i(t, n) { return t = +t, (n = +n) >= 1 ? () => t : n <= 0 ? () => 0 : function () { for (var i = 0, o = t, a = n; o * a > 16 && o * (1 - a) > 16;) { const u = Math.floor((o + 1) * a); const c = r(u, o - u + 1)(); c <= a ? (i += u, o -= u, a = (a - c) / (1 - c)) : (o = u - 1, a /= c); } for (var f = a < 0.5, s = e(f ? a : 1 - a), l = s(), h = 0; l <= o; ++h)l += s(); return i + (f ? h : o - h); }; } return i.source = t, i; }(Gp)); const ug = (function t(n) { function e(t, e, r) { let i; return (t = +t) == 0 ? i = (t) => -Math.log(t) : (t = 1 / t, i = (n) => n ** t), e = e == null ? 0 : +e, r = r == null ? 1 : +r, function () { return e + r * i(-Math.log1p(-n())); }; } return e.source = t, e; }(Gp)); const cg = (function t(n) { function e(t, e) { return t = t == null ? 0 : +t, e = e == null ? 1 : +e, function () { return t + e * Math.tan(Math.PI * n()); }; } return e.source = t, e; }(Gp)); const fg = (function t(n) { function e(t, e) { return t = t == null ? 0 : +t, e = e == null ? 1 : +e, function () { const r = n(); return t + e * Math.log(r / (1 - r)); }; } return e.source = t, e; }(Gp)); const sg = (function t(n) { const e = ig.source(n); const r = ag.source(n); function i(t) { return function () { for (var i = 0, o = t; o > 16;) { const a = Math.floor(0.875 * o); const u = e(a)(); if (u > o) return i + r(a - 1, o / u)(); i += a, o -= u; } for (var c = -Math.log1p(-n()), f = 0; c <= o; ++f)c -= Math.log1p(-n()); return i + f; }; } return i.source = t, i; }(Gp)); const lg = 1 / 4294967296; function hg(t, n) { switch (arguments.length) { case 0: break; case 1: this.range(t); break; default: this.range(n).domain(t); } return this; } function dg(t, n) { switch (arguments.length) { case 0: break; case 1: typeof t === 'function' ? this.interpolator(t) : this.range(t); break; default: this.domain(t), typeof n === 'function' ? this.interpolator(n) : this.range(n); } return this; } const pg = Symbol('implicit'); function gg() {
    let t = new InternMap(); let n = []; let e = []; let
      r = pg; function i(i) { let o = t.get(i); if (void 0 === o) { if (r !== pg) return r; t.set(i, o = n.push(i) - 1); } return e[o % e.length]; } return i.domain = function (e) { if (!arguments.length) return n.slice(); n = [], t = new InternMap(); for (const r of e)t.has(r) || t.set(r, n.push(r) - 1); return i; }, i.range = function (t) { return arguments.length ? (e = Array.from(t), i) : e.slice(); }, i.unknown = function (t) { return arguments.length ? (r = t, i) : r; }, i.copy = function () { return gg(n, e).unknown(r); }, hg.apply(i, arguments), i;
  } function yg() {
    let t; let n; const e = gg().unknown(void 0); const r = e.domain; const i = e.range; let o = 0; let a = 1; let u = !1; let c = 0; let f = 0; let s = 0.5; function l() { const e = r().length; const l = a < o; let h = l ? a : o; const d = l ? o : a; t = (d - h) / Math.max(1, e - c + 2 * f), u && (t = Math.floor(t)), h += (d - h - t * (e - c)) * s, n = t * (1 - c), u && (h = Math.round(h), n = Math.round(n)); const p = lt(e).map(((n) => h + t * n)); return i(l ? p.reverse() : p); } return delete e.unknown, e.domain = function (t) { return arguments.length ? (r(t), l()) : r(); }, e.range = function (t) { return arguments.length ? ([o, a] = t, o = +o, a = +a, l()) : [o, a]; }, e.rangeRound = function (t) { return [o, a] = t, o = +o, a = +a, u = !0, l(); }, e.bandwidth = function () { return n; }, e.step = function () { return t; }, e.round = function (t) { return arguments.length ? (u = !!t, l()) : u; }, e.padding = function (t) { return arguments.length ? (c = Math.min(1, f = +t), l()) : c; }, e.paddingInner = function (t) { return arguments.length ? (c = Math.min(1, t), l()) : c; }, e.paddingOuter = function (t) { return arguments.length ? (f = +t, l()) : f; }, e.align = function (t) { return arguments.length ? (s = Math.max(0, Math.min(1, t)), l()) : s; }, e.copy = function () {
      return yg(r(), [o, a]).round(u).paddingInner(c).paddingOuter(f)
        .align(s);
    }, hg.apply(l(), arguments);
  } function vg(t) { const n = t.copy; return t.padding = t.paddingOuter, delete t.paddingInner, delete t.paddingOuter, t.copy = function () { return vg(n()); }, t; } function _g(t) { return +t; } const bg = [0, 1]; function mg(t) { return t; } function xg(t, n) { return (n -= t = +t) ? function (e) { return (e - t) / n; } : (function (t) { return function () { return t; }; }(isNaN(n) ? NaN : 0.5)); } function wg(t, n, e) { let r = t[0]; const i = t[1]; let o = n[0]; const a = n[1]; return i < r ? (r = xg(i, r), o = e(a, o)) : (r = xg(r, i), o = e(o, a)), function (t) { return o(r(t)); }; } function Mg(t, n, e) { const r = Math.min(t.length, n.length) - 1; const i = new Array(r); const o = new Array(r); let a = -1; for (t[r] < t[0] && (t = t.slice().reverse(), n = n.slice().reverse()); ++a < r;)i[a] = xg(t[a], t[a + 1]), o[a] = e(n[a], n[a + 1]); return function (n) { const e = s(t, n, 1, r) - 1; return o[e](i[e](n)); }; } function Tg(t, n) {
    return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp())
      .unknown(t.unknown());
  } function Ag() { let t; let n; let e; let r; let i; let o; let a = bg; let u = bg; let c = Gr; let f = mg; function s() { const t = Math.min(a.length, u.length); return f !== mg && (f = (function (t, n) { let e; return t > n && (e = t, t = n, n = e), function (e) { return Math.max(t, Math.min(n, e)); }; }(a[0], a[t - 1]))), r = t > 2 ? Mg : wg, i = o = null, l; } function l(n) { return n == null || isNaN(n = +n) ? e : (i || (i = r(a.map(t), u, c)))(t(f(n))); } return l.invert = function (e) { return f(n((o || (o = r(u, a.map(t), Yr)))(e))); }, l.domain = function (t) { return arguments.length ? (a = Array.from(t, _g), s()) : a.slice(); }, l.range = function (t) { return arguments.length ? (u = Array.from(t), s()) : u.slice(); }, l.rangeRound = function (t) { return u = Array.from(t), c = Vr, s(); }, l.clamp = function (t) { return arguments.length ? (f = !!t || mg, s()) : f !== mg; }, l.interpolate = function (t) { return arguments.length ? (c = t, s()) : c; }, l.unknown = function (t) { return arguments.length ? (e = t, l) : e; }, function (e, r) { return t = e, n = r, s(); }; } function Sg() { return Ag()(mg, mg); } function Eg(n, e, r, i) { let o; const a = W(n, e, r); switch ((i = Jc(i == null ? ',f' : i)).type) { case 's': var u = Math.max(Math.abs(n), Math.abs(e)); return i.precision != null || isNaN(o = lf(a, u)) || (i.precision = o), t.formatPrefix(i, u); case '': case 'e': case 'g': case 'p': case 'r': i.precision != null || isNaN(o = hf(a, Math.max(Math.abs(n), Math.abs(e)))) || (i.precision = o - (i.type === 'e')); break; case 'f': case '%': i.precision != null || isNaN(o = sf(a)) || (i.precision = o - 2 * (i.type === '%')); } return t.format(i); } function Ng(t) { const n = t.domain; return t.ticks = function (t) { const e = n(); return G(e[0], e[e.length - 1], t == null ? 10 : t); }, t.tickFormat = function (t, e) { const r = n(); return Eg(r[0], r[r.length - 1], t == null ? 10 : t, e); }, t.nice = function (e) { e == null && (e = 10); let r; let i; const o = n(); let a = 0; let u = o.length - 1; let c = o[a]; let f = o[u]; let s = 10; for (f < c && (i = c, c = f, f = i, i = a, a = u, u = i); s-- > 0;) { if ((i = V(c, f, e)) === r) return o[a] = c, o[u] = f, n(o); if (i > 0)c = Math.floor(c / i) * i, f = Math.ceil(f / i) * i; else { if (!(i < 0)) break; c = Math.ceil(c * i) / i, f = Math.floor(f * i) / i; }r = i; } return t; }, t; } function kg(t, n) { let e; let r = 0; let i = (t = t.slice()).length - 1; let o = t[r]; let a = t[i]; return a < o && (e = r, r = i, i = e, e = o, o = a, a = e), t[r] = n.floor(o), t[i] = n.ceil(a), t; } function Cg(t) { return Math.log(t); } function Pg(t) { return Math.exp(t); } function zg(t) { return -Math.log(-t); } function $g(t) { return -Math.exp(-t); } function Dg(t) { return isFinite(t) ? +(`1e${t}`) : t < 0 ? 0 : t; } function Rg(t) { return (n, e) => -t(-n, e); } function Fg(n) { const e = n(Cg, Pg); const r = e.domain; let i; let o; let a = 10; function u() { return i = (function (t) { return t === Math.E ? Math.log : t === 10 && Math.log10 || t === 2 && Math.log2 || (t = Math.log(t), (n) => Math.log(n) / t); }(a)), o = (function (t) { return t === 10 ? Dg : t === Math.E ? Math.exp : (n) => t ** n; }(a)), r()[0] < 0 ? (i = Rg(i), o = Rg(o), n(zg, $g)) : n(Cg, Pg), e; } return e.base = function (t) { return arguments.length ? (a = +t, u()) : a; }, e.domain = function (t) { return arguments.length ? (r(t), u()) : r(); }, e.ticks = (t) => { const n = r(); let e = n[0]; let u = n[n.length - 1]; const c = u < e; c && ([e, u] = [u, e]); let f; let s; let l = i(e); let h = i(u); const d = t == null ? 10 : +t; let p = []; if (!(a % 1) && h - l < d) { if (l = Math.floor(l), h = Math.ceil(h), e > 0) { for (;l <= h; ++l) for (f = 1; f < a; ++f) if (s = l < 0 ? f / o(-l) : f * o(l), !(s < e)) { if (s > u) break; p.push(s); } } else for (;l <= h; ++l) for (f = a - 1; f >= 1; --f) if (s = l > 0 ? f / o(-l) : f * o(l), !(s < e)) { if (s > u) break; p.push(s); }2 * p.length < d && (p = G(e, u, d)); } else p = G(l, h, Math.min(h - l, d)).map(o); return c ? p.reverse() : p; }, e.tickFormat = (n, r) => { if (n == null && (n = 10), r == null && (r = a === 10 ? 's' : ','), typeof r !== 'function' && (a % 1 || (r = Jc(r)).precision != null || (r.trim = !0), r = t.format(r)), n === 1 / 0) return r; const u = Math.max(1, a * n / e.ticks().length); return (t) => { let n = t / o(Math.round(i(t))); return n * a < a - 0.5 && (n *= a), n <= u ? r(t) : ''; }; }, e.nice = () => r(kg(r(), { floor: (t) => o(Math.floor(i(t))), ceil: (t) => o(Math.ceil(i(t))) })), e; } function qg(t) { return function (n) { return Math.sign(n) * Math.log1p(Math.abs(n / t)); }; } function Ug(t) { return function (n) { return Math.sign(n) * Math.expm1(Math.abs(n)) * t; }; } function Ig(t) { let n = 1; const e = t(qg(n), Ug(n)); return e.constant = function (e) { return arguments.length ? t(qg(n = +e), Ug(n)) : n; }, Ng(e); } function Og(t) { return function (n) { return n < 0 ? -((-n) ** t) : n ** t; }; } function Bg(t) { return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t); } function Yg(t) { return t < 0 ? -t * t : t * t; } function Lg(t) { const n = t(mg, mg); let e = 1; return n.exponent = function (n) { return arguments.length ? (e = +n) === 1 ? t(mg, mg) : e === 0.5 ? t(Bg, Yg) : t(Og(e), Og(1 / e)) : e; }, Ng(n); } function jg() { const t = Lg(Ag()); return t.copy = function () { return Tg(t, jg()).exponent(t.exponent()); }, hg.apply(t, arguments), t; } function Hg(t) { return Math.sign(t) * t * t; } const Xg = new Date(); const
    Gg = new Date(); function Vg(t, n, e, r) { function i(n) { return t(n = arguments.length === 0 ? new Date() : new Date(+n)), n; } return i.floor = (n) => (t(n = new Date(+n)), n), i.ceil = (e) => (t(e = new Date(e - 1)), n(e, 1), t(e), e), i.round = (t) => { const n = i(t); const e = i.ceil(t); return t - n < e - t ? n : e; }, i.offset = (t, e) => (n(t = new Date(+t), e == null ? 1 : Math.floor(e)), t), i.range = (e, r, o) => { const a = []; if (e = i.ceil(e), o = o == null ? 1 : Math.floor(o), !(e < r && o > 0)) return a; let u; do { a.push(u = new Date(+e)), n(e, o), t(e); } while (u < e && e < r); return a; }, i.filter = (e) => Vg(((n) => { if (n >= n) for (;t(n), !e(n);)n.setTime(n - 1); }), ((t, r) => { if (t >= t) if (r < 0) for (;++r <= 0;) for (;n(t, -1), !e(t););else for (;--r >= 0;) for (;n(t, 1), !e(t);); })), e && (i.count = (n, r) => (Xg.setTime(+n), Gg.setTime(+r), t(Xg), t(Gg), Math.floor(e(Xg, Gg))), i.every = (t) => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? i.filter(r ? (n) => r(n) % t == 0 : (n) => i.count(0, n) % t == 0) : i : null)), i; } const Wg = Vg((() => {}), ((t, n) => { t.setTime(+t + n); }), ((t, n) => n - t)); Wg.every = (t) => (t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? Vg(((n) => { n.setTime(Math.floor(n / t) * t); }), ((n, e) => { n.setTime(+n + e * t); }), ((n, e) => (e - n) / t)) : Wg : null); const Zg = Wg.range; const Kg = 1e3; const Qg = 6e4; const Jg = 36e5; const ty = 864e5; const ny = 6048e5; const ey = 2592e6; const ry = 31536e6; const iy = Vg(((t) => { t.setTime(t - t.getMilliseconds()); }), ((t, n) => { t.setTime(+t + n * Kg); }), ((t, n) => (n - t) / Kg), ((t) => t.getUTCSeconds())); const oy = iy.range; const ay = Vg(((t) => { t.setTime(t - t.getMilliseconds() - t.getSeconds() * Kg); }), ((t, n) => { t.setTime(+t + n * Qg); }), ((t, n) => (n - t) / Qg), ((t) => t.getMinutes())); const uy = ay.range; const cy = Vg(((t) => { t.setUTCSeconds(0, 0); }), ((t, n) => { t.setTime(+t + n * Qg); }), ((t, n) => (n - t) / Qg), ((t) => t.getUTCMinutes())); const fy = cy.range; const sy = Vg(((t) => { t.setTime(t - t.getMilliseconds() - t.getSeconds() * Kg - t.getMinutes() * Qg); }), ((t, n) => { t.setTime(+t + n * Jg); }), ((t, n) => (n - t) / Jg), ((t) => t.getHours())); const ly = sy.range; const hy = Vg(((t) => { t.setUTCMinutes(0, 0, 0); }), ((t, n) => { t.setTime(+t + n * Jg); }), ((t, n) => (n - t) / Jg), ((t) => t.getUTCHours())); const dy = hy.range; const py = Vg(((t) => t.setHours(0, 0, 0, 0)), ((t, n) => t.setDate(t.getDate() + n)), ((t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Qg) / ty), ((t) => t.getDate() - 1)); const gy = py.range; const yy = Vg(((t) => { t.setUTCHours(0, 0, 0, 0); }), ((t, n) => { t.setUTCDate(t.getUTCDate() + n); }), ((t, n) => (n - t) / ty), ((t) => t.getUTCDate() - 1)); const vy = yy.range; const _y = Vg(((t) => { t.setUTCHours(0, 0, 0, 0); }), ((t, n) => { t.setUTCDate(t.getUTCDate() + n); }), ((t, n) => (n - t) / ty), ((t) => Math.floor(t / ty))); const by = _y.range; function my(t) { return Vg(((n) => { n.setDate(n.getDate() - (n.getDay() + 7 - t) % 7), n.setHours(0, 0, 0, 0); }), ((t, n) => { t.setDate(t.getDate() + 7 * n); }), ((t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Qg) / ny)); } const xy = my(0); const wy = my(1); const My = my(2); const Ty = my(3); const Ay = my(4); const Sy = my(5); const Ey = my(6); const Ny = xy.range; const ky = wy.range; const Cy = My.range; const Py = Ty.range; const zy = Ay.range; const $y = Sy.range; const Dy = Ey.range; function Ry(t) { return Vg(((n) => { n.setUTCDate(n.getUTCDate() - (n.getUTCDay() + 7 - t) % 7), n.setUTCHours(0, 0, 0, 0); }), ((t, n) => { t.setUTCDate(t.getUTCDate() + 7 * n); }), ((t, n) => (n - t) / ny)); } const Fy = Ry(0); const qy = Ry(1); const Uy = Ry(2); const Iy = Ry(3); const Oy = Ry(4); const By = Ry(5); const Yy = Ry(6); const Ly = Fy.range; const jy = qy.range; const Hy = Uy.range; const Xy = Iy.range; const Gy = Oy.range; const Vy = By.range; const Wy = Yy.range; const Zy = Vg(((t) => { t.setDate(1), t.setHours(0, 0, 0, 0); }), ((t, n) => { t.setMonth(t.getMonth() + n); }), ((t, n) => n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear())), ((t) => t.getMonth())); const Ky = Zy.range; const Qy = Vg(((t) => { t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0); }), ((t, n) => { t.setUTCMonth(t.getUTCMonth() + n); }), ((t, n) => n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear())), ((t) => t.getUTCMonth())); const Jy = Qy.range; const tv = Vg(((t) => { t.setMonth(0, 1), t.setHours(0, 0, 0, 0); }), ((t, n) => { t.setFullYear(t.getFullYear() + n); }), ((t, n) => n.getFullYear() - t.getFullYear()), ((t) => t.getFullYear())); tv.every = (t) => (isFinite(t = Math.floor(t)) && t > 0 ? Vg(((n) => { n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0); }), ((n, e) => { n.setFullYear(n.getFullYear() + e * t); })) : null); const nv = tv.range; const ev = Vg(((t) => { t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0); }), ((t, n) => { t.setUTCFullYear(t.getUTCFullYear() + n); }), ((t, n) => n.getUTCFullYear() - t.getUTCFullYear()), ((t) => t.getUTCFullYear())); ev.every = (t) => (isFinite(t = Math.floor(t)) && t > 0 ? Vg(((n) => { n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0); }), ((n, e) => { n.setUTCFullYear(n.getUTCFullYear() + e * t); })) : null); const rv = ev.range; function iv(t, n, e, i, o, a) { const u = [[iy, 1, Kg], [iy, 5, 5e3], [iy, 15, 15e3], [iy, 30, 3e4], [a, 1, Qg], [a, 5, 3e5], [a, 15, 9e5], [a, 30, 18e5], [o, 1, Jg], [o, 3, 108e5], [o, 6, 216e5], [o, 12, 432e5], [i, 1, ty], [i, 2, 1728e5], [e, 1, ny], [n, 1, ey], [n, 3, 7776e6], [t, 1, ry]]; function c(n, e, i) { const o = Math.abs(e - n) / i; const a = r((([,, t]) => t)).right(u, o); if (a === u.length) return t.every(W(n / ry, e / ry, i)); if (a === 0) return Wg.every(Math.max(W(n, e, i), 1)); const [c, f] = u[o / u[a - 1][2] < u[a][2] / o ? a - 1 : a]; return c.every(f); } return [function (t, n, e) { const r = n < t; r && ([t, n] = [n, t]); const i = e && typeof e.range === 'function' ? e : c(t, n, e); const o = i ? i.range(t, +n + 1) : []; return r ? o.reverse() : o; }, c]; } const [ov, av] = iv(ev, Qy, Fy, _y, hy, cy); const [uv, cv] = iv(tv, Zy, xy, py, sy, ay); function fv(t) { if (t.y >= 0 && t.y < 100) { const n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L); return n.setFullYear(t.y), n; } return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L); } function sv(t) { if (t.y >= 0 && t.y < 100) { const n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L)); return n.setUTCFullYear(t.y), n; } return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L)); } function lv(t, n, e) {
    return {
      y: t, m: n, d: e, H: 0, M: 0, S: 0, L: 0,
    };
  } function hv(t) {
    const n = t.dateTime; const e = t.date; const r = t.time; const i = t.periods; const o = t.days; const a = t.shortDays; const u = t.months; const c = t.shortMonths; const f = mv(i); const s = xv(i); const l = mv(o); const h = xv(o); const d = mv(a); const p = xv(a); const g = mv(u); const y = xv(u); const v = mv(c); const _ = xv(c); const b = {
      a(t) { return a[t.getDay()]; }, A(t) { return o[t.getDay()]; }, b(t) { return c[t.getMonth()]; }, B(t) { return u[t.getMonth()]; }, c: null, d: Yv, e: Yv, f: Gv, g: i_, G: a_, H: Lv, I: jv, j: Hv, L: Xv, m: Vv, M: Wv, p(t) { return i[+(t.getHours() >= 12)]; }, q(t) { return 1 + ~~(t.getMonth() / 3); }, Q: k_, s: C_, S: Zv, u: Kv, U: Qv, V: t_, w: n_, W: e_, x: null, X: null, y: r_, Y: o_, Z: u_, '%': N_,
    }; const m = {
      a(t) { return a[t.getUTCDay()]; }, A(t) { return o[t.getUTCDay()]; }, b(t) { return c[t.getUTCMonth()]; }, B(t) { return u[t.getUTCMonth()]; }, c: null, d: c_, e: c_, f: d_, g: T_, G: S_, H: f_, I: s_, j: l_, L: h_, m: p_, M: g_, p(t) { return i[+(t.getUTCHours() >= 12)]; }, q(t) { return 1 + ~~(t.getUTCMonth() / 3); }, Q: k_, s: C_, S: y_, u: v_, U: __, V: m_, w: x_, W: w_, x: null, X: null, y: M_, Y: A_, Z: E_, '%': N_,
    }; const x = {
      a(t, n, e) { const r = d.exec(n.slice(e)); return r ? (t.w = p.get(r[0].toLowerCase()), e + r[0].length) : -1; }, A(t, n, e) { const r = l.exec(n.slice(e)); return r ? (t.w = h.get(r[0].toLowerCase()), e + r[0].length) : -1; }, b(t, n, e) { const r = v.exec(n.slice(e)); return r ? (t.m = _.get(r[0].toLowerCase()), e + r[0].length) : -1; }, B(t, n, e) { const r = g.exec(n.slice(e)); return r ? (t.m = y.get(r[0].toLowerCase()), e + r[0].length) : -1; }, c(t, e, r) { return T(t, n, e, r); }, d: zv, e: zv, f: Uv, g: Nv, G: Ev, H: Dv, I: Dv, j: $v, L: qv, m: Pv, M: Rv, p(t, n, e) { const r = f.exec(n.slice(e)); return r ? (t.p = s.get(r[0].toLowerCase()), e + r[0].length) : -1; }, q: Cv, Q: Ov, s: Bv, S: Fv, u: Mv, U: Tv, V: Av, w: wv, W: Sv, x(t, n, r) { return T(t, e, n, r); }, X(t, n, e) { return T(t, r, n, e); }, y: Nv, Y: Ev, Z: kv, '%': Iv,
    }; function w(t, n) { return function (e) { let r; let i; let o; const a = []; let u = -1; let c = 0; const f = t.length; for (e instanceof Date || (e = new Date(+e)); ++u < f;)t.charCodeAt(u) === 37 && (a.push(t.slice(c, u)), (i = pv[r = t.charAt(++u)]) != null ? r = t.charAt(++u) : i = r === 'e' ? ' ' : '0', (o = n[r]) && (r = o(e, i)), a.push(r), c = u + 1); return a.push(t.slice(c, u)), a.join(''); }; } function M(t, n) { return function (e) { let r; let i; const o = lv(1900, void 0, 1); if (T(o, t, e += '', 0) != e.length) return null; if ('Q' in o) return new Date(o.Q); if ('s' in o) return new Date(1e3 * o.s + ('L' in o ? o.L : 0)); if (n && !('Z' in o) && (o.Z = 0), 'p' in o && (o.H = o.H % 12 + 12 * o.p), void 0 === o.m && (o.m = 'q' in o ? o.q : 0), 'V' in o) { if (o.V < 1 || o.V > 53) return null; 'w' in o || (o.w = 1), 'Z' in o ? (i = (r = sv(lv(o.y, 0, 1))).getUTCDay(), r = i > 4 || i === 0 ? qy.ceil(r) : qy(r), r = yy.offset(r, 7 * (o.V - 1)), o.y = r.getUTCFullYear(), o.m = r.getUTCMonth(), o.d = r.getUTCDate() + (o.w + 6) % 7) : (i = (r = fv(lv(o.y, 0, 1))).getDay(), r = i > 4 || i === 0 ? wy.ceil(r) : wy(r), r = py.offset(r, 7 * (o.V - 1)), o.y = r.getFullYear(), o.m = r.getMonth(), o.d = r.getDate() + (o.w + 6) % 7); } else ('W' in o || 'U' in o) && ('w' in o || (o.w = 'u' in o ? o.u % 7 : 'W' in o ? 1 : 0), i = 'Z' in o ? sv(lv(o.y, 0, 1)).getUTCDay() : fv(lv(o.y, 0, 1)).getDay(), o.m = 0, o.d = 'W' in o ? (o.w + 6) % 7 + 7 * o.W - (i + 5) % 7 : o.w + 7 * o.U - (i + 6) % 7); return 'Z' in o ? (o.H += o.Z / 100 | 0, o.M += o.Z % 100, sv(o)) : fv(o); }; } function T(t, n, e, r) { for (var i, o, a = 0, u = n.length, c = e.length; a < u;) { if (r >= c) return -1; if ((i = n.charCodeAt(a++)) === 37) { if (i = n.charAt(a++), !(o = x[i in pv ? n.charAt(a++) : i]) || (r = o(t, e, r)) < 0) return -1; } else if (i != e.charCodeAt(r++)) return -1; } return r; } return b.x = w(e, b), b.X = w(r, b), b.c = w(n, b), m.x = w(e, m), m.X = w(r, m), m.c = w(n, m), {
      format(t) { const n = w(t += '', b); return n.toString = function () { return t; }, n; }, parse(t) { const n = M(t += '', !1); return n.toString = function () { return t; }, n; }, utcFormat(t) { const n = w(t += '', m); return n.toString = function () { return t; }, n; }, utcParse(t) { const n = M(t += '', !0); return n.toString = function () { return t; }, n; },
    };
  } let dv; var pv = { '-': '', _: ' ', 0: '0' }; const gv = /^\s*\d+/; const yv = /^%/; const vv = /[\\^$*+?|[\]().{}]/g; function _v(t, n, e) { const r = t < 0 ? '-' : ''; const i = `${r ? -t : t}`; const o = i.length; return r + (o < e ? new Array(e - o + 1).join(n) + i : i); } function bv(t) { return t.replace(vv, '\\$&'); } function mv(t) { return new RegExp(`^(?:${t.map(bv).join('|')})`, 'i'); } function xv(t) { return new Map(t.map(((t, n) => [t.toLowerCase(), n]))); } function wv(t, n, e) { const r = gv.exec(n.slice(e, e + 1)); return r ? (t.w = +r[0], e + r[0].length) : -1; } function Mv(t, n, e) { const r = gv.exec(n.slice(e, e + 1)); return r ? (t.u = +r[0], e + r[0].length) : -1; } function Tv(t, n, e) { const r = gv.exec(n.slice(e, e + 2)); return r ? (t.U = +r[0], e + r[0].length) : -1; } function Av(t, n, e) { const r = gv.exec(n.slice(e, e + 2)); return r ? (t.V = +r[0], e + r[0].length) : -1; } function Sv(t, n, e) { const r = gv.exec(n.slice(e, e + 2)); return r ? (t.W = +r[0], e + r[0].length) : -1; } function Ev(t, n, e) { const r = gv.exec(n.slice(e, e + 4)); return r ? (t.y = +r[0], e + r[0].length) : -1; } function Nv(t, n, e) { const r = gv.exec(n.slice(e, e + 2)); return r ? (t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), e + r[0].length) : -1; } function kv(t, n, e) { const r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n.slice(e, e + 6)); return r ? (t.Z = r[1] ? 0 : -(r[2] + (r[3] || '00')), e + r[0].length) : -1; } function Cv(t, n, e) { const r = gv.exec(n.slice(e, e + 1)); return r ? (t.q = 3 * r[0] - 3, e + r[0].length) : -1; } function Pv(t, n, e) { const r = gv.exec(n.slice(e, e + 2)); return r ? (t.m = r[0] - 1, e + r[0].length) : -1; } function zv(t, n, e) { const r = gv.exec(n.slice(e, e + 2)); return r ? (t.d = +r[0], e + r[0].length) : -1; } function $v(t, n, e) { const r = gv.exec(n.slice(e, e + 3)); return r ? (t.m = 0, t.d = +r[0], e + r[0].length) : -1; } function Dv(t, n, e) { const r = gv.exec(n.slice(e, e + 2)); return r ? (t.H = +r[0], e + r[0].length) : -1; } function Rv(t, n, e) { const r = gv.exec(n.slice(e, e + 2)); return r ? (t.M = +r[0], e + r[0].length) : -1; } function Fv(t, n, e) { const r = gv.exec(n.slice(e, e + 2)); return r ? (t.S = +r[0], e + r[0].length) : -1; } function qv(t, n, e) { const r = gv.exec(n.slice(e, e + 3)); return r ? (t.L = +r[0], e + r[0].length) : -1; } function Uv(t, n, e) { const r = gv.exec(n.slice(e, e + 6)); return r ? (t.L = Math.floor(r[0] / 1e3), e + r[0].length) : -1; } function Iv(t, n, e) { const r = yv.exec(n.slice(e, e + 1)); return r ? e + r[0].length : -1; } function Ov(t, n, e) { const r = gv.exec(n.slice(e)); return r ? (t.Q = +r[0], e + r[0].length) : -1; } function Bv(t, n, e) { const r = gv.exec(n.slice(e)); return r ? (t.s = +r[0], e + r[0].length) : -1; } function Yv(t, n) { return _v(t.getDate(), n, 2); } function Lv(t, n) { return _v(t.getHours(), n, 2); } function jv(t, n) { return _v(t.getHours() % 12 || 12, n, 2); } function Hv(t, n) { return _v(1 + py.count(tv(t), t), n, 3); } function Xv(t, n) { return _v(t.getMilliseconds(), n, 3); } function Gv(t, n) { return `${Xv(t, n)}000`; } function Vv(t, n) { return _v(t.getMonth() + 1, n, 2); } function Wv(t, n) { return _v(t.getMinutes(), n, 2); } function Zv(t, n) { return _v(t.getSeconds(), n, 2); } function Kv(t) { const n = t.getDay(); return n === 0 ? 7 : n; } function Qv(t, n) { return _v(xy.count(tv(t) - 1, t), n, 2); } function Jv(t) { const n = t.getDay(); return n >= 4 || n === 0 ? Ay(t) : Ay.ceil(t); } function t_(t, n) { return t = Jv(t), _v(Ay.count(tv(t), t) + (tv(t).getDay() === 4), n, 2); } function n_(t) { return t.getDay(); } function e_(t, n) { return _v(wy.count(tv(t) - 1, t), n, 2); } function r_(t, n) { return _v(t.getFullYear() % 100, n, 2); } function i_(t, n) { return _v((t = Jv(t)).getFullYear() % 100, n, 2); } function o_(t, n) { return _v(t.getFullYear() % 1e4, n, 4); } function a_(t, n) { const e = t.getDay(); return _v((t = e >= 4 || e === 0 ? Ay(t) : Ay.ceil(t)).getFullYear() % 1e4, n, 4); } function u_(t) { let n = t.getTimezoneOffset(); return (n > 0 ? '-' : (n *= -1, '+')) + _v(n / 60 | 0, '0', 2) + _v(n % 60, '0', 2); } function c_(t, n) { return _v(t.getUTCDate(), n, 2); } function f_(t, n) { return _v(t.getUTCHours(), n, 2); } function s_(t, n) { return _v(t.getUTCHours() % 12 || 12, n, 2); } function l_(t, n) { return _v(1 + yy.count(ev(t), t), n, 3); } function h_(t, n) { return _v(t.getUTCMilliseconds(), n, 3); } function d_(t, n) { return `${h_(t, n)}000`; } function p_(t, n) { return _v(t.getUTCMonth() + 1, n, 2); } function g_(t, n) { return _v(t.getUTCMinutes(), n, 2); } function y_(t, n) { return _v(t.getUTCSeconds(), n, 2); } function v_(t) { const n = t.getUTCDay(); return n === 0 ? 7 : n; } function __(t, n) { return _v(Fy.count(ev(t) - 1, t), n, 2); } function b_(t) { const n = t.getUTCDay(); return n >= 4 || n === 0 ? Oy(t) : Oy.ceil(t); } function m_(t, n) { return t = b_(t), _v(Oy.count(ev(t), t) + (ev(t).getUTCDay() === 4), n, 2); } function x_(t) { return t.getUTCDay(); } function w_(t, n) { return _v(qy.count(ev(t) - 1, t), n, 2); } function M_(t, n) { return _v(t.getUTCFullYear() % 100, n, 2); } function T_(t, n) { return _v((t = b_(t)).getUTCFullYear() % 100, n, 2); } function A_(t, n) { return _v(t.getUTCFullYear() % 1e4, n, 4); } function S_(t, n) { const e = t.getUTCDay(); return _v((t = e >= 4 || e === 0 ? Oy(t) : Oy.ceil(t)).getUTCFullYear() % 1e4, n, 4); } function E_() { return '+0000'; } function N_() { return '%'; } function k_(t) { return +t; } function C_(t) { return Math.floor(+t / 1e3); } function P_(n) { return dv = hv(n), t.timeFormat = dv.format, t.timeParse = dv.parse, t.utcFormat = dv.utcFormat, t.utcParse = dv.utcParse, dv; }t.timeFormat = void 0, t.timeParse = void 0, t.utcFormat = void 0, t.utcParse = void 0, P_({
    dateTime: '%x, %X', date: '%-m/%-d/%Y', time: '%-I:%M:%S %p', periods: ['AM', 'PM'], days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  }); const z_ = '%Y-%m-%dT%H:%M:%S.%LZ'; const $_ = Date.prototype.toISOString ? function (t) { return t.toISOString(); } : t.utcFormat(z_); const D_ = $_; const R_ = +new Date('2000-01-01T00:00:00.000Z') ? function (t) { const n = new Date(t); return isNaN(n) ? null : n; } : t.utcParse(z_); const F_ = R_; function q_(t) { return new Date(t); } function U_(t) { return t instanceof Date ? +t : +new Date(+t); } function I_(t, n, e, r, i, o, a, u, c, f) { const s = Sg(); const l = s.invert; const h = s.domain; const d = f('.%L'); const p = f(':%S'); const g = f('%I:%M'); const y = f('%I %p'); const v = f('%a %d'); const _ = f('%b %d'); const b = f('%B'); const m = f('%Y'); function x(t) { return (c(t) < t ? d : u(t) < t ? p : a(t) < t ? g : o(t) < t ? y : r(t) < t ? i(t) < t ? v : _ : e(t) < t ? b : m)(t); } return s.invert = function (t) { return new Date(l(t)); }, s.domain = function (t) { return arguments.length ? h(Array.from(t, U_)) : h().map(q_); }, s.ticks = function (n) { const e = h(); return t(e[0], e[e.length - 1], n == null ? 10 : n); }, s.tickFormat = function (t, n) { return n == null ? x : f(n); }, s.nice = function (t) { const e = h(); return t && typeof t.range === 'function' || (t = n(e[0], e[e.length - 1], t == null ? 10 : t)), t ? h(kg(e, t)) : s; }, s.copy = function () { return Tg(s, I_(t, n, e, r, i, o, a, u, c, f)); }, s; } function O_() { let t; let n; let e; let r; let i; let o = 0; let a = 1; let u = mg; let c = !1; function f(n) { return n == null || isNaN(n = +n) ? i : u(e === 0 ? 0.5 : (n = (r(n) - t) * e, c ? Math.max(0, Math.min(1, n)) : n)); } function s(t) { return function (n) { let e; let r; return arguments.length ? ([e, r] = n, u = t(e, r), f) : [u(0), u(1)]; }; } return f.domain = function (i) { return arguments.length ? ([o, a] = i, t = r(o = +o), n = r(a = +a), e = t === n ? 0 : 1 / (n - t), f) : [o, a]; }, f.clamp = function (t) { return arguments.length ? (c = !!t, f) : c; }, f.interpolator = function (t) { return arguments.length ? (u = t, f) : u; }, f.range = s(Gr), f.rangeRound = s(Vr), f.unknown = function (t) { return arguments.length ? (i = t, f) : i; }, function (i) { return r = i, t = i(o), n = i(a), e = t === n ? 0 : 1 / (n - t), f; }; } function B_(t, n) { return n.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown()); } function Y_() { const t = Lg(O_()); return t.copy = function () { return B_(t, Y_()).exponent(t.exponent()); }, dg.apply(t, arguments); } function L_() { let t; let n; let e; let r; let i; let o; let a; let u = 0; let c = 0.5; let f = 1; let s = 1; let l = mg; let h = !1; function d(t) { return isNaN(t = +t) ? a : (t = 0.5 + ((t = +o(t)) - n) * (s * t < s * n ? r : i), l(h ? Math.max(0, Math.min(1, t)) : t)); } function p(t) { return function (n) { let e; let r; let i; return arguments.length ? ([e, r, i] = n, l = di(t, [e, r, i]), d) : [l(0), l(0.5), l(1)]; }; } return d.domain = function (a) { return arguments.length ? ([u, c, f] = a, t = o(u = +u), n = o(c = +c), e = o(f = +f), r = t === n ? 0 : 0.5 / (n - t), i = n === e ? 0 : 0.5 / (e - n), s = n < t ? -1 : 1, d) : [u, c, f]; }, d.clamp = function (t) { return arguments.length ? (h = !!t, d) : h; }, d.interpolator = function (t) { return arguments.length ? (l = t, d) : l; }, d.range = p(Gr), d.rangeRound = p(Vr), d.unknown = function (t) { return arguments.length ? (a = t, d) : a; }, function (a) { return o = a, t = a(u), n = a(c), e = a(f), r = t === n ? 0 : 0.5 / (n - t), i = n === e ? 0 : 0.5 / (e - n), s = n < t ? -1 : 1, d; }; } function j_() { const t = Lg(L_()); return t.copy = function () { return B_(t, j_()).exponent(t.exponent()); }, dg.apply(t, arguments); } function H_(t) { for (var n = t.length / 6 | 0, e = new Array(n), r = 0; r < n;)e[r] = `#${t.slice(6 * r, 6 * ++r)}`; return e; } const X_ = H_('1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf'); const G_ = H_('7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666'); const V_ = H_('1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666'); const W_ = H_('4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0'); const Z_ = H_('a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928'); const K_ = H_('fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2'); const Q_ = H_('b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc'); const J_ = H_('e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999'); const tb = H_('66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3'); const nb = H_('8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f'); const eb = H_('4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab'); const rb = (t) => Fr(t[t.length - 1]); const ib = new Array(3).concat('d8b365f5f5f55ab4ac', 'a6611adfc27d80cdc1018571', 'a6611adfc27df5f5f580cdc1018571', '8c510ad8b365f6e8c3c7eae55ab4ac01665e', '8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e', '8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e', '8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e', '5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30', '5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30').map(H_); const ob = rb(ib); const ab = new Array(3).concat('af8dc3f7f7f77fbf7b', '7b3294c2a5cfa6dba0008837', '7b3294c2a5cff7f7f7a6dba0008837', '762a83af8dc3e7d4e8d9f0d37fbf7b1b7837', '762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837', '762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837', '762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837', '40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b', '40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b').map(H_); const ub = rb(ab); const cb = new Array(3).concat('e9a3c9f7f7f7a1d76a', 'd01c8bf1b6dab8e1864dac26', 'd01c8bf1b6daf7f7f7b8e1864dac26', 'c51b7de9a3c9fde0efe6f5d0a1d76a4d9221', 'c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221', 'c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221', 'c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221', '8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419', '8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419').map(H_); const fb = rb(cb); const sb = new Array(3).concat('998ec3f7f7f7f1a340', '5e3c99b2abd2fdb863e66101', '5e3c99b2abd2f7f7f7fdb863e66101', '542788998ec3d8daebfee0b6f1a340b35806', '542788998ec3d8daebf7f7f7fee0b6f1a340b35806', '5427888073acb2abd2d8daebfee0b6fdb863e08214b35806', '5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806', '2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08', '2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08').map(H_); const lb = rb(sb); const hb = new Array(3).concat('ef8a62f7f7f767a9cf', 'ca0020f4a58292c5de0571b0', 'ca0020f4a582f7f7f792c5de0571b0', 'b2182bef8a62fddbc7d1e5f067a9cf2166ac', 'b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac', 'b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac', 'b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac', '67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061', '67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061').map(H_); const db = rb(hb); const pb = new Array(3).concat('ef8a62ffffff999999', 'ca0020f4a582bababa404040', 'ca0020f4a582ffffffbababa404040', 'b2182bef8a62fddbc7e0e0e09999994d4d4d', 'b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d', 'b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d', 'b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d', '67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a', '67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a').map(H_); const gb = rb(pb); const yb = new Array(3).concat('fc8d59ffffbf91bfdb', 'd7191cfdae61abd9e92c7bb6', 'd7191cfdae61ffffbfabd9e92c7bb6', 'd73027fc8d59fee090e0f3f891bfdb4575b4', 'd73027fc8d59fee090ffffbfe0f3f891bfdb4575b4', 'd73027f46d43fdae61fee090e0f3f8abd9e974add14575b4', 'd73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4', 'a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695', 'a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695').map(H_); const vb = rb(yb); const _b = new Array(3).concat('fc8d59ffffbf91cf60', 'd7191cfdae61a6d96a1a9641', 'd7191cfdae61ffffbfa6d96a1a9641', 'd73027fc8d59fee08bd9ef8b91cf601a9850', 'd73027fc8d59fee08bffffbfd9ef8b91cf601a9850', 'd73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850', 'd73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850', 'a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837', 'a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837').map(H_); const bb = rb(_b); const mb = new Array(3).concat('fc8d59ffffbf99d594', 'd7191cfdae61abdda42b83ba', 'd7191cfdae61ffffbfabdda42b83ba', 'd53e4ffc8d59fee08be6f59899d5943288bd', 'd53e4ffc8d59fee08bffffbfe6f59899d5943288bd', 'd53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd', 'd53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd', '9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2', '9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2').map(H_); const xb = rb(mb); const wb = new Array(3).concat('e5f5f999d8c92ca25f', 'edf8fbb2e2e266c2a4238b45', 'edf8fbb2e2e266c2a42ca25f006d2c', 'edf8fbccece699d8c966c2a42ca25f006d2c', 'edf8fbccece699d8c966c2a441ae76238b45005824', 'f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824', 'f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b').map(H_); const Mb = rb(wb); const Tb = new Array(3).concat('e0ecf49ebcda8856a7', 'edf8fbb3cde38c96c688419d', 'edf8fbb3cde38c96c68856a7810f7c', 'edf8fbbfd3e69ebcda8c96c68856a7810f7c', 'edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b', 'f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b', 'f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b').map(H_); const Ab = rb(Tb); const Sb = new Array(3).concat('e0f3dba8ddb543a2ca', 'f0f9e8bae4bc7bccc42b8cbe', 'f0f9e8bae4bc7bccc443a2ca0868ac', 'f0f9e8ccebc5a8ddb57bccc443a2ca0868ac', 'f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e', 'f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e', 'f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081').map(H_); const Eb = rb(Sb); const Nb = new Array(3).concat('fee8c8fdbb84e34a33', 'fef0d9fdcc8afc8d59d7301f', 'fef0d9fdcc8afc8d59e34a33b30000', 'fef0d9fdd49efdbb84fc8d59e34a33b30000', 'fef0d9fdd49efdbb84fc8d59ef6548d7301f990000', 'fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000', 'fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000').map(H_); const kb = rb(Nb); const Cb = new Array(3).concat('ece2f0a6bddb1c9099', 'f6eff7bdc9e167a9cf02818a', 'f6eff7bdc9e167a9cf1c9099016c59', 'f6eff7d0d1e6a6bddb67a9cf1c9099016c59', 'f6eff7d0d1e6a6bddb67a9cf3690c002818a016450', 'fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450', 'fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636').map(H_); const Pb = rb(Cb); const zb = new Array(3).concat('ece7f2a6bddb2b8cbe', 'f1eef6bdc9e174a9cf0570b0', 'f1eef6bdc9e174a9cf2b8cbe045a8d', 'f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d', 'f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b', 'fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b', 'fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858').map(H_); const $b = rb(zb); const Db = new Array(3).concat('e7e1efc994c7dd1c77', 'f1eef6d7b5d8df65b0ce1256', 'f1eef6d7b5d8df65b0dd1c77980043', 'f1eef6d4b9dac994c7df65b0dd1c77980043', 'f1eef6d4b9dac994c7df65b0e7298ace125691003f', 'f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f', 'f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f').map(H_); const Rb = rb(Db); const Fb = new Array(3).concat('fde0ddfa9fb5c51b8a', 'feebe2fbb4b9f768a1ae017e', 'feebe2fbb4b9f768a1c51b8a7a0177', 'feebe2fcc5c0fa9fb5f768a1c51b8a7a0177', 'feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177', 'fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177', 'fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a').map(H_); const qb = rb(Fb); const Ub = new Array(3).concat('edf8b17fcdbb2c7fb8', 'ffffcca1dab441b6c4225ea8', 'ffffcca1dab441b6c42c7fb8253494', 'ffffccc7e9b47fcdbb41b6c42c7fb8253494', 'ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84', 'ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84', 'ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58').map(H_); const Ib = rb(Ub); const Ob = new Array(3).concat('f7fcb9addd8e31a354', 'ffffccc2e69978c679238443', 'ffffccc2e69978c67931a354006837', 'ffffccd9f0a3addd8e78c67931a354006837', 'ffffccd9f0a3addd8e78c67941ab5d238443005a32', 'ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32', 'ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529').map(H_); const Bb = rb(Ob); const Yb = new Array(3).concat('fff7bcfec44fd95f0e', 'ffffd4fed98efe9929cc4c02', 'ffffd4fed98efe9929d95f0e993404', 'ffffd4fee391fec44ffe9929d95f0e993404', 'ffffd4fee391fec44ffe9929ec7014cc4c028c2d04', 'ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04', 'ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506').map(H_); const Lb = rb(Yb); const jb = new Array(3).concat('ffeda0feb24cf03b20', 'ffffb2fecc5cfd8d3ce31a1c', 'ffffb2fecc5cfd8d3cf03b20bd0026', 'ffffb2fed976feb24cfd8d3cf03b20bd0026', 'ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026', 'ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026', 'ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026').map(H_); const Hb = rb(jb); const Xb = new Array(3).concat('deebf79ecae13182bd', 'eff3ffbdd7e76baed62171b5', 'eff3ffbdd7e76baed63182bd08519c', 'eff3ffc6dbef9ecae16baed63182bd08519c', 'eff3ffc6dbef9ecae16baed64292c62171b5084594', 'f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594', 'f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b').map(H_); const Gb = rb(Xb); const Vb = new Array(3).concat('e5f5e0a1d99b31a354', 'edf8e9bae4b374c476238b45', 'edf8e9bae4b374c47631a354006d2c', 'edf8e9c7e9c0a1d99b74c47631a354006d2c', 'edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32', 'f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32', 'f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b').map(H_); const Wb = rb(Vb); const Zb = new Array(3).concat('f0f0f0bdbdbd636363', 'f7f7f7cccccc969696525252', 'f7f7f7cccccc969696636363252525', 'f7f7f7d9d9d9bdbdbd969696636363252525', 'f7f7f7d9d9d9bdbdbd969696737373525252252525', 'fffffff0f0f0d9d9d9bdbdbd969696737373525252252525', 'fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000').map(H_); const Kb = rb(Zb); const Qb = new Array(3).concat('efedf5bcbddc756bb1', 'f2f0f7cbc9e29e9ac86a51a3', 'f2f0f7cbc9e29e9ac8756bb154278f', 'f2f0f7dadaebbcbddc9e9ac8756bb154278f', 'f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486', 'fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486', 'fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d').map(H_); const Jb = rb(Qb); const tm = new Array(3).concat('fee0d2fc9272de2d26', 'fee5d9fcae91fb6a4acb181d', 'fee5d9fcae91fb6a4ade2d26a50f15', 'fee5d9fcbba1fc9272fb6a4ade2d26a50f15', 'fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d', 'fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d', 'fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d').map(H_); const nm = rb(tm); const em = new Array(3).concat('fee6cefdae6be6550d', 'feeddefdbe85fd8d3cd94701', 'feeddefdbe85fd8d3ce6550da63603', 'feeddefdd0a2fdae6bfd8d3ce6550da63603', 'feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04', 'fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04', 'fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704').map(H_); const rm = rb(em); const im = hi(Tr(300, 0.5, 0), Tr(-240, 0.5, 1)); const om = hi(Tr(-100, 0.75, 0.35), Tr(80, 1.5, 0.8)); const am = hi(Tr(260, 0.75, 0.35), Tr(80, 1.5, 0.8)); const um = Tr(); const cm = Fe(); const fm = Math.PI / 3; const sm = 2 * Math.PI / 3; function lm(t) { const n = t.length; return function (e) { return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))]; }; } const hm = lm(H_('44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725')); const dm = lm(H_('00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf')); const pm = lm(H_('00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4')); const gm = lm(H_('0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921')); function ym(t) { return function () { return t; }; } const vm = Math.abs; const _m = Math.atan2; const bm = Math.cos; const mm = Math.max; const xm = Math.min; const wm = Math.sin; const Mm = Math.sqrt; const Tm = 1e-12; const Am = Math.PI; const Sm = Am / 2; const Em = 2 * Am; function Nm(t) { return t >= 1 ? Sm : t <= -1 ? -Sm : Math.asin(t); } function km(t) { let n = 3; return t.digits = function (e) { if (!arguments.length) return n; if (e == null)n = null; else { const t = Math.floor(e); if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`); n = t; } return t; }, () => new Ua(n); } function Cm(t) { return t.innerRadius; } function Pm(t) { return t.outerRadius; } function zm(t) { return t.startAngle; } function $m(t) { return t.endAngle; } function Dm(t) { return t && t.padAngle; } function Rm(t, n, e, r, i, o, a) {
    const u = t - e; const c = n - r; const f = (a ? o : -o) / Mm(u * u + c * c); const s = f * c; const l = -f * u; const h = t + s; const d = n + l; const p = e + s; const g = r + l; const y = (h + p) / 2; const v = (d + g) / 2; const _ = p - h; const b = g - d; const m = _ * _ + b * b; const x = i - o; const w = h * g - p * d; const M = (b < 0 ? -1 : 1) * Mm(mm(0, x * x * m - w * w)); let T = (w * b - _ * M) / m; let A = (-w * _ - b * M) / m; const S = (w * b + _ * M) / m; const E = (-w * _ + b * M) / m; const N = T - y; const k = A - v; const C = S - y; const P = E - v; return N * N + k * k > C * C + P * P && (T = S, A = E), {
      cx: T, cy: A, x01: -s, y01: -l, x11: T * (i / x - 1), y11: A * (i / x - 1),
    };
  } const Fm = Array.prototype.slice; function qm(t) { return typeof t === 'object' && 'length' in t ? t : Array.from(t); } function Um(t) { this._context = t; } function Im(t) { return new Um(t); } function Om(t) { return t[0]; } function Bm(t) { return t[1]; } function Ym(t, n) { let e = ym(!0); let r = null; let i = Im; let o = null; const a = km(u); function u(u) { let c; let f; let s; const l = (u = qm(u)).length; let h = !1; for (r == null && (o = i(s = a())), c = 0; c <= l; ++c)!(c < l && e(f = u[c], c, u)) === h && ((h = !h) ? o.lineStart() : o.lineEnd()), h && o.point(+t(f, c, u), +n(f, c, u)); if (s) return o = null, `${s}` || null; } return t = typeof t === 'function' ? t : void 0 === t ? Om : ym(t), n = typeof n === 'function' ? n : void 0 === n ? Bm : ym(n), u.x = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : ym(+n), u) : t; }, u.y = function (t) { return arguments.length ? (n = typeof t === 'function' ? t : ym(+t), u) : n; }, u.defined = function (t) { return arguments.length ? (e = typeof t === 'function' ? t : ym(!!t), u) : e; }, u.curve = function (t) { return arguments.length ? (i = t, r != null && (o = i(r)), u) : i; }, u.context = function (t) { return arguments.length ? (t == null ? r = o = null : o = i(r = t), u) : r; }, u; } function Lm(t, n, e) { let r = null; let i = ym(!0); let o = null; let a = Im; let u = null; const c = km(f); function f(f) { let s; let l; let h; let d; let p; const g = (f = qm(f)).length; let y = !1; const v = new Array(g); const _ = new Array(g); for (o == null && (u = a(p = c())), s = 0; s <= g; ++s) { if (!(s < g && i(d = f[s], s, f)) === y) if (y = !y)l = s, u.areaStart(), u.lineStart(); else { for (u.lineEnd(), u.lineStart(), h = s - 1; h >= l; --h)u.point(v[h], _[h]); u.lineEnd(), u.areaEnd(); }y && (v[s] = +t(d, s, f), _[s] = +n(d, s, f), u.point(r ? +r(d, s, f) : v[s], e ? +e(d, s, f) : _[s])); } if (p) return u = null, `${p}` || null; } function s() { return Ym().defined(i).curve(a).context(o); } return t = typeof t === 'function' ? t : void 0 === t ? Om : ym(+t), n = typeof n === 'function' ? n : ym(void 0 === n ? 0 : +n), e = typeof e === 'function' ? e : void 0 === e ? Bm : ym(+e), f.x = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : ym(+n), r = null, f) : t; }, f.x0 = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : ym(+n), f) : t; }, f.x1 = function (t) { return arguments.length ? (r = t == null ? null : typeof t === 'function' ? t : ym(+t), f) : r; }, f.y = function (t) { return arguments.length ? (n = typeof t === 'function' ? t : ym(+t), e = null, f) : n; }, f.y0 = function (t) { return arguments.length ? (n = typeof t === 'function' ? t : ym(+t), f) : n; }, f.y1 = function (t) { return arguments.length ? (e = t == null ? null : typeof t === 'function' ? t : ym(+t), f) : e; }, f.lineX0 = f.lineY0 = function () { return s().x(t).y(n); }, f.lineY1 = function () { return s().x(t).y(e); }, f.lineX1 = function () { return s().x(r).y(n); }, f.defined = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : ym(!!t), f) : i; }, f.curve = function (t) { return arguments.length ? (a = t, o != null && (u = a(o)), f) : a; }, f.context = function (t) { return arguments.length ? (t == null ? o = u = null : u = a(o = t), f) : o; }, f; } function jm(t, n) { return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN; } function Hm(t) { return t; }Um.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._point = 0; }, lineEnd() { (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line; }, point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; default: this._context.lineTo(t, n); } },
  }; const Xm = Vm(Im); function Gm(t) { this._curve = t; } function Vm(t) { function n(n) { return new Gm(t(n)); } return n._curve = t, n; } function Wm(t) { const n = t.curve; return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t.curve = function (t) { return arguments.length ? n(Vm(t)) : n()._curve; }, t; } function Zm() { return Wm(Ym().curve(Xm)); } function Km() { const t = Lm().curve(Xm); const n = t.curve; const e = t.lineX0; const r = t.lineX1; const i = t.lineY0; const o = t.lineY1; return t.angle = t.x, delete t.x, t.startAngle = t.x0, delete t.x0, t.endAngle = t.x1, delete t.x1, t.radius = t.y, delete t.y, t.innerRadius = t.y0, delete t.y0, t.outerRadius = t.y1, delete t.y1, t.lineStartAngle = function () { return Wm(e()); }, delete t.lineX0, t.lineEndAngle = function () { return Wm(r()); }, delete t.lineX1, t.lineInnerRadius = function () { return Wm(i()); }, delete t.lineY0, t.lineOuterRadius = function () { return Wm(o()); }, delete t.lineY1, t.curve = function (t) { return arguments.length ? n(Vm(t)) : n()._curve; }, t; } function Qm(t, n) { return [(n = +n) * Math.cos(t -= Math.PI / 2), n * Math.sin(t)]; }Gm.prototype = {
    areaStart() { this._curve.areaStart(); }, areaEnd() { this._curve.areaEnd(); }, lineStart() { this._curve.lineStart(); }, lineEnd() { this._curve.lineEnd(); }, point(t, n) { this._curve.point(n * Math.sin(t), n * -Math.cos(t)); },
  }; class Jm {
    constructor(t, n) { this._context = t, this._x = n; }

    areaStart() { this._line = 0; }

    areaEnd() { this._line = NaN; }

    lineStart() { this._point = 0; }

    lineEnd() { (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line; }

    point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; default: this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n); } this._x0 = t, this._y0 = n; }
  } class tx {
    constructor(t) { this._context = t; }

    lineStart() { this._point = 0; }

    lineEnd() {}

    point(t, n) { if (t = +t, n = +n, this._point === 0) this._point = 1; else { const e = Qm(this._x0, this._y0); const r = Qm(this._x0, this._y0 = (this._y0 + n) / 2); const i = Qm(t, this._y0); const o = Qm(t, n); this._context.moveTo(...e), this._context.bezierCurveTo(...r, ...i, ...o); } this._x0 = t, this._y0 = n; }
  } function nx(t) { return new Jm(t, !0); } function ex(t) { return new Jm(t, !1); } function rx(t) { return new tx(t); } function ix(t) { return t.source; } function ox(t) { return t.target; } function ax(t) { let n = ix; let e = ox; let r = Om; let i = Bm; let o = null; let a = null; const u = km(c); function c() { let c; const f = Fm.call(arguments); const s = n.apply(this, f); const l = e.apply(this, f); if (o == null && (a = t(c = u())), a.lineStart(), f[0] = s, a.point(+r.apply(this, f), +i.apply(this, f)), f[0] = l, a.point(+r.apply(this, f), +i.apply(this, f)), a.lineEnd(), c) return a = null, `${c}` || null; } return c.source = function (t) { return arguments.length ? (n = t, c) : n; }, c.target = function (t) { return arguments.length ? (e = t, c) : e; }, c.x = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : ym(+t), c) : r; }, c.y = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : ym(+t), c) : i; }, c.context = function (n) { return arguments.length ? (n == null ? o = a = null : a = t(o = n), c) : o; }, c; } const ux = Mm(3); const cx = { draw(t, n) { const e = 0.59436 * Mm(n + xm(n / 28, 0.75)); const r = e / 2; const i = r * ux; t.moveTo(0, e), t.lineTo(0, -e), t.moveTo(-i, -r), t.lineTo(i, r), t.moveTo(-i, r), t.lineTo(i, -r); } }; const fx = { draw(t, n) { const e = Mm(n / Am); t.moveTo(e, 0), t.arc(0, 0, e, 0, Em); } }; const sx = { draw(t, n) { const e = Mm(n / 5) / 2; t.moveTo(-3 * e, -e), t.lineTo(-e, -e), t.lineTo(-e, -3 * e), t.lineTo(e, -3 * e), t.lineTo(e, -e), t.lineTo(3 * e, -e), t.lineTo(3 * e, e), t.lineTo(e, e), t.lineTo(e, 3 * e), t.lineTo(-e, 3 * e), t.lineTo(-e, e), t.lineTo(-3 * e, e), t.closePath(); } }; const lx = Mm(1 / 3); const hx = 2 * lx; const dx = { draw(t, n) { const e = Mm(n / hx); const r = e * lx; t.moveTo(0, -e), t.lineTo(r, 0), t.lineTo(0, e), t.lineTo(-r, 0), t.closePath(); } }; const px = { draw(t, n) { const e = 0.62625 * Mm(n); t.moveTo(0, -e), t.lineTo(e, 0), t.lineTo(0, e), t.lineTo(-e, 0), t.closePath(); } }; const gx = { draw(t, n) { const e = 0.87559 * Mm(n - xm(n / 7, 2)); t.moveTo(-e, 0), t.lineTo(e, 0), t.moveTo(0, e), t.lineTo(0, -e); } }; const yx = { draw(t, n) { const e = Mm(n); const r = -e / 2; t.rect(r, r, e, e); } }; const vx = { draw(t, n) { const e = 0.4431 * Mm(n); t.moveTo(e, e), t.lineTo(e, -e), t.lineTo(-e, -e), t.lineTo(-e, e), t.closePath(); } }; const _x = wm(Am / 10) / wm(7 * Am / 10); const bx = wm(Em / 10) * _x; const mx = -bm(Em / 10) * _x; const xx = { draw(t, n) { const e = Mm(0.8908130915292852 * n); const r = bx * e; const i = mx * e; t.moveTo(0, -e), t.lineTo(r, i); for (let n = 1; n < 5; ++n) { const o = Em * n / 5; const a = bm(o); const u = wm(o); t.lineTo(u * e, -a * e), t.lineTo(a * r - u * i, u * r + a * i); }t.closePath(); } }; const wx = Mm(3); const Mx = { draw(t, n) { const e = -Mm(n / (3 * wx)); t.moveTo(0, 2 * e), t.lineTo(-wx * e, -e), t.lineTo(wx * e, -e), t.closePath(); } }; const Tx = Mm(3); const Ax = { draw(t, n) { const e = 0.6824 * Mm(n); const r = e / 2; const i = e * Tx / 2; t.moveTo(0, -e), t.lineTo(i, r), t.lineTo(-i, r), t.closePath(); } }; const Sx = -0.5; const Ex = Mm(3) / 2; const Nx = 1 / Mm(12); const kx = 3 * (Nx / 2 + 1); const Cx = { draw(t, n) { const e = Mm(n / kx); const r = e / 2; const i = e * Nx; const o = r; const a = e * Nx + e; const u = -o; const c = a; t.moveTo(r, i), t.lineTo(o, a), t.lineTo(u, c), t.lineTo(Sx * r - Ex * i, Ex * r + Sx * i), t.lineTo(Sx * o - Ex * a, Ex * o + Sx * a), t.lineTo(Sx * u - Ex * c, Ex * u + Sx * c), t.lineTo(Sx * r + Ex * i, Sx * i - Ex * r), t.lineTo(Sx * o + Ex * a, Sx * a - Ex * o), t.lineTo(Sx * u + Ex * c, Sx * c - Ex * u), t.closePath(); } }; const Px = { draw(t, n) { const e = 0.6189 * Mm(n - xm(n / 6, 1.7)); t.moveTo(-e, -e), t.lineTo(e, e), t.moveTo(-e, e), t.lineTo(e, -e); } }; const zx = [fx, sx, dx, yx, xx, Mx, Cx]; const $x = [fx, gx, Px, Ax, cx, vx, px]; function Dx() {} function Rx(t, n, e) { t._context.bezierCurveTo((2 * t._x0 + t._x1) / 3, (2 * t._y0 + t._y1) / 3, (t._x0 + 2 * t._x1) / 3, (t._y0 + 2 * t._y1) / 3, (t._x0 + 4 * t._x1 + n) / 6, (t._y0 + 4 * t._y1 + e) / 6); } function Fx(t) { this._context = t; } function qx(t) { this._context = t; } function Ux(t) { this._context = t; } function Ix(t, n) { this._basis = new Fx(t), this._beta = n; }Fx.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0; }, lineEnd() { switch (this._point) { case 3: Rx(this, this._x1, this._y1); case 2: this._context.lineTo(this._x1, this._y1); }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line; }, point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; break; case 2: this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); default: Rx(this, t, n); } this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n; },
  }, qx.prototype = {
    areaStart: Dx, areaEnd: Dx, lineStart() { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0; }, lineEnd() { switch (this._point) { case 1: this._context.moveTo(this._x2, this._y2), this._context.closePath(); break; case 2: this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath(); break; case 3: this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4); } }, point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._x2 = t, this._y2 = n; break; case 1: this._point = 2, this._x3 = t, this._y3 = n; break; case 2: this._point = 3, this._x4 = t, this._y4 = n, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + n) / 6); break; default: Rx(this, t, n); } this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n; },
  }, Ux.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0; }, lineEnd() { (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line; }, point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3; var e = (this._x0 + 4 * this._x1 + t) / 6; var r = (this._y0 + 4 * this._y1 + n) / 6; this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r); break; case 3: this._point = 4; default: Rx(this, t, n); } this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n; },
  }, Ix.prototype = { lineStart() { this._x = [], this._y = [], this._basis.lineStart(); }, lineEnd() { const t = this._x; const n = this._y; const e = t.length - 1; if (e > 0) for (var r, i = t[0], o = n[0], a = t[e] - i, u = n[e] - o, c = -1; ++c <= e;)r = c / e, this._basis.point(this._beta * t[c] + (1 - this._beta) * (i + r * a), this._beta * n[c] + (1 - this._beta) * (o + r * u)); this._x = this._y = null, this._basis.lineEnd(); }, point(t, n) { this._x.push(+t), this._y.push(+n); } }; const Ox = (function t(n) { function e(t) { return n === 1 ? new Fx(t) : new Ix(t, n); } return e.beta = function (n) { return t(+n); }, e; }(0.85)); function Bx(t, n, e) { t._context.bezierCurveTo(t._x1 + t._k * (t._x2 - t._x0), t._y1 + t._k * (t._y2 - t._y0), t._x2 + t._k * (t._x1 - n), t._y2 + t._k * (t._y1 - e), t._x2, t._y2); } function Yx(t, n) { this._context = t, this._k = (1 - n) / 6; }Yx.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0; }, lineEnd() { switch (this._point) { case 2: this._context.lineTo(this._x2, this._y2); break; case 3: Bx(this, this._x1, this._y1); }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line; }, point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2, this._x1 = t, this._y1 = n; break; case 2: this._point = 3; default: Bx(this, t, n); } this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n; },
  }; const Lx = (function t(n) { function e(t) { return new Yx(t, n); } return e.tension = function (n) { return t(+n); }, e; }(0)); function jx(t, n) { this._context = t, this._k = (1 - n) / 6; }jx.prototype = {
    areaStart: Dx, areaEnd: Dx, lineStart() { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0; }, lineEnd() { switch (this._point) { case 1: this._context.moveTo(this._x3, this._y3), this._context.closePath(); break; case 2: this._context.lineTo(this._x3, this._y3), this._context.closePath(); break; case 3: this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5); } }, point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._x3 = t, this._y3 = n; break; case 1: this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n); break; case 2: this._point = 3, this._x5 = t, this._y5 = n; break; default: Bx(this, t, n); } this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n; },
  }; const Hx = (function t(n) { function e(t) { return new jx(t, n); } return e.tension = function (n) { return t(+n); }, e; }(0)); function Xx(t, n) { this._context = t, this._k = (1 - n) / 6; }Xx.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0; }, lineEnd() { (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line; }, point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break; case 3: this._point = 4; default: Bx(this, t, n); } this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n; },
  }; const Gx = (function t(n) { function e(t) { return new Xx(t, n); } return e.tension = function (n) { return t(+n); }, e; }(0)); function Vx(t, n, e) { let r = t._x1; let i = t._y1; let o = t._x2; let a = t._y2; if (t._l01_a > Tm) { const u = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a; const c = 3 * t._l01_a * (t._l01_a + t._l12_a); r = (r * u - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / c, i = (i * u - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / c; } if (t._l23_a > Tm) { const f = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a; const s = 3 * t._l23_a * (t._l23_a + t._l12_a); o = (o * f + t._x1 * t._l23_2a - n * t._l12_2a) / s, a = (a * f + t._y1 * t._l23_2a - e * t._l12_2a) / s; }t._context.bezierCurveTo(r, i, o, a, t._x2, t._y2); } function Wx(t, n) { this._context = t, this._alpha = n; }Wx.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0; }, lineEnd() { switch (this._point) { case 2: this._context.lineTo(this._x2, this._y2); break; case 3: this.point(this._x2, this._y2); }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line; }, point(t, n) { if (t = +t, n = +n, this._point) { const e = this._x2 - t; const r = this._y2 - n; this._l23_a = Math.sqrt(this._l23_2a = (e * e + r * r) ** this._alpha); } switch (this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; break; case 2: this._point = 3; default: Vx(this, t, n); } this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n; },
  }; const Zx = (function t(n) { function e(t) { return n ? new Wx(t, n) : new Yx(t, 0); } return e.alpha = function (n) { return t(+n); }, e; }(0.5)); function Kx(t, n) { this._context = t, this._alpha = n; }Kx.prototype = {
    areaStart: Dx, areaEnd: Dx, lineStart() { this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0; }, lineEnd() { switch (this._point) { case 1: this._context.moveTo(this._x3, this._y3), this._context.closePath(); break; case 2: this._context.lineTo(this._x3, this._y3), this._context.closePath(); break; case 3: this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5); } }, point(t, n) { if (t = +t, n = +n, this._point) { const e = this._x2 - t; const r = this._y2 - n; this._l23_a = Math.sqrt(this._l23_2a = (e * e + r * r) ** this._alpha); } switch (this._point) { case 0: this._point = 1, this._x3 = t, this._y3 = n; break; case 1: this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n); break; case 2: this._point = 3, this._x5 = t, this._y5 = n; break; default: Vx(this, t, n); } this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n; },
  }; const Qx = (function t(n) { function e(t) { return n ? new Kx(t, n) : new jx(t, 0); } return e.alpha = function (n) { return t(+n); }, e; }(0.5)); function Jx(t, n) { this._context = t, this._alpha = n; }Jx.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0; }, lineEnd() { (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line; }, point(t, n) { if (t = +t, n = +n, this._point) { const e = this._x2 - t; const r = this._y2 - n; this._l23_a = Math.sqrt(this._l23_2a = (e * e + r * r) ** this._alpha); } switch (this._point) { case 0: this._point = 1; break; case 1: this._point = 2; break; case 2: this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break; case 3: this._point = 4; default: Vx(this, t, n); } this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n; },
  }; const tw = (function t(n) { function e(t) { return n ? new Jx(t, n) : new Xx(t, 0); } return e.alpha = function (n) { return t(+n); }, e; }(0.5)); function nw(t) { this._context = t; } function ew(t) { return t < 0 ? -1 : 1; } function rw(t, n, e) { const r = t._x1 - t._x0; const i = n - t._x1; const o = (t._y1 - t._y0) / (r || i < 0 && -0); const a = (e - t._y1) / (i || r < 0 && -0); const u = (o * i + a * r) / (r + i); return (ew(o) + ew(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(u)) || 0; } function iw(t, n) { const e = t._x1 - t._x0; return e ? (3 * (t._y1 - t._y0) / e - n) / 2 : n; } function ow(t, n, e) { const r = t._x0; const i = t._y0; const o = t._x1; const a = t._y1; const u = (o - r) / 3; t._context.bezierCurveTo(r + u, i + u * n, o - u, a - u * e, o, a); } function aw(t) { this._context = t; } function uw(t) { this._context = new cw(t); } function cw(t) { this._context = t; } function fw(t) { this._context = t; } function sw(t) { let n; let e; const r = t.length - 1; const i = new Array(r); const o = new Array(r); const a = new Array(r); for (i[0] = 0, o[0] = 2, a[0] = t[0] + 2 * t[1], n = 1; n < r - 1; ++n)i[n] = 1, o[n] = 4, a[n] = 4 * t[n] + 2 * t[n + 1]; for (i[r - 1] = 2, o[r - 1] = 7, a[r - 1] = 8 * t[r - 1] + t[r], n = 1; n < r; ++n)e = i[n] / o[n - 1], o[n] -= e, a[n] -= e * a[n - 1]; for (i[r - 1] = a[r - 1] / o[r - 1], n = r - 2; n >= 0; --n)i[n] = (a[n] - i[n + 1]) / o[n]; for (o[r - 1] = (t[r] + i[r - 1]) / 2, n = 0; n < r - 1; ++n)o[n] = 2 * t[n + 1] - i[n + 1]; return [i, o]; } function lw(t, n) { this._context = t, this._t = n; } function hw(t, n) { if ((i = t.length) > 1) for (var e, r, i, o = 1, a = t[n[0]], u = a.length; o < i; ++o) for (r = a, a = t[n[o]], e = 0; e < u; ++e)a[e][1] += a[e][0] = isNaN(r[e][1]) ? r[e][0] : r[e][1]; } function dw(t) { for (var n = t.length, e = new Array(n); --n >= 0;)e[n] = n; return e; } function pw(t, n) { return t[n]; } function gw(t) { const n = []; return n.key = t, n; } function yw(t) { const n = t.map(vw); return dw(t).sort(((t, e) => n[t] - n[e])); } function vw(t) { for (var n, e = -1, r = 0, i = t.length, o = -1 / 0; ++e < i;)(n = +t[e][1]) > o && (o = n, r = e); return r; } function _w(t) { const n = t.map(bw); return dw(t).sort(((t, e) => n[t] - n[e])); } function bw(t) { for (var n, e = 0, r = -1, i = t.length; ++r < i;)(n = +t[r][1]) && (e += n); return e; }nw.prototype = {
    areaStart: Dx, areaEnd: Dx, lineStart() { this._point = 0; }, lineEnd() { this._point && this._context.closePath(); }, point(t, n) { t = +t, n = +n, this._point ? this._context.lineTo(t, n) : (this._point = 1, this._context.moveTo(t, n)); },
  }, aw.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0; }, lineEnd() { switch (this._point) { case 2: this._context.lineTo(this._x1, this._y1); break; case 3: ow(this, this._t0, iw(this, this._t0)); }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line; }, point(t, n) { let e = NaN; if (n = +n, (t = +t) !== this._x1 || n !== this._y1) { switch (this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; break; case 2: this._point = 3, ow(this, iw(this, e = rw(this, t, n)), e); break; default: ow(this, this._t0, e = rw(this, t, n)); } this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n, this._t0 = e; } },
  }, (uw.prototype = Object.create(aw.prototype)).point = function (t, n) { aw.prototype.point.call(this, n, t); }, cw.prototype = {
    moveTo(t, n) { this._context.moveTo(n, t); }, closePath() { this._context.closePath(); }, lineTo(t, n) { this._context.lineTo(n, t); }, bezierCurveTo(t, n, e, r, i, o) { this._context.bezierCurveTo(n, t, r, e, o, i); },
  }, fw.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._x = [], this._y = []; }, lineEnd() { const t = this._x; const n = this._y; const e = t.length; if (e) if (this._line ? this._context.lineTo(t[0], n[0]) : this._context.moveTo(t[0], n[0]), e === 2) this._context.lineTo(t[1], n[1]); else for (let r = sw(t), i = sw(n), o = 0, a = 1; a < e; ++o, ++a) this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], t[a], n[a]); (this._line || this._line !== 0 && e === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null; }, point(t, n) { this._x.push(+t), this._y.push(+n); },
  }, lw.prototype = {
    areaStart() { this._line = 0; }, areaEnd() { this._line = NaN; }, lineStart() { this._x = this._y = NaN, this._point = 0; }, lineEnd() { this._t > 0 && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line); }, point(t, n) { switch (t = +t, n = +n, this._point) { case 0: this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n); break; case 1: this._point = 2; default: if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n); else { const e = this._x * (1 - this._t) + t * this._t; this._context.lineTo(e, this._y), this._context.lineTo(e, n); } } this._x = t, this._y = n; },
  }; const mw = (t) => () => t; function xw(t, {
    sourceEvent: n, target: e, transform: r, dispatch: i,
  }) {
    Object.defineProperties(this, {
      type: { value: t, enumerable: !0, configurable: !0 }, sourceEvent: { value: n, enumerable: !0, configurable: !0 }, target: { value: e, enumerable: !0, configurable: !0 }, transform: { value: r, enumerable: !0, configurable: !0 }, _: { value: i },
    });
  } function ww(t, n, e) { this.k = t, this.x = n, this.y = e; }ww.prototype = {
    constructor: ww, scale(t) { return t === 1 ? this : new ww(this.k * t, this.x, this.y); }, translate(t, n) { return t === 0 & n === 0 ? this : new ww(this.k, this.x + this.k * t, this.y + this.k * n); }, apply(t) { return [t[0] * this.k + this.x, t[1] * this.k + this.y]; }, applyX(t) { return t * this.k + this.x; }, applyY(t) { return t * this.k + this.y; }, invert(t) { return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k]; }, invertX(t) { return (t - this.x) / this.k; }, invertY(t) { return (t - this.y) / this.k; }, rescaleX(t) { return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t)); }, rescaleY(t) { return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t)); }, toString() { return `translate(${this.x},${this.y}) scale(${this.k})`; },
  }; const Mw = new ww(1, 0, 0); function Tw(t) { for (;!t.__zoom;) if (!(t = t.parentNode)) return Mw; return t.__zoom; } function Aw(t) { t.stopImmediatePropagation(); } function Sw(t) { t.preventDefault(), t.stopImmediatePropagation(); } function Ew(t) { return !(t.ctrlKey && t.type !== 'wheel' || t.button); } function Nw() { let t = this; return t instanceof SVGElement ? (t = t.ownerSVGElement || t).hasAttribute('viewBox') ? [[(t = t.viewBox.baseVal).x, t.y], [t.x + t.width, t.y + t.height]] : [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]] : [[0, 0], [t.clientWidth, t.clientHeight]]; } function kw() { return this.__zoom || Mw; } function Cw(t) { return -t.deltaY * (t.deltaMode === 1 ? 0.05 : t.deltaMode ? 1 : 0.002) * (t.ctrlKey ? 10 : 1); } function Pw() { return navigator.maxTouchPoints || 'ontouchstart' in this; } function zw(t, n, e) { const r = t.invertX(n[0][0]) - e[0][0]; const i = t.invertX(n[1][0]) - e[1][0]; const o = t.invertY(n[0][1]) - e[0][1]; const a = t.invertY(n[1][1]) - e[1][1]; return t.translate(i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i), a > o ? (o + a) / 2 : Math.min(0, o) || Math.max(0, a)); }Tw.prototype = ww.prototype, t.Adder = T, t.Delaunay = Lu, t.FormatSpecifier = tf, t.InternMap = InternMap, t.InternSet = InternSet, t.Node = Qd, t.Path = Ua, t.Voronoi = qu, t.ZoomTransform = ww, t.active = function (t, n) { let e; let r; const i = t.__transition; if (i) for (r in n = n == null ? null : `${n}`, i) if ((e = i[r]).state > qi && e.name === n) return new po([[t]], Zo, n, +r); return null; }, t.arc = function () { let t = Cm; let n = Pm; let e = ym(0); let r = null; let i = zm; let o = $m; let a = Dm; let u = null; const c = km(f); function f() { let f; let s; let l = +t.apply(this, arguments); let h = +n.apply(this, arguments); const d = i.apply(this, arguments) - Sm; const p = o.apply(this, arguments) - Sm; const g = vm(p - d); const y = p > d; if (u || (u = f = c()), h < l && (s = h, h = l, l = s), h > Tm) if (g > Em - Tm)u.moveTo(h * bm(d), h * wm(d)), u.arc(0, 0, h, d, p, !y), l > Tm && (u.moveTo(l * bm(p), l * wm(p)), u.arc(0, 0, l, p, d, y)); else { let v; let _; let b = d; let m = p; let x = d; let w = p; let M = g; let T = g; const A = a.apply(this, arguments) / 2; const S = A > Tm && (r ? +r.apply(this, arguments) : Mm(l * l + h * h)); const E = xm(vm(h - l) / 2, +e.apply(this, arguments)); let N = E; let k = E; if (S > Tm) { let C = Nm(S / l * wm(A)); let P = Nm(S / h * wm(A)); (M -= 2 * C) > Tm ? (x += C *= y ? 1 : -1, w -= C) : (M = 0, x = w = (d + p) / 2), (T -= 2 * P) > Tm ? (b += P *= y ? 1 : -1, m -= P) : (T = 0, b = m = (d + p) / 2); } const z = h * bm(b); const $ = h * wm(b); const D = l * bm(w); const R = l * wm(w); if (E > Tm) { let F; var q = h * bm(m); var U = h * wm(m); var I = l * bm(x); var O = l * wm(x); if (g < Am) if (F = (function (t, n, e, r, i, o, a, u) { const c = e - t; const f = r - n; const s = a - i; const l = u - o; let h = l * c - s * f; if (!(h * h < Tm)) return [t + (h = (s * (n - o) - l * (t - i)) / h) * c, n + h * f]; }(z, $, I, O, q, U, D, R))) { const B = z - F[0]; const Y = $ - F[1]; const L = q - F[0]; const j = U - F[1]; const H = 1 / wm((function (t) { return t > 1 ? 0 : t < -1 ? Am : Math.acos(t); }((B * L + Y * j) / (Mm(B * B + Y * Y) * Mm(L * L + j * j)))) / 2); const X = Mm(F[0] * F[0] + F[1] * F[1]); N = xm(E, (l - X) / (H - 1)), k = xm(E, (h - X) / (H + 1)); } else N = k = 0; }T > Tm ? k > Tm ? (v = Rm(I, O, z, $, h, k, y), _ = Rm(q, U, D, R, h, k, y), u.moveTo(v.cx + v.x01, v.cy + v.y01), k < E ? u.arc(v.cx, v.cy, k, _m(v.y01, v.x01), _m(_.y01, _.x01), !y) : (u.arc(v.cx, v.cy, k, _m(v.y01, v.x01), _m(v.y11, v.x11), !y), u.arc(0, 0, h, _m(v.cy + v.y11, v.cx + v.x11), _m(_.cy + _.y11, _.cx + _.x11), !y), u.arc(_.cx, _.cy, k, _m(_.y11, _.x11), _m(_.y01, _.x01), !y))) : (u.moveTo(z, $), u.arc(0, 0, h, b, m, !y)) : u.moveTo(z, $), l > Tm && M > Tm ? N > Tm ? (v = Rm(D, R, q, U, l, -N, y), _ = Rm(z, $, I, O, l, -N, y), u.lineTo(v.cx + v.x01, v.cy + v.y01), N < E ? u.arc(v.cx, v.cy, N, _m(v.y01, v.x01), _m(_.y01, _.x01), !y) : (u.arc(v.cx, v.cy, N, _m(v.y01, v.x01), _m(v.y11, v.x11), !y), u.arc(0, 0, l, _m(v.cy + v.y11, v.cx + v.x11), _m(_.cy + _.y11, _.cx + _.x11), y), u.arc(_.cx, _.cy, N, _m(_.y11, _.x11), _m(_.y01, _.x01), !y))) : u.arc(0, 0, l, w, x, y) : u.lineTo(D, R); } else u.moveTo(0, 0); if (u.closePath(), f) return u = null, `${f}` || null; } return f.centroid = function () { const e = (+t.apply(this, arguments) + +n.apply(this, arguments)) / 2; const r = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Am / 2; return [bm(r) * e, wm(r) * e]; }, f.innerRadius = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : ym(+n), f) : t; }, f.outerRadius = function (t) { return arguments.length ? (n = typeof t === 'function' ? t : ym(+t), f) : n; }, f.cornerRadius = function (t) { return arguments.length ? (e = typeof t === 'function' ? t : ym(+t), f) : e; }, f.padRadius = function (t) { return arguments.length ? (r = t == null ? null : typeof t === 'function' ? t : ym(+t), f) : r; }, f.startAngle = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : ym(+t), f) : i; }, f.endAngle = function (t) { return arguments.length ? (o = typeof t === 'function' ? t : ym(+t), f) : o; }, f.padAngle = function (t) { return arguments.length ? (a = typeof t === 'function' ? t : ym(+t), f) : a; }, f.context = function (t) { return arguments.length ? (u = t == null ? null : t, f) : u; }, f; }, t.area = Lm, t.areaRadial = Km, t.ascending = n, t.autoType = function (t) { for (const n in t) { var e; var r; let i = t[n].trim(); if (i) if (i === 'true')i = !0; else if (i === 'false')i = !1; else if (i === 'NaN')i = NaN; else if (isNaN(e = +i)) { if (!(r = i.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/))) continue; yc && r[4] && !r[7] && (i = i.replace(/-/g, '/').replace(/T/, ' ')), i = new Date(i); } else i = e; else i = null; t[n] = i; } return t; }, t.axisBottom = function (t) { return Pt(Mt, t); }, t.axisLeft = function (t) { return Pt(Tt, t); }, t.axisRight = function (t) { return Pt(wt, t); }, t.axisTop = function (t) { return Pt(xt, t); }, t.bin = Q, t.bisect = s, t.bisectCenter = f, t.bisectLeft = c, t.bisectRight = u, t.bisector = r, t.blob = function (t, n) { return fetch(t, n).then(vc); }, t.blur = function (t, n) { if (!((n = +n) >= 0)) throw new RangeError('invalid r'); let e = t.length; if (!((e = Math.floor(e)) >= 0)) throw new RangeError('invalid length'); if (!e || !n) return t; const r = y(n); const i = t.slice(); return r(t, i, 0, e, 1), r(i, t, 0, e, 1), r(t, i, 0, e, 1), t; }, t.blur2 = l, t.blurImage = h, t.brush = function () { return wa(la); }, t.brushSelection = function (t) { const n = t.__brush; return n ? n.dim.output(n.selection) : null; }, t.brushX = function () { return wa(fa); }, t.brushY = function () { return wa(sa); }, t.buffer = function (t, n) { return fetch(t, n).then(_c); }, t.chord = function () { return za(!1, !1); }, t.chordDirected = function () { return za(!0, !1); }, t.chordTranspose = function () { return za(!1, !0); }, t.cluster = function () { let t = Ld; let n = 1; let e = 1; let r = !1; function i(i) { let o; let a = 0; i.eachAfter(((n) => { const e = n.children; e ? (n.x = (function (t) { return t.reduce(jd, 0) / t.length; }(e)), n.y = (function (t) { return 1 + t.reduce(Hd, 0); }(e))) : (n.x = o ? a += t(n, o) : 0, n.y = 0, o = n); })); const u = (function (t) { for (var n; n = t.children;)t = n[0]; return t; }(i)); const c = (function (t) { for (var n; n = t.children;)t = n[n.length - 1]; return t; }(i)); const f = u.x - t(u, c) / 2; const s = c.x + t(c, u) / 2; return i.eachAfter(r ? (t) => { t.x = (t.x - i.x) * n, t.y = (i.y - t.y) * e; } : (t) => { t.x = (t.x - f) / (s - f) * n, t.y = (1 - (i.y ? t.y / i.y : 1)) * e; }); } return i.separation = function (n) { return arguments.length ? (t = n, i) : t; }, i.size = function (t) { return arguments.length ? (r = !1, n = +t[0], e = +t[1], i) : r ? null : [n, e]; }, i.nodeSize = function (t) { return arguments.length ? (r = !0, n = +t[0], e = +t[1], i) : r ? [n, e] : null; }, i; }, t.color = ze, t.contourDensity = function () { let t = fu; let n = su; let e = lu; let r = 960; let i = 500; let o = 20; let a = 2; let u = 3 * o; let c = r + 2 * u >> a; let f = i + 2 * u >> a; let s = Qa(20); function h(r) { const i = new Float32Array(c * f); const s = 2 ** -a; let h = -1; for (const o of r) { const d = (t(o, ++h, r) + u) * s; const p = (n(o, h, r) + u) * s; const g = +e(o, h, r); if (g && d >= 0 && d < c && p >= 0 && p < f) { const y = Math.floor(d); const v = Math.floor(p); const _ = d - y - 0.5; const b = p - v - 0.5; i[y + v * c] += (1 - _) * (1 - b) * g, i[y + 1 + v * c] += _ * (1 - b) * g, i[y + 1 + (v + 1) * c] += _ * b * g, i[y + (v + 1) * c] += (1 - _) * b * g; } } return l({ data: i, width: c, height: f }, o * s), i; } function d(t) { const n = h(t); let e = s(n); const r = 2 ** (2 * a); return Array.isArray(e) || (e = G(Number.MIN_VALUE, J(n) / r, e)), iu().size([c, f]).thresholds(e.map(((t) => t * r)))(n).map(((t, n) => (t.value = +e[n], p(t)))); } function p(t) { return t.coordinates.forEach(g), t; } function g(t) { t.forEach(y); } function y(t) { t.forEach(v); } function v(t) { t[0] = t[0] * 2 ** a - u, t[1] = t[1] * 2 ** a - u; } function _() { return c = r + 2 * (u = 3 * o) >> a, f = i + 2 * u >> a, d; } return d.contours = function (t) { const n = h(t); const e = iu().size([c, f]); const r = 2 ** (2 * a); const i = (t) => { t = +t; const i = p(e.contour(n, t * r)); return i.value = t, i; }; return Object.defineProperty(i, 'max', { get: () => J(n) / r }), i; }, d.x = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : Qa(+n), d) : t; }, d.y = function (t) { return arguments.length ? (n = typeof t === 'function' ? t : Qa(+t), d) : n; }, d.weight = function (t) { return arguments.length ? (e = typeof t === 'function' ? t : Qa(+t), d) : e; }, d.size = function (t) { if (!arguments.length) return [r, i]; const n = +t[0]; const e = +t[1]; if (!(n >= 0 && e >= 0)) throw new Error('invalid size'); return r = n, i = e, _(); }, d.cellSize = function (t) { if (!arguments.length) return 1 << a; if (!((t = +t) >= 1)) throw new Error('invalid cell size'); return a = Math.floor(Math.log(t) / Math.LN2), _(); }, d.thresholds = function (t) { return arguments.length ? (s = typeof t === 'function' ? t : Array.isArray(t) ? Qa(Za.call(t)) : Qa(t), d) : s; }, d.bandwidth = function (t) { if (!arguments.length) return Math.sqrt(o * (o + 1)); if (!((t = +t) >= 0)) throw new Error('invalid bandwidth'); return o = (Math.sqrt(4 * t * t + 1) - 1) / 2, _(); }, d; }, t.contours = iu, t.count = v, t.create = function (t) { return Zn(Yt(t).call(document.documentElement)); }, t.creator = Yt, t.cross = function (...t) { const n = typeof t[t.length - 1] === 'function' && (function (t) { return (n) => t(...n); }(t.pop())); const e = (t = t.map(m)).map(_); const r = t.length - 1; const i = new Array(r + 1).fill(0); const o = []; if (r < 0 || e.some(b)) return o; for (;;) { o.push(i.map(((n, e) => t[e][n]))); let a = r; for (;++i[a] === e[a];) { if (a === 0) return n ? o.map(n) : o; i[a--] = 0; } } }, t.csv = wc, t.csvFormat = rc, t.csvFormatBody = ic, t.csvFormatRow = ac, t.csvFormatRows = oc, t.csvFormatValue = uc, t.csvParse = nc, t.csvParseRows = ec, t.cubehelix = Tr, t.cumsum = function (t, n) { let e = 0; let r = 0; return Float64Array.from(t, void 0 === n ? (t) => e += +t || 0 : (i) => e += +n(i, r++, t) || 0); }, t.curveBasis = function (t) { return new Fx(t); }, t.curveBasisClosed = function (t) { return new qx(t); }, t.curveBasisOpen = function (t) { return new Ux(t); }, t.curveBumpX = nx, t.curveBumpY = ex, t.curveBundle = Ox, t.curveCardinal = Lx, t.curveCardinalClosed = Hx, t.curveCardinalOpen = Gx, t.curveCatmullRom = Zx, t.curveCatmullRomClosed = Qx, t.curveCatmullRomOpen = tw, t.curveLinear = Im, t.curveLinearClosed = function (t) { return new nw(t); }, t.curveMonotoneX = function (t) { return new aw(t); }, t.curveMonotoneY = function (t) { return new uw(t); }, t.curveNatural = function (t) { return new fw(t); }, t.curveStep = function (t) { return new lw(t, 0.5); }, t.curveStepAfter = function (t) { return new lw(t, 1); }, t.curveStepBefore = function (t) { return new lw(t, 0); }, t.descending = e, t.deviation = w, t.difference = function (t, ...n) { t = new InternSet(t); for (const e of n) for (const n of e)t.delete(n); return t; }, t.disjoint = function (t, n) { const e = n[Symbol.iterator](); const r = new InternSet(); for (const n of t) { if (r.has(n)) return !1; let t; let i; for (;({ value: t, done: i } = e.next()) && !i;) { if (Object.is(n, t)) return !1; r.add(t); } } return !0; }, t.dispatch = $t, t.drag = function () {
    let t; let n; let e; let r; let i = se; let o = le; let a = he; let u = de; const c = {}; const f = $t('start', 'drag', 'end'); let s = 0; let l = 0; function h(t) {
      t.on('mousedown.drag', d).filter(u).on('touchstart.drag', y).on('touchmove.drag', v, ee)
        .on('touchend.drag touchcancel.drag', _)
        .style('touch-action', 'none')
        .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');
    } function d(a, u) { if (!r && i.call(this, a, u)) { const c = b(this, o.call(this, a, u), a, u, 'mouse'); c && (Zn(a.view).on('mousemove.drag', p, re).on('mouseup.drag', g, re), ae(a.view), ie(a), e = !1, t = a.clientX, n = a.clientY, c('start', a)); } } function p(r) { if (oe(r), !e) { const i = r.clientX - t; const o = r.clientY - n; e = i * i + o * o > l; }c.mouse('drag', r); } function g(t) { Zn(t.view).on('mousemove.drag mouseup.drag', null), ue(t.view, e), oe(t), c.mouse('end', t); } function y(t, n) { if (i.call(this, t, n)) { let e; let r; const a = t.changedTouches; const u = o.call(this, t, n); const c = a.length; for (e = 0; e < c; ++e)(r = b(this, u, t, n, a[e].identifier, a[e])) && (ie(t), r('start', t, a[e])); } } function v(t) { let n; let e; const r = t.changedTouches; const i = r.length; for (n = 0; n < i; ++n)(e = c[r[n].identifier]) && (oe(t), e('drag', t, r[n])); } function _(t) { let n; let e; const i = t.changedTouches; const o = i.length; for (r && clearTimeout(r), r = setTimeout((() => { r = null; }), 500), n = 0; n < o; ++n)(e = c[i[n].identifier]) && (ie(t), e('end', t, i[n])); } function b(t, n, e, r, i, o) {
      let u; let l; let d; const p = f.copy(); let g = ne(o || e, n); if ((d = a.call(t, new fe('beforestart', {
        sourceEvent: e, target: h, identifier: i, active: s, x: g[0], y: g[1], dx: 0, dy: 0, dispatch: p,
      }), r)) != null) {
        return u = d.x - g[0] || 0, l = d.y - g[1] || 0, function e(o, a, f) {
          let y; const v = g; switch (o) { case 'start': c[i] = e, y = s++; break; case 'end': delete c[i], --s; case 'drag': g = ne(f || a, n), y = s; }p.call(o, t, new fe(o, {
            sourceEvent: a, subject: d, target: h, identifier: i, active: y, x: g[0] + u, y: g[1] + l, dx: g[0] - v[0], dy: g[1] - v[1], dispatch: p,
          }), r);
        };
      }
    } return h.filter = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : ce(!!t), h) : i; }, h.container = function (t) { return arguments.length ? (o = typeof t === 'function' ? t : ce(t), h) : o; }, h.subject = function (t) { return arguments.length ? (a = typeof t === 'function' ? t : ce(t), h) : a; }, h.touchable = function (t) { return arguments.length ? (u = typeof t === 'function' ? t : ce(!!t), h) : u; }, h.on = function () { const t = f.on.apply(f, arguments); return t === f ? h : t; }, h.clickDistance = function (t) { return arguments.length ? (l = (t = +t) * t, h) : Math.sqrt(l); }, h;
  }, t.dragDisable = ae, t.dragEnable = ue, t.dsv = function (t, n, e, r) { arguments.length === 3 && typeof e === 'function' && (r = e, e = void 0); const i = Ju(t); return mc(n, e).then(((t) => i.parse(t, r))); }, t.dsvFormat = Ju, t.easeBack = Lo, t.easeBackIn = Bo, t.easeBackInOut = Lo, t.easeBackOut = Yo, t.easeBounce = Io, t.easeBounceIn = function (t) { return 1 - Io(1 - t); }, t.easeBounceInOut = function (t) { return ((t *= 2) <= 1 ? 1 - Io(1 - t) : Io(t - 1) + 1) / 2; }, t.easeBounceOut = Io, t.easeCircle = No, t.easeCircleIn = function (t) { return 1 - Math.sqrt(1 - t * t); }, t.easeCircleInOut = No, t.easeCircleOut = function (t) { return Math.sqrt(1 - --t * t); }, t.easeCubic = bo, t.easeCubicIn = function (t) { return t * t * t; }, t.easeCubicInOut = bo, t.easeCubicOut = function (t) { return --t * t * t + 1; }, t.easeElastic = Xo, t.easeElasticIn = Ho, t.easeElasticInOut = Go, t.easeElasticOut = Xo, t.easeExp = Eo, t.easeExpIn = function (t) { return So(1 - +t); }, t.easeExpInOut = Eo, t.easeExpOut = function (t) { return 1 - So(t); }, t.easeLinear = (t) => +t, t.easePoly = wo, t.easePolyIn = mo, t.easePolyInOut = wo, t.easePolyOut = xo, t.easeQuad = _o, t.easeQuadIn = function (t) { return t * t; }, t.easeQuadInOut = _o, t.easeQuadOut = function (t) { return t * (2 - t); }, t.easeSin = Ao, t.easeSinIn = function (t) { return +t == 1 ? 1 : 1 - Math.cos(t * To); }, t.easeSinInOut = Ao, t.easeSinOut = function (t) { return Math.sin(t * To); }, t.every = function (t, n) { if (typeof n !== 'function') throw new TypeError('test is not a function'); let e = -1; for (const r of t) if (!n(r, ++e, t)) return !1; return !0; }, t.extent = M, t.fcumsum = function (t, n) { const e = new T(); let r = -1; return Float64Array.from(t, void 0 === n ? (t) => e.add(+t || 0) : (i) => e.add(+n(i, ++r, t) || 0)); }, t.filter = function (t, n) { if (typeof n !== 'function') throw new TypeError('test is not a function'); const e = []; let r = -1; for (const i of t)n(i, ++r, t) && e.push(i); return e; }, t.flatGroup = function (t, ...n) { return z(P(t, ...n), n); }, t.flatRollup = function (t, n, ...e) { return z(D(t, n, ...e), e); }, t.forceCenter = function (t, n) { let e; let r = 1; function i() { let i; let o; const a = e.length; let u = 0; let c = 0; for (i = 0; i < a; ++i)u += (o = e[i]).x, c += o.y; for (u = (u / a - t) * r, c = (c / a - n) * r, i = 0; i < a; ++i)(o = e[i]).x -= u, o.y -= c; } return t == null && (t = 0), n == null && (n = 0), i.initialize = function (t) { e = t; }, i.x = function (n) { return arguments.length ? (t = +n, i) : t; }, i.y = function (t) { return arguments.length ? (n = +t, i) : n; }, i.strength = function (t) { return arguments.length ? (r = +t, i) : r; }, i; }, t.forceCollide = function (t) { let n; let e; let r; let i = 1; let o = 1; function a() { for (var t, a, c, f, s, l, h, d = n.length, p = 0; p < o; ++p) for (a = $c(n, Ic, Oc).visitAfter(u), t = 0; t < d; ++t)c = n[t], l = e[c.index], h = l * l, f = c.x + c.vx, s = c.y + c.vy, a.visit(g); function g(t, n, e, o, a) { const u = t.data; let d = t.r; let p = l + d; if (!u) return n > f + p || o < f - p || e > s + p || a < s - p; if (u.index > c.index) { let g = f - u.x - u.vx; let y = s - u.y - u.vy; let v = g * g + y * y; v < p * p && (g === 0 && (v += (g = Uc(r)) * g), y === 0 && (v += (y = Uc(r)) * y), v = (p - (v = Math.sqrt(v))) / v * i, c.vx += (g *= v) * (p = (d *= d) / (h + d)), c.vy += (y *= v) * p, u.vx -= g * (p = 1 - p), u.vy -= y * p); } } } function u(t) { if (t.data) return t.r = e[t.data.index]; for (let n = t.r = 0; n < 4; ++n)t[n] && t[n].r > t.r && (t.r = t[n].r); } function c() { if (n) { let r; let i; const o = n.length; for (e = new Array(o), r = 0; r < o; ++r)i = n[r], e[i.index] = +t(i, r, n); } } return typeof t !== 'function' && (t = qc(t == null ? 1 : +t)), a.initialize = function (t, e) { n = t, r = e, c(); }, a.iterations = function (t) { return arguments.length ? (o = +t, a) : o; }, a.strength = function (t) { return arguments.length ? (i = +t, a) : i; }, a.radius = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : qc(+n), c(), a) : t; }, a; }, t.forceLink = function (t) { let n; let e; let r; let i; let o; let a; let u = Bc; let c = function (t) { return 1 / Math.min(i[t.source.index], i[t.target.index]); }; let f = qc(30); let s = 1; function l(r) { for (let i = 0, u = t.length; i < s; ++i) for (var c, f, l, h, d, p, g, y = 0; y < u; ++y)f = (c = t[y]).source, h = (l = c.target).x + l.vx - f.x - f.vx || Uc(a), d = l.y + l.vy - f.y - f.vy || Uc(a), h *= p = ((p = Math.sqrt(h * h + d * d)) - e[y]) / p * r * n[y], d *= p, l.vx -= h * (g = o[y]), l.vy -= d * g, f.vx += h * (g = 1 - g), f.vy += d * g; } function h() { if (r) { let a; let c; const f = r.length; const s = t.length; const l = new Map(r.map(((t, n) => [u(t, n, r), t]))); for (a = 0, i = new Array(f); a < s; ++a)(c = t[a]).index = a, typeof c.source !== 'object' && (c.source = Yc(l, c.source)), typeof c.target !== 'object' && (c.target = Yc(l, c.target)), i[c.source.index] = (i[c.source.index] || 0) + 1, i[c.target.index] = (i[c.target.index] || 0) + 1; for (a = 0, o = new Array(s); a < s; ++a)c = t[a], o[a] = i[c.source.index] / (i[c.source.index] + i[c.target.index]); n = new Array(s), d(), e = new Array(s), p(); } } function d() { if (r) for (let e = 0, i = t.length; e < i; ++e)n[e] = +c(t[e], e, t); } function p() { if (r) for (let n = 0, i = t.length; n < i; ++n)e[n] = +f(t[n], n, t); } return t == null && (t = []), l.initialize = function (t, n) { r = t, a = n, h(); }, l.links = function (n) { return arguments.length ? (t = n, h(), l) : t; }, l.id = function (t) { return arguments.length ? (u = t, l) : u; }, l.iterations = function (t) { return arguments.length ? (s = +t, l) : s; }, l.strength = function (t) { return arguments.length ? (c = typeof t === 'function' ? t : qc(+t), d(), l) : c; }, l.distance = function (t) { return arguments.length ? (f = typeof t === 'function' ? t : qc(+t), p(), l) : f; }, l; }, t.forceManyBody = function () { let t; let n; let e; let r; let i; let o = qc(-30); let a = 1; let u = 1 / 0; let c = 0.81; function f(e) { let i; const o = t.length; const a = $c(t, Xc, Gc).visitAfter(l); for (r = e, i = 0; i < o; ++i)n = t[i], a.visit(h); } function s() { if (t) { let n; let e; const r = t.length; for (i = new Array(r), n = 0; n < r; ++n)e = t[n], i[e.index] = +o(e, n, t); } } function l(t) { let n; let e; let r; let o; let a; let u = 0; let c = 0; if (t.length) { for (r = o = a = 0; a < 4; ++a)(n = t[a]) && (e = Math.abs(n.value)) && (u += n.value, c += e, r += e * n.x, o += e * n.y); t.x = r / c, t.y = o / c; } else { (n = t).x = n.data.x, n.y = n.data.y; do { u += i[n.data.index]; } while (n = n.next); }t.value = u; } function h(t, o, f, s) { if (!t.value) return !0; let l = t.x - n.x; let h = t.y - n.y; let d = s - o; let p = l * l + h * h; if (d * d / c < p) return p < u && (l === 0 && (p += (l = Uc(e)) * l), h === 0 && (p += (h = Uc(e)) * h), p < a && (p = Math.sqrt(a * p)), n.vx += l * t.value * r / p, n.vy += h * t.value * r / p), !0; if (!(t.length || p >= u)) { (t.data !== n || t.next) && (l === 0 && (p += (l = Uc(e)) * l), h === 0 && (p += (h = Uc(e)) * h), p < a && (p = Math.sqrt(a * p))); do { t.data !== n && (d = i[t.data.index] * r / p, n.vx += l * d, n.vy += h * d); } while (t = t.next); } } return f.initialize = function (n, r) { t = n, e = r, s(); }, f.strength = function (t) { return arguments.length ? (o = typeof t === 'function' ? t : qc(+t), s(), f) : o; }, f.distanceMin = function (t) { return arguments.length ? (a = t * t, f) : Math.sqrt(a); }, f.distanceMax = function (t) { return arguments.length ? (u = t * t, f) : Math.sqrt(u); }, f.theta = function (t) { return arguments.length ? (c = t * t, f) : Math.sqrt(c); }, f; }, t.forceRadial = function (t, n, e) { let r; let i; let o; let a = qc(0.1); function u(t) { for (let a = 0, u = r.length; a < u; ++a) { const c = r[a]; const f = c.x - n || 1e-6; const s = c.y - e || 1e-6; const l = Math.sqrt(f * f + s * s); const h = (o[a] - l) * i[a] * t / l; c.vx += f * h, c.vy += s * h; } } function c() { if (r) { let n; const e = r.length; for (i = new Array(e), o = new Array(e), n = 0; n < e; ++n)o[n] = +t(r[n], n, r), i[n] = isNaN(o[n]) ? 0 : +a(r[n], n, r); } } return typeof t !== 'function' && (t = qc(+t)), n == null && (n = 0), e == null && (e = 0), u.initialize = function (t) { r = t, c(); }, u.strength = function (t) { return arguments.length ? (a = typeof t === 'function' ? t : qc(+t), c(), u) : a; }, u.radius = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : qc(+n), c(), u) : t; }, u.x = function (t) { return arguments.length ? (n = +t, u) : n; }, u.y = function (t) { return arguments.length ? (e = +t, u) : e; }, u; }, t.forceSimulation = function (t) {
    let n; let e = 1; let r = 0.001; let i = 1 - r ** (1 / 300); let o = 0; let a = 0.6; const u = new Map(); const c = Ni(l); const f = $t('tick', 'end'); let s = (function () { let t = 1; return () => (t = (Lc * t + jc) % Hc) / Hc; }()); function l() { h(), f.call('tick', n), e < r && (c.stop(), f.call('end', n)); } function h(r) { let c; let f; const s = t.length; void 0 === r && (r = 1); for (let l = 0; l < r; ++l) for (e += (o - e) * i, u.forEach(((t) => { t(e); })), c = 0; c < s; ++c)(f = t[c]).fx == null ? f.x += f.vx *= a : (f.x = f.fx, f.vx = 0), f.fy == null ? f.y += f.vy *= a : (f.y = f.fy, f.vy = 0); return n; } function d() { for (var n, e = 0, r = t.length; e < r; ++e) { if ((n = t[e]).index = e, n.fx != null && (n.x = n.fx), n.fy != null && (n.y = n.fy), isNaN(n.x) || isNaN(n.y)) { const i = 10 * Math.sqrt(0.5 + e); const o = e * Vc; n.x = i * Math.cos(o), n.y = i * Math.sin(o); }(isNaN(n.vx) || isNaN(n.vy)) && (n.vx = n.vy = 0); } } function p(n) { return n.initialize && n.initialize(t, s), n; } return t == null && (t = []), d(), n = {
      tick: h, restart() { return c.restart(l), n; }, stop() { return c.stop(), n; }, nodes(e) { return arguments.length ? (t = e, d(), u.forEach(p), n) : t; }, alpha(t) { return arguments.length ? (e = +t, n) : e; }, alphaMin(t) { return arguments.length ? (r = +t, n) : r; }, alphaDecay(t) { return arguments.length ? (i = +t, n) : +i; }, alphaTarget(t) { return arguments.length ? (o = +t, n) : o; }, velocityDecay(t) { return arguments.length ? (a = 1 - t, n) : 1 - a; }, randomSource(t) { return arguments.length ? (s = t, u.forEach(p), n) : s; }, force(t, e) { return arguments.length > 1 ? (e == null ? u.delete(t) : u.set(t, p(e)), n) : u.get(t); }, find(n, e, r) { let i; let o; let a; let u; let c; let f = 0; const s = t.length; for (r == null ? r = 1 / 0 : r *= r, f = 0; f < s; ++f)(a = (i = n - (u = t[f]).x) * i + (o = e - u.y) * o) < r && (c = u, r = a); return c; }, on(t, e) { return arguments.length > 1 ? (f.on(t, e), n) : f.on(t); },
    };
  }, t.forceX = function (t) { let n; let e; let r; let i = qc(0.1); function o(t) { for (var i, o = 0, a = n.length; o < a; ++o)(i = n[o]).vx += (r[o] - i.x) * e[o] * t; } function a() { if (n) { let o; const a = n.length; for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o)e[o] = isNaN(r[o] = +t(n[o], o, n)) ? 0 : +i(n[o], o, n); } } return typeof t !== 'function' && (t = qc(t == null ? 0 : +t)), o.initialize = function (t) { n = t, a(); }, o.strength = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : qc(+t), a(), o) : i; }, o.x = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : qc(+n), a(), o) : t; }, o; }, t.forceY = function (t) { let n; let e; let r; let i = qc(0.1); function o(t) { for (var i, o = 0, a = n.length; o < a; ++o)(i = n[o]).vy += (r[o] - i.y) * e[o] * t; } function a() { if (n) { let o; const a = n.length; for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o)e[o] = isNaN(r[o] = +t(n[o], o, n)) ? 0 : +i(n[o], o, n); } } return typeof t !== 'function' && (t = qc(t == null ? 0 : +t)), o.initialize = function (t) { n = t, a(); }, o.strength = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : qc(+t), a(), o) : i; }, o.y = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : qc(+n), a(), o) : t; }, o; }, t.formatDefaultLocale = ff, t.formatLocale = cf, t.formatSpecifier = Jc, t.fsum = function (t, n) { const e = new T(); if (void 0 === n) for (let n of t)(n = +n) && e.add(n); else { let r = -1; for (let i of t)(i = +n(i, ++r, t)) && e.add(i); } return +e; }, t.geoAlbers = xd, t.geoAlbersUsa = function () {
    let t; let n; let e; let r; let i; let o; const a = xd(); const u = md().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]); const c = md().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]); const f = { point(t, n) { o = [t, n]; } }; function s(t) { const n = t[0]; const a = t[1]; return o = null, e.point(n, a), o || (r.point(n, a), o) || (i.point(n, a), o); } function l() { return t = n = null, s; } return s.invert = function (t) { const n = a.scale(); const e = a.translate(); const r = (t[0] - e[0]) / n; const i = (t[1] - e[1]) / n; return (i >= 0.12 && i < 0.234 && r >= -0.425 && r < -0.214 ? u : i >= 0.166 && i < 0.234 && r >= -0.214 && r < -0.115 ? c : a).invert(t); }, s.stream = function (e) {
      return t && n === e ? t : (r = [a.stream(n = e), u.stream(e), c.stream(e)], i = r.length, t = {
        point(t, n) { for (let e = -1; ++e < i;)r[e].point(t, n); }, sphere() { for (let t = -1; ++t < i;)r[t].sphere(); }, lineStart() { for (let t = -1; ++t < i;)r[t].lineStart(); }, lineEnd() { for (let t = -1; ++t < i;)r[t].lineEnd(); }, polygonStart() { for (let t = -1; ++t < i;)r[t].polygonStart(); }, polygonEnd() { for (let t = -1; ++t < i;)r[t].polygonEnd(); },
      }); let r; let i;
    }, s.precision = function (t) { return arguments.length ? (a.precision(t), u.precision(t), c.precision(t), l()) : a.precision(); }, s.scale = function (t) { return arguments.length ? (a.scale(t), u.scale(0.35 * t), c.scale(t), s.translate(a.translate())) : a.scale(); }, s.translate = function (t) { if (!arguments.length) return a.translate(); const n = a.scale(); const o = +t[0]; const s = +t[1]; return e = a.translate(t).clipExtent([[o - 0.455 * n, s - 0.238 * n], [o + 0.455 * n, s + 0.238 * n]]).stream(f), r = u.translate([o - 0.307 * n, s + 0.201 * n]).clipExtent([[o - 0.425 * n + df, s + 0.12 * n + df], [o - 0.214 * n - df, s + 0.234 * n - df]]).stream(f), i = c.translate([o - 0.205 * n, s + 0.212 * n]).clipExtent([[o - 0.214 * n + df, s + 0.166 * n + df], [o - 0.115 * n - df, s + 0.234 * n - df]]).stream(f), l(); }, s.fitExtent = function (t, n) { return ud(s, t, n); }, s.fitSize = function (t, n) { return cd(s, t, n); }, s.fitWidth = function (t, n) { return fd(s, t, n); }, s.fitHeight = function (t, n) { return sd(s, t, n); }, s.scale(1070);
  }, t.geoArea = function (t) { return us = new T(), Lf(t, cs), 2 * us; }, t.geoAzimuthalEqualArea = function () { return yd(Td).scale(124.75).clipAngle(179.999); }, t.geoAzimuthalEqualAreaRaw = Td, t.geoAzimuthalEquidistant = function () { return yd(Ad).scale(79.4188).clipAngle(179.999); }, t.geoAzimuthalEquidistantRaw = Ad, t.geoBounds = function (t) { let n; let e; let r; let i; let o; let a; let u; if (Qf = Kf = -(Wf = Zf = 1 / 0), is = [], Lf(t, Fs), e = is.length) { for (is.sort(Hs), n = 1, o = [r = is[0]]; n < e; ++n)Xs(r, (i = is[n])[0]) || Xs(r, i[1]) ? (js(r[0], i[1]) > js(r[0], r[1]) && (r[1] = i[1]), js(i[0], r[1]) > js(r[0], r[1]) && (r[0] = i[0])) : o.push(r = i); for (a = -1 / 0, n = 0, r = o[e = o.length - 1]; n <= e; r = i, ++n)i = o[n], (u = js(r[1], i[0])) > a && (a = u, Wf = i[0], Kf = r[1]); } return is = os = null, Wf === 1 / 0 || Zf === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Wf, Zf], [Kf, Qf]]; }, t.geoCentroid = function (t) { ms = xs = ws = Ms = Ts = As = Ss = Es = 0, Ns = new T(), ks = new T(), Cs = new T(), Lf(t, Gs); let n = +Ns; let e = +ks; let r = +Cs; let i = Ef(n, e, r); return i < pf && (n = As, e = Ss, r = Es, xs < df && (n = ws, e = Ms, r = Ts), (i = Ef(n, e, r)) < pf) ? [NaN, NaN] : [Mf(e, n) * bf, Rf(r / i) * bf]; }, t.geoCircle = function () { let t; let n; let e = il([0, 0]); let r = il(90); let i = il(2); const o = { point(e, r) { t.push(e = n(e, r)), e[0] *= bf, e[1] *= bf; } }; function a() { let a = e.apply(this, arguments); const u = r.apply(this, arguments) * mf; const c = i.apply(this, arguments) * mf; return t = [], n = ul(-a[0] * mf, -a[1] * mf, 0).invert, hl(o, u, c, 1), a = { type: 'Polygon', coordinates: [t] }, t = n = null, a; } return a.center = function (t) { return arguments.length ? (e = typeof t === 'function' ? t : il([+t[0], +t[1]]), a) : e; }, a.radius = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : il(+t), a) : r; }, a.precision = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : il(+t), a) : i; }, a; }, t.geoClipAntimeridian = Tl, t.geoClipCircle = Al, t.geoClipExtent = function () { let t; let n; let e; let r = 0; let i = 0; let o = 960; let a = 500; return e = { stream(e) { return t && n === e ? t : t = zl(r, i, o, a)(n = e); }, extent(u) { return arguments.length ? (r = +u[0][0], i = +u[0][1], o = +u[1][0], a = +u[1][1], t = n = null, e) : [[r, i], [o, a]]; } }; }, t.geoClipRectangle = zl, t.geoConicConformal = function () { return _d(kd).scale(109.5).parallels([30, 30]); }, t.geoConicConformalRaw = kd, t.geoConicEqualArea = md, t.geoConicEqualAreaRaw = bd, t.geoConicEquidistant = function () { return _d(Pd).scale(131.154).center([0, 13.9389]); }, t.geoConicEquidistantRaw = Pd, t.geoContains = function (t, n) { return (t && Bl.hasOwnProperty(t.type) ? Bl[t.type] : Ll)(t, n); }, t.geoDistance = Ol, t.geoEqualEarth = function () { return yd(qd).scale(177.158); }, t.geoEqualEarthRaw = qd, t.geoEquirectangular = function () { return yd(Cd).scale(152.63); }, t.geoEquirectangularRaw = Cd, t.geoGnomonic = function () { return yd(Ud).scale(144.049).clipAngle(60); }, t.geoGnomonicRaw = Ud, t.geoGraticule = Kl, t.geoGraticule10 = function () { return Kl()(); }, t.geoIdentity = function () { let t; let n; let e; let r; let i; let o; let a; let u = 1; let c = 0; let f = 0; let s = 1; let l = 1; let h = 0; let d = null; let p = 1; let g = 1; const y = id({ point(t, n) { const e = b([t, n]); this.stream.point(e[0], e[1]); } }); let v = eh; function _() { return p = u * s, g = u * l, o = a = null, b; } function b(e) { let r = e[0] * p; let i = e[1] * g; if (h) { const o = i * t - r * n; r = r * t + i * n, i = o; } return [r + c, i + f]; } return b.invert = function (e) { let r = e[0] - c; let i = e[1] - f; if (h) { const o = i * t + r * n; r = r * t - i * n, i = o; } return [r / p, i / g]; }, b.stream = function (t) { return o && a === t ? o : o = y(v(a = t)); }, b.postclip = function (t) { return arguments.length ? (v = t, d = e = r = i = null, _()) : v; }, b.clipExtent = function (t) { return arguments.length ? (v = t == null ? (d = e = r = i = null, eh) : zl(d = +t[0][0], e = +t[0][1], r = +t[1][0], i = +t[1][1]), _()) : d == null ? null : [[d, e], [r, i]]; }, b.scale = function (t) { return arguments.length ? (u = +t, _()) : u; }, b.translate = function (t) { return arguments.length ? (c = +t[0], f = +t[1], _()) : [c, f]; }, b.angle = function (e) { return arguments.length ? (n = Cf(h = e % 360 * mf), t = Tf(h), _()) : h * bf; }, b.reflectX = function (t) { return arguments.length ? (s = t ? -1 : 1, _()) : s < 0; }, b.reflectY = function (t) { return arguments.length ? (l = t ? -1 : 1, _()) : l < 0; }, b.fitExtent = function (t, n) { return ud(b, t, n); }, b.fitSize = function (t, n) { return cd(b, t, n); }, b.fitWidth = function (t, n) { return fd(b, t, n); }, b.fitHeight = function (t, n) { return sd(b, t, n); }, b; }, t.geoInterpolate = function (t, n) { const e = t[0] * mf; const r = t[1] * mf; const i = n[0] * mf; const o = n[1] * mf; const a = Tf(r); const u = Cf(r); const c = Tf(o); const f = Cf(o); const s = a * Tf(e); const l = a * Cf(e); const h = c * Tf(i); const d = c * Cf(i); const p = 2 * Rf(zf(Ff(o - r) + a * c * Ff(i - e))); const g = Cf(p); const y = p ? function (t) { const n = Cf(t *= p) / g; const e = Cf(p - t) / g; const r = e * s + n * h; const i = e * l + n * d; const o = e * u + n * f; return [Mf(i, r) * bf, Mf(o, zf(r * r + i * i)) * bf]; } : function () { return [e * bf, r * bf]; }; return y.distance = p, y; }, t.geoLength = ql, t.geoMercator = function () { return Ed(Sd).scale(961 / _f); }, t.geoMercatorRaw = Sd, t.geoNaturalEarth1 = function () { return yd(Id).scale(175.295); }, t.geoNaturalEarth1Raw = Id, t.geoOrthographic = function () { return yd(Od).scale(249.5).clipAngle(90 + df); }, t.geoOrthographicRaw = Od, t.geoPath = function (t, n) { let e; let r; let i = 3; let o = 4.5; function a(t) { return t && (typeof o === 'function' && r.pointRadius(+o.apply(this, arguments)), Lf(t, e(r))), r.result(); } return a.area = function (t) { return Lf(t, e(sh)), sh.result(); }, a.measure = function (t) { return Lf(t, e(Kh)), Kh.result(); }, a.bounds = function (t) { return Lf(t, e(mh)), mh.result(); }, a.centroid = function (t) { return Lf(t, e(Oh)), Oh.result(); }, a.projection = function (n) { return arguments.length ? (e = n == null ? (t = null, eh) : (t = n).stream, a) : t; }, a.context = function (t) { return arguments.length ? (r = t == null ? (n = null, new ed(i)) : new Bh(n = t), typeof o !== 'function' && r.pointRadius(o), a) : n; }, a.pointRadius = function (t) { return arguments.length ? (o = typeof t === 'function' ? t : (r.pointRadius(+t), +t), a) : o; }, a.digits = function (t) { if (!arguments.length) return i; if (t == null)i = null; else { const n = Math.floor(t); if (!(n >= 0)) throw new RangeError(`invalid digits: ${t}`); i = n; } return n === null && (r = new ed(i)), a; }, a.projection(t).digits(i).context(n); }, t.geoProjection = yd, t.geoProjectionMutator = vd, t.geoRotation = ll, t.geoStereographic = function () { return yd(Bd).scale(250).clipAngle(142); }, t.geoStereographicRaw = Bd, t.geoStream = Lf, t.geoTransform = function (t) { return { stream: id(t) }; }, t.geoTransverseMercator = function () { const t = Ed(Yd); const n = t.center; const e = t.rotate; return t.center = function (t) { return arguments.length ? n([-t[1], t[0]]) : [(t = n())[1], -t[0]]; }, t.rotate = function (t) { return arguments.length ? e([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = e())[0], t[1], t[2] - 90]; }, e([0, 0, 90]).scale(159.155); }, t.geoTransverseMercatorRaw = Yd, t.gray = function (t, n) { return new ur(t, 0, 0, n == null ? 1 : n); }, t.greatest = ot, t.greatestIndex = function (t, e = n) { if (e.length === 1) return tt(t, e); let r; let i = -1; let o = -1; for (const n of t)++o, (i < 0 ? e(n, n) === 0 : e(n, r) > 0) && (r = n, i = o); return i; }, t.group = C, t.groupSort = function (t, e, r) { return (e.length !== 2 ? U($(t, e, r), (([t, e], [r, i]) => n(e, i) || n(t, r))) : U(C(t, r), (([t, r], [i, o]) => e(r, o) || n(t, i)))).map((([t]) => t)); }, t.groups = P, t.hcl = dr, t.hierarchy = Gd, t.histogram = Q, t.hsl = He, t.html = Ec, t.image = function (t, n) { return new Promise(((e, r) => { const i = new Image(); for (const o in n)i[o] = n[o]; i.onerror = r, i.onload = function () { e(i); }, i.src = t; })); }, t.index = function (t, ...n) { return F(t, k, R, n); }, t.indexes = function (t, ...n) { return F(t, Array.from, R, n); }, t.interpolate = Gr, t.interpolateArray = function (t, n) { return (Ir(n) ? Ur : Or)(t, n); }, t.interpolateBasis = Er, t.interpolateBasisClosed = Nr, t.interpolateBlues = Gb, t.interpolateBrBG = ob, t.interpolateBuGn = Mb, t.interpolateBuPu = Ab, t.interpolateCividis = function (t) { return t = Math.max(0, Math.min(1, t)), `rgb(${Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - 2710.57 * t)))))))}, ${Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - 67.37 * t)))))))}, ${Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - 2475.67 * t)))))))})`; }, t.interpolateCool = am, t.interpolateCubehelix = li, t.interpolateCubehelixDefault = im, t.interpolateCubehelixLong = hi, t.interpolateDate = Br, t.interpolateDiscrete = function (t) { const n = t.length; return function (e) { return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))]; }; }, t.interpolateGnBu = Eb, t.interpolateGreens = Wb, t.interpolateGreys = Kb, t.interpolateHcl = ci, t.interpolateHclLong = fi, t.interpolateHsl = oi, t.interpolateHslLong = ai, t.interpolateHue = function (t, n) { const e = Pr(+t, +n); return function (t) { const n = e(t); return n - 360 * Math.floor(n / 360); }; }, t.interpolateInferno = pm, t.interpolateLab = function (t, n) { const e = $r((t = ar(t)).l, (n = ar(n)).l); const r = $r(t.a, n.a); const i = $r(t.b, n.b); const o = $r(t.opacity, n.opacity); return function (n) { return t.l = e(n), t.a = r(n), t.b = i(n), t.opacity = o(n), `${t}`; }; }, t.interpolateMagma = dm, t.interpolateNumber = Yr, t.interpolateNumberArray = Ur, t.interpolateObject = Lr, t.interpolateOrRd = kb, t.interpolateOranges = rm, t.interpolatePRGn = ub, t.interpolatePiYG = fb, t.interpolatePlasma = gm, t.interpolatePuBu = $b, t.interpolatePuBuGn = Pb, t.interpolatePuOr = lb, t.interpolatePuRd = Rb, t.interpolatePurples = Jb, t.interpolateRainbow = function (t) { (t < 0 || t > 1) && (t -= Math.floor(t)); const n = Math.abs(t - 0.5); return um.h = 360 * t - 100, um.s = 1.5 - 1.5 * n, um.l = 0.8 - 0.9 * n, `${um}`; }, t.interpolateRdBu = db, t.interpolateRdGy = gb, t.interpolateRdPu = qb, t.interpolateRdYlBu = vb, t.interpolateRdYlGn = bb, t.interpolateReds = nm, t.interpolateRgb = Dr, t.interpolateRgbBasis = Fr, t.interpolateRgbBasisClosed = qr, t.interpolateRound = Vr, t.interpolateSinebow = function (t) { let n; return t = (0.5 - t) * Math.PI, cm.r = 255 * (n = Math.sin(t)) * n, cm.g = 255 * (n = Math.sin(t + fm)) * n, cm.b = 255 * (n = Math.sin(t + sm)) * n, `${cm}`; }, t.interpolateSpectral = xb, t.interpolateString = Xr, t.interpolateTransformCss = ti, t.interpolateTransformSvg = ni, t.interpolateTurbo = function (t) { return t = Math.max(0, Math.min(1, t)), `rgb(${Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - 14825.05 * t)))))))}, ${Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + 707.56 * t)))))))}, ${Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - 6838.66 * t)))))))})`; }, t.interpolateViridis = hm, t.interpolateWarm = om, t.interpolateYlGn = Bb, t.interpolateYlGnBu = Ib, t.interpolateYlOrBr = Lb, t.interpolateYlOrRd = Hb, t.interpolateZoom = ri, t.interrupt = Gi, t.intersection = function (t, ...n) { t = new InternSet(t), n = n.map(vt); t:for (const e of t) for (const r of n) if (!r.has(e)) { t.delete(e); continue t; } return t; }, t.interval = function (t, n, e) {
    const r = new Ei(); let
      i = n; return n == null ? (r.restart(t, n, e), r) : (r._restart = r.restart, r.restart = function (t, n, e) { n = +n, e = e == null ? Ai() : +e, r._restart((function o(a) { a += i, r._restart(o, i += n, e), t(a); }), n, e); }, r.restart(t, n, e), r);
  }, t.isoFormat = D_, t.isoParse = F_, t.json = function (t, n) { return fetch(t, n).then(Tc); }, t.lab = ar, t.lch = function (t, n, e, r) { return arguments.length === 1 ? hr(t) : new pr(e, n, t, r == null ? 1 : r); }, t.least = function (t, e = n) { let r; let i = !1; if (e.length === 1) { let o; for (const a of t) { const t = e(a); (i ? n(t, o) < 0 : n(t, t) === 0) && (r = a, o = t, i = !0); } } else for (const n of t)(i ? e(n, r) < 0 : e(n, n) === 0) && (r = n, i = !0); return r; }, t.leastIndex = ht, t.line = Ym, t.lineRadial = Zm, t.link = ax, t.linkHorizontal = function () { return ax(nx); }, t.linkRadial = function () { const t = ax(rx); return t.angle = t.x, delete t.x, t.radius = t.y, delete t.y, t; }, t.linkVertical = function () { return ax(ex); }, t.local = Qn, t.map = function (t, n) { if (typeof t[Symbol.iterator] !== 'function') throw new TypeError('values is not iterable'); if (typeof n !== 'function') throw new TypeError('mapper is not a function'); return Array.from(t, ((e, r) => n(e, r, t))); }, t.matcher = Vt, t.max = J, t.maxIndex = tt, t.mean = function (t, n) { let e = 0; let r = 0; if (void 0 === n) for (let n of t)n != null && (n = +n) >= n && (++e, r += n); else { let i = -1; for (let o of t)(o = n(o, ++i, t)) != null && (o = +o) >= o && (++e, r += o); } if (e) return r / e; }, t.median = function (t, n) { return at(t, 0.5, n); }, t.medianIndex = function (t, n) { return ct(t, 0.5, n); }, t.merge = ft, t.min = nt, t.minIndex = et, t.mode = function (t, n) { const e = new InternMap(); if (void 0 === n) for (const n of t)n != null && n >= n && e.set(n, (e.get(n) || 0) + 1); else { let r = -1; for (let i of t)(i = n(i, ++r, t)) != null && i >= i && e.set(i, (e.get(i) || 0) + 1); } let r; let i = 0; for (const [t, n] of e)n > i && (i = n, r = t); return r; }, t.namespace = It, t.namespaces = Ut, t.nice = Z, t.now = Ai, t.pack = function () { let t = null; let n = 1; let e = 1; let r = np; function i(i) { const o = ap(); return i.x = n / 2, i.y = e / 2, t ? i.eachBefore(xp(t)).eachAfter(wp(r, 0.5, o)).eachBefore(Mp(1)) : i.eachBefore(xp(mp)).eachAfter(wp(np, 1, o)).eachAfter(wp(r, i.r / Math.min(n, e), o)).eachBefore(Mp(Math.min(n, e) / (2 * i.r))), i; } return i.radius = function (n) { return arguments.length ? (t = Jd(n), i) : t; }, i.size = function (t) { return arguments.length ? (n = +t[0], e = +t[1], i) : [n, e]; }, i.padding = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : ep(+t), i) : r; }, i; }, t.packEnclose = function (t) { return up(t, ap()); }, t.packSiblings = function (t) { return bp(t, ap()), t; }, t.pairs = function (t, n = st) { const e = []; let r; let i = !1; for (const o of t)i && e.push(n(r, o)), r = o, i = !0; return e; }, t.partition = function () { let t = 1; let n = 1; let e = 0; let r = !1; function i(i) { const o = i.height + 1; return i.x0 = i.y0 = e, i.x1 = t, i.y1 = n / o, i.eachBefore(function (t, n) { return function (r) { r.children && Ap(r, r.x0, t * (r.depth + 1) / n, r.x1, t * (r.depth + 2) / n); let i = r.x0; let o = r.y0; let a = r.x1 - e; let u = r.y1 - e; a < i && (i = a = (i + a) / 2), u < o && (o = u = (o + u) / 2), r.x0 = i, r.y0 = o, r.x1 = a, r.y1 = u; }; }(n, o)), r && i.eachBefore(Tp), i; } return i.round = function (t) { return arguments.length ? (r = !!t, i) : r; }, i.size = function (e) { return arguments.length ? (t = +e[0], n = +e[1], i) : [t, n]; }, i.padding = function (t) { return arguments.length ? (e = +t, i) : e; }, i; }, t.path = Ia, t.pathRound = function (t = 3) { return new Ua(+t); }, t.permute = q, t.pie = function () {
    let t = Hm; let n = jm; let e = null; let r = ym(0); let i = ym(Em); let o = ym(0); function a(a) {
      let u; let c; let f; let s; let l; const h = (a = qm(a)).length; let d = 0; const p = new Array(h); const g = new Array(h); let y = +r.apply(this, arguments); const v = Math.min(Em, Math.max(-Em, i.apply(this, arguments) - y)); const _ = Math.min(Math.abs(v) / h, o.apply(this, arguments)); const b = _ * (v < 0 ? -1 : 1); for (u = 0; u < h; ++u)(l = g[p[u] = u] = +t(a[u], u, a)) > 0 && (d += l); for (n != null ? p.sort(((t, e) => n(g[t], g[e]))) : e != null && p.sort(((t, n) => e(a[t], a[n]))), u = 0, f = d ? (v - h * b) / d : 0; u < h; ++u, y = s) {
        c = p[u], s = y + ((l = g[c]) > 0 ? l * f : 0) + b, g[c] = {
          data: a[c], index: u, value: l, startAngle: y, endAngle: s, padAngle: _,
        };
      } return g;
    } return a.value = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : ym(+n), a) : t; }, a.sortValues = function (t) { return arguments.length ? (n = t, e = null, a) : n; }, a.sort = function (t) { return arguments.length ? (e = t, n = null, a) : e; }, a.startAngle = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : ym(+t), a) : r; }, a.endAngle = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : ym(+t), a) : i; }, a.padAngle = function (t) { return arguments.length ? (o = typeof t === 'function' ? t : ym(+t), a) : o; }, a;
  }, t.piecewise = di, t.pointRadial = Qm, t.pointer = ne, t.pointers = function (t, n) { return t.target && (t = te(t), void 0 === n && (n = t.currentTarget), t = t.touches || [t]), Array.from(t, ((t) => ne(t, n))); }, t.polygonArea = function (t) { for (var n, e = -1, r = t.length, i = t[r - 1], o = 0; ++e < r;)n = i, i = t[e], o += n[1] * i[0] - n[0] * i[1]; return o / 2; }, t.polygonCentroid = function (t) { for (var n, e, r = -1, i = t.length, o = 0, a = 0, u = t[i - 1], c = 0; ++r < i;)n = u, u = t[r], c += e = n[0] * u[1] - u[0] * n[1], o += (n[0] + u[0]) * e, a += (n[1] + u[1]) * e; return [o / (c *= 3), a / c]; }, t.polygonContains = function (t, n) { for (var e, r, i = t.length, o = t[i - 1], a = n[0], u = n[1], c = o[0], f = o[1], s = !1, l = 0; l < i; ++l)e = (o = t[l])[0], (r = o[1]) > u != f > u && a < (c - e) * (u - r) / (f - r) + e && (s = !s), c = e, f = r; return s; }, t.polygonHull = function (t) { if ((e = t.length) < 3) return null; let n; let e; const r = new Array(e); const i = new Array(e); for (n = 0; n < e; ++n)r[n] = [+t[n][0], +t[n][1], n]; for (r.sort(Hp), n = 0; n < e; ++n)i[n] = [r[n][0], -r[n][1]]; const o = Xp(r); const a = Xp(i); const u = a[0] === o[0]; const c = a[a.length - 1] === o[o.length - 1]; const f = []; for (n = o.length - 1; n >= 0; --n)f.push(t[r[o[n]][2]]); for (n = +u; n < a.length - c; ++n)f.push(t[r[a[n]][2]]); return f; }, t.polygonLength = function (t) { for (var n, e, r = -1, i = t.length, o = t[i - 1], a = o[0], u = o[1], c = 0; ++r < i;)n = a, e = u, n -= a = (o = t[r])[0], e -= u = o[1], c += Math.hypot(n, e); return c; }, t.precisionFixed = sf, t.precisionPrefix = lf, t.precisionRound = hf, t.quadtree = $c, t.quantile = at, t.quantileIndex = ct, t.quantileSorted = ut, t.quantize = function (t, n) { for (var e = new Array(n), r = 0; r < n; ++r)e[r] = t(r / (n - 1)); return e; }, t.quickselect = rt, t.radialArea = Km, t.radialLine = Zm, t.randomBates = Jp, t.randomBernoulli = eg, t.randomBeta = og, t.randomBinomial = ag, t.randomCauchy = cg, t.randomExponential = tg, t.randomGamma = ig, t.randomGeometric = rg, t.randomInt = Wp, t.randomIrwinHall = Qp, t.randomLcg = function (t = Math.random()) { let n = 0 | (t >= 0 && t < 1 ? t / lg : Math.abs(t)); return () => (n = 1664525 * n + 1013904223 | 0, lg * (n >>> 0)); }, t.randomLogNormal = Kp, t.randomLogistic = fg, t.randomNormal = Zp, t.randomPareto = ng, t.randomPoisson = sg, t.randomUniform = Vp, t.randomWeibull = ug, t.range = lt, t.rank = function (t, e = n) { if (typeof t[Symbol.iterator] !== 'function') throw new TypeError('values is not iterable'); let r = Array.from(t); const i = new Float64Array(r.length); e.length !== 2 && (r = r.map(e), e = n); const o = (t, n) => e(r[t], r[n]); let a; let u; return (t = Uint32Array.from(r, ((t, n) => n))).sort(e === n ? (t, n) => O(r[t], r[n]) : I(o)), t.forEach(((t, n) => { const e = o(t, void 0 === a ? t : a); e >= 0 ? ((void 0 === a || e > 0) && (a = t, u = n), i[t] = u) : i[t] = NaN; })), i; }, t.reduce = function (t, n, e) { if (typeof n !== 'function') throw new TypeError('reducer is not a function'); const r = t[Symbol.iterator](); let i; let o; let a = -1; if (arguments.length < 3) { if (({ done: i, value: e } = r.next()), i) return; ++a; } for (;({ done: i, value: o } = r.next()), !i;)e = n(e, o, ++a, t); return e; }, t.reverse = function (t) { if (typeof t[Symbol.iterator] !== 'function') throw new TypeError('values is not iterable'); return Array.from(t).reverse(); }, t.rgb = Fe, t.ribbon = function () { return Wa(); }, t.ribbonArrow = function () { return Wa(Va); }, t.rollup = $, t.rollups = D, t.scaleBand = yg, t.scaleDiverging = function t() { const n = Ng(L_()(mg)); return n.copy = function () { return B_(n, t()); }, dg.apply(n, arguments); }, t.scaleDivergingLog = function t() { const n = Fg(L_()).domain([0.1, 1, 10]); return n.copy = function () { return B_(n, t()).base(n.base()); }, dg.apply(n, arguments); }, t.scaleDivergingPow = j_, t.scaleDivergingSqrt = function () { return j_.apply(null, arguments).exponent(0.5); }, t.scaleDivergingSymlog = function t() { const n = Ig(L_()); return n.copy = function () { return B_(n, t()).constant(n.constant()); }, dg.apply(n, arguments); }, t.scaleIdentity = function t(n) { let e; function r(t) { return t == null || isNaN(t = +t) ? e : t; } return r.invert = r, r.domain = r.range = function (t) { return arguments.length ? (n = Array.from(t, _g), r) : n.slice(); }, r.unknown = function (t) { return arguments.length ? (e = t, r) : e; }, r.copy = function () { return t(n).unknown(e); }, n = arguments.length ? Array.from(n, _g) : [0, 1], Ng(r); }, t.scaleImplicit = pg, t.scaleLinear = function t() { const n = Sg(); return n.copy = function () { return Tg(n, t()); }, hg.apply(n, arguments), Ng(n); }, t.scaleLog = function t() { const n = Fg(Ag()).domain([1, 10]); return n.copy = () => Tg(n, t()).base(n.base()), hg.apply(n, arguments), n; }, t.scaleOrdinal = gg, t.scalePoint = function () { return vg(yg.apply(null, arguments).paddingInner(1)); }, t.scalePow = jg, t.scaleQuantile = function t() { let e; let r = []; let i = []; let o = []; function a() { let t = 0; const n = Math.max(1, i.length); for (o = new Array(n - 1); ++t < n;)o[t - 1] = ut(r, t / n); return u; } function u(t) { return t == null || isNaN(t = +t) ? e : i[s(o, t)]; } return u.invertExtent = function (t) { const n = i.indexOf(t); return n < 0 ? [NaN, NaN] : [n > 0 ? o[n - 1] : r[0], n < o.length ? o[n] : r[r.length - 1]]; }, u.domain = function (t) { if (!arguments.length) return r.slice(); r = []; for (let n of t)n == null || isNaN(n = +n) || r.push(n); return r.sort(n), a(); }, u.range = function (t) { return arguments.length ? (i = Array.from(t), a()) : i.slice(); }, u.unknown = function (t) { return arguments.length ? (e = t, u) : e; }, u.quantiles = function () { return o.slice(); }, u.copy = function () { return t().domain(r).range(i).unknown(e); }, hg.apply(u, arguments); }, t.scaleQuantize = function t() { let n; let e = 0; let r = 1; let i = 1; let o = [0.5]; let a = [0, 1]; function u(t) { return t != null && t <= t ? a[s(o, t, 0, i)] : n; } function c() { let t = -1; for (o = new Array(i); ++t < i;)o[t] = ((t + 1) * r - (t - i) * e) / (i + 1); return u; } return u.domain = function (t) { return arguments.length ? ([e, r] = t, e = +e, r = +r, c()) : [e, r]; }, u.range = function (t) { return arguments.length ? (i = (a = Array.from(t)).length - 1, c()) : a.slice(); }, u.invertExtent = function (t) { const n = a.indexOf(t); return n < 0 ? [NaN, NaN] : n < 1 ? [e, o[0]] : n >= i ? [o[i - 1], r] : [o[n - 1], o[n]]; }, u.unknown = function (t) { return arguments.length ? (n = t, u) : u; }, u.thresholds = function () { return o.slice(); }, u.copy = function () { return t().domain([e, r]).range(a).unknown(n); }, hg.apply(Ng(u), arguments); }, t.scaleRadial = function t() { let n; const e = Sg(); let r = [0, 1]; let i = !1; function o(t) { const r = (function (t) { return Math.sign(t) * Math.sqrt(Math.abs(t)); }(e(t))); return isNaN(r) ? n : i ? Math.round(r) : r; } return o.invert = function (t) { return e.invert(Hg(t)); }, o.domain = function (t) { return arguments.length ? (e.domain(t), o) : e.domain(); }, o.range = function (t) { return arguments.length ? (e.range((r = Array.from(t, _g)).map(Hg)), o) : r.slice(); }, o.rangeRound = function (t) { return o.range(t).round(!0); }, o.round = function (t) { return arguments.length ? (i = !!t, o) : i; }, o.clamp = function (t) { return arguments.length ? (e.clamp(t), o) : e.clamp(); }, o.unknown = function (t) { return arguments.length ? (n = t, o) : n; }, o.copy = function () { return t(e.domain(), r).round(i).clamp(e.clamp()).unknown(n); }, hg.apply(o, arguments), Ng(o); }, t.scaleSequential = function t() { const n = Ng(O_()(mg)); return n.copy = function () { return B_(n, t()); }, dg.apply(n, arguments); }, t.scaleSequentialLog = function t() { const n = Fg(O_()).domain([1, 10]); return n.copy = function () { return B_(n, t()).base(n.base()); }, dg.apply(n, arguments); }, t.scaleSequentialPow = Y_, t.scaleSequentialQuantile = function t() { let e = []; let r = mg; function i(t) { if (t != null && !isNaN(t = +t)) return r((s(e, t, 1) - 1) / (e.length - 1)); } return i.domain = function (t) { if (!arguments.length) return e.slice(); e = []; for (let n of t)n == null || isNaN(n = +n) || e.push(n); return e.sort(n), i; }, i.interpolator = function (t) { return arguments.length ? (r = t, i) : r; }, i.range = function () { return e.map(((t, n) => r(n / (e.length - 1)))); }, i.quantiles = function (t) { return Array.from({ length: t + 1 }, ((n, r) => at(e, r / t))); }, i.copy = function () { return t(r).domain(e); }, dg.apply(i, arguments); }, t.scaleSequentialSqrt = function () { return Y_.apply(null, arguments).exponent(0.5); }, t.scaleSequentialSymlog = function t() { const n = Ig(O_()); return n.copy = function () { return B_(n, t()).constant(n.constant()); }, dg.apply(n, arguments); }, t.scaleSqrt = function () { return jg.apply(null, arguments).exponent(0.5); }, t.scaleSymlog = function t() { const n = Ig(Ag()); return n.copy = function () { return Tg(n, t()).constant(n.constant()); }, hg.apply(n, arguments); }, t.scaleThreshold = function t() { let n; let e = [0.5]; let r = [0, 1]; let i = 1; function o(t) { return t != null && t <= t ? r[s(e, t, 0, i)] : n; } return o.domain = function (t) { return arguments.length ? (e = Array.from(t), i = Math.min(e.length, r.length - 1), o) : e.slice(); }, o.range = function (t) { return arguments.length ? (r = Array.from(t), i = Math.min(e.length, r.length - 1), o) : r.slice(); }, o.invertExtent = function (t) { const n = r.indexOf(t); return [e[n - 1], e[n]]; }, o.unknown = function (t) { return arguments.length ? (n = t, o) : n; }, o.copy = function () { return t().domain(e).range(r).unknown(n); }, hg.apply(o, arguments); }, t.scaleTime = function () { return hg.apply(I_(uv, cv, tv, Zy, xy, py, sy, ay, iy, t.timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments); }, t.scaleUtc = function () { return hg.apply(I_(ov, av, ev, Qy, Fy, yy, hy, cy, iy, t.utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments); }, t.scan = function (t, n) { const e = ht(t, n); return e < 0 ? void 0 : e; }, t.schemeAccent = G_, t.schemeBlues = Xb, t.schemeBrBG = ib, t.schemeBuGn = wb, t.schemeBuPu = Tb, t.schemeCategory10 = X_, t.schemeDark2 = V_, t.schemeGnBu = Sb, t.schemeGreens = Vb, t.schemeGreys = Zb, t.schemeObservable10 = W_, t.schemeOrRd = Nb, t.schemeOranges = em, t.schemePRGn = ab, t.schemePaired = Z_, t.schemePastel1 = K_, t.schemePastel2 = Q_, t.schemePiYG = cb, t.schemePuBu = zb, t.schemePuBuGn = Cb, t.schemePuOr = sb, t.schemePuRd = Db, t.schemePurples = Qb, t.schemeRdBu = hb, t.schemeRdGy = pb, t.schemeRdPu = Fb, t.schemeRdYlBu = yb, t.schemeRdYlGn = _b, t.schemeReds = tm, t.schemeSet1 = J_, t.schemeSet2 = tb, t.schemeSet3 = nb, t.schemeSpectral = mb, t.schemeTableau10 = eb, t.schemeYlGn = Ob, t.schemeYlGnBu = Ub, t.schemeYlOrBr = Yb, t.schemeYlOrRd = jb, t.select = Zn, t.selectAll = function (t) { return typeof t === 'string' ? new Vn([document.querySelectorAll(t)], [document.documentElement]) : new Vn([Ht(t)], Gn); }, t.selection = Wn, t.selector = jt, t.selectorAll = Gt, t.shuffle = dt, t.shuffler = pt, t.some = function (t, n) { if (typeof n !== 'function') throw new TypeError('test is not a function'); let e = -1; for (const r of t) if (n(r, ++e, t)) return !0; return !1; }, t.sort = U, t.stack = function () { let t = ym([]); let n = dw; let e = hw; let r = pw; function i(i) { let o; let a; const u = Array.from(t.apply(this, arguments), gw); const c = u.length; let f = -1; for (const t of i) for (o = 0, ++f; o < c; ++o)(u[o][f] = [0, +r(t, u[o].key, f, i)]).data = t; for (o = 0, a = qm(n(u)); o < c; ++o)u[a[o]].index = o; return e(u, a), u; } return i.keys = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : ym(Array.from(n)), i) : t; }, i.value = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : ym(+t), i) : r; }, i.order = function (t) { return arguments.length ? (n = t == null ? dw : typeof t === 'function' ? t : ym(Array.from(t)), i) : n; }, i.offset = function (t) { return arguments.length ? (e = t == null ? hw : t, i) : e; }, i; }, t.stackOffsetDiverging = function (t, n) { if ((u = t.length) > 0) for (var e, r, i, o, a, u, c = 0, f = t[n[0]].length; c < f; ++c) for (o = a = 0, e = 0; e < u; ++e)(i = (r = t[n[e]][c])[1] - r[0]) > 0 ? (r[0] = o, r[1] = o += i) : i < 0 ? (r[1] = a, r[0] = a += i) : (r[0] = 0, r[1] = i); }, t.stackOffsetExpand = function (t, n) { if ((r = t.length) > 0) { for (var e, r, i, o = 0, a = t[0].length; o < a; ++o) { for (i = e = 0; e < r; ++e)i += t[e][o][1] || 0; if (i) for (e = 0; e < r; ++e)t[e][o][1] /= i; }hw(t, n); } }, t.stackOffsetNone = hw, t.stackOffsetSilhouette = function (t, n) { if ((e = t.length) > 0) { for (var e, r = 0, i = t[n[0]], o = i.length; r < o; ++r) { for (var a = 0, u = 0; a < e; ++a)u += t[a][r][1] || 0; i[r][1] += i[r][0] = -u / 2; }hw(t, n); } }, t.stackOffsetWiggle = function (t, n) { if ((i = t.length) > 0 && (r = (e = t[n[0]]).length) > 0) { for (var e, r, i, o = 0, a = 1; a < r; ++a) { for (var u = 0, c = 0, f = 0; u < i; ++u) { for (var s = t[n[u]], l = s[a][1] || 0, h = (l - (s[a - 1][1] || 0)) / 2, d = 0; d < u; ++d) { const p = t[n[d]]; h += (p[a][1] || 0) - (p[a - 1][1] || 0); }c += l, f += h * l; }e[a - 1][1] += e[a - 1][0] = o, c && (o -= f / c); }e[a - 1][1] += e[a - 1][0] = o, hw(t, n); } }, t.stackOrderAppearance = yw, t.stackOrderAscending = _w, t.stackOrderDescending = function (t) { return _w(t).reverse(); }, t.stackOrderInsideOut = function (t) { let n; let e; const r = t.length; const i = t.map(bw); const o = yw(t); let a = 0; let u = 0; const c = []; const f = []; for (n = 0; n < r; ++n)e = o[n], a < u ? (a += i[e], c.push(e)) : (u += i[e], f.push(e)); return f.reverse().concat(c); }, t.stackOrderNone = dw, t.stackOrderReverse = function (t) { return dw(t).reverse(); }, t.stratify = function () { let t; let n = kp; let e = Cp; function r(r) { let i; let o; let a; let u; let c; let f; let s; let l; const h = Array.from(r); let d = n; let p = e; const g = new Map(); if (t != null) { const n = h.map(((n, e) => (function (t) { t = `${t}`; const n = t.length; zp(t, n - 1) && !zp(t, n - 2) && (t = t.slice(0, -1)); return t[0] === '/' ? t : `/${t}`; }(t(n, e, r))))); const e = n.map(Pp); const i = new Set(n).add(''); for (const t of e)i.has(t) || (i.add(t), n.push(t), e.push(Pp(t)), h.push(Np)); d = (t, e) => n[e], p = (t, n) => e[n]; } for (a = 0, i = h.length; a < i; ++a)o = h[a], f = h[a] = new Qd(o), (s = d(o, a, r)) != null && (s += '') && (l = f.id = s, g.set(l, g.has(l) ? Ep : f)), (s = p(o, a, r)) != null && (s += '') && (f.parent = s); for (a = 0; a < i; ++a) if (s = (f = h[a]).parent) { if (!(c = g.get(s))) throw new Error(`missing: ${s}`); if (c === Ep) throw new Error(`ambiguous: ${s}`); c.children ? c.children.push(f) : c.children = [f], f.parent = c; } else { if (u) throw new Error('multiple roots'); u = f; } if (!u) throw new Error('no root'); if (t != null) { for (;u.data === Np && u.children.length === 1;)u = u.children[0], --i; for (let t = h.length - 1; t >= 0 && (f = h[t]).data === Np; --t)f.data = null; } if (u.parent = Sp, u.eachBefore(((t) => { t.depth = t.parent.depth + 1, --i; })).eachBefore(Kd), u.parent = null, i > 0) throw new Error('cycle'); return u; } return r.id = function (t) { return arguments.length ? (n = Jd(t), r) : n; }, r.parentId = function (t) { return arguments.length ? (e = Jd(t), r) : e; }, r.path = function (n) { return arguments.length ? (t = Jd(n), r) : t; }, r; }, t.style = _n, t.subset = function (t, n) { return _t(n, t); }, t.sum = function (t, n) { let e = 0; if (void 0 === n) for (let n of t)(n = +n) && (e += n); else { let r = -1; for (let i of t)(i = +n(i, ++r, t)) && (e += i); } return e; }, t.superset = _t, t.svg = Nc, t.symbol = function (t, n) { let e = null; const r = km(i); function i() { let i; if (e || (e = i = r()), t.apply(this, arguments).draw(e, +n.apply(this, arguments)), i) return e = null, `${i}` || null; } return t = typeof t === 'function' ? t : ym(t || fx), n = typeof n === 'function' ? n : ym(void 0 === n ? 64 : +n), i.type = function (n) { return arguments.length ? (t = typeof n === 'function' ? n : ym(n), i) : t; }, i.size = function (t) { return arguments.length ? (n = typeof t === 'function' ? t : ym(+t), i) : n; }, i.context = function (t) { return arguments.length ? (e = t == null ? null : t, i) : e; }, i; }, t.symbolAsterisk = cx, t.symbolCircle = fx, t.symbolCross = sx, t.symbolDiamond = dx, t.symbolDiamond2 = px, t.symbolPlus = gx, t.symbolSquare = yx, t.symbolSquare2 = vx, t.symbolStar = xx, t.symbolTimes = Px, t.symbolTriangle = Mx, t.symbolTriangle2 = Ax, t.symbolWye = Cx, t.symbolX = Px, t.symbols = zx, t.symbolsFill = zx, t.symbolsStroke = $x, t.text = mc, t.thresholdFreedmanDiaconis = function (t, n, e) { const r = v(t); const i = at(t, 0.75) - at(t, 0.25); return r && i ? Math.ceil((e - n) / (2 * i * r ** (-1 / 3))) : 1; }, t.thresholdScott = function (t, n, e) { const r = v(t); const i = w(t); return r && i ? Math.ceil((e - n) * Math.cbrt(r) / (3.49 * i)) : 1; }, t.thresholdSturges = K, t.tickFormat = Eg, t.tickIncrement = V, t.tickStep = W, t.ticks = G, t.timeDay = py, t.timeDays = gy, t.timeFormatDefaultLocale = P_, t.timeFormatLocale = hv, t.timeFriday = Sy, t.timeFridays = $y, t.timeHour = sy, t.timeHours = ly, t.timeInterval = Vg, t.timeMillisecond = Wg, t.timeMilliseconds = Zg, t.timeMinute = ay, t.timeMinutes = uy, t.timeMonday = wy, t.timeMondays = ky, t.timeMonth = Zy, t.timeMonths = Ky, t.timeSaturday = Ey, t.timeSaturdays = Dy, t.timeSecond = iy, t.timeSeconds = oy, t.timeSunday = xy, t.timeSundays = Ny, t.timeThursday = Ay, t.timeThursdays = zy, t.timeTickInterval = cv, t.timeTicks = uv, t.timeTuesday = My, t.timeTuesdays = Cy, t.timeWednesday = Ty, t.timeWednesdays = Py, t.timeWeek = xy, t.timeWeeks = Ny, t.timeYear = tv, t.timeYears = nv, t.timeout = $i, t.timer = Ni, t.timerFlush = ki, t.transition = go, t.transpose = gt, t.tree = function () { let t = $p; let n = 1; let e = 1; let r = null; function i(i) { const c = (function (t) { for (var n, e, r, i, o, a = new Up(t, 0), u = [a]; n = u.pop();) if (r = n._.children) for (n.children = new Array(o = r.length), i = o - 1; i >= 0; --i)u.push(e = n.children[i] = new Up(r[i], i)), e.parent = n; return (a.parent = new Up(null, 0)).children = [a], a; }(i)); if (c.eachAfter(o), c.parent.m = -c.z, c.eachBefore(a), r)i.eachBefore(u); else { let f = i; let s = i; let l = i; i.eachBefore(((t) => { t.x < f.x && (f = t), t.x > s.x && (s = t), t.depth > l.depth && (l = t); })); const h = f === s ? 1 : t(f, s) / 2; const d = h - f.x; const p = n / (s.x + h + d); const g = e / (l.depth || 1); i.eachBefore(((t) => { t.x = (t.x + d) * p, t.y = t.depth * g; })); } return i; } function o(n) { const e = n.children; const r = n.parent.children; const i = n.i ? r[n.i - 1] : null; if (e) { !(function (t) { for (var n, e = 0, r = 0, i = t.children, o = i.length; --o >= 0;)(n = i[o]).z += e, n.m += e, e += n.s + (r += n.c); }(n)); const o = (e[0].z + e[e.length - 1].z) / 2; i ? (n.z = i.z + t(n._, i._), n.m = n.z - o) : n.z = o; } else i && (n.z = i.z + t(n._, i._)); n.parent.A = (function (n, e, r) { if (e) { for (var i, o = n, a = n, u = e, c = o.parent.children[0], f = o.m, s = a.m, l = u.m, h = c.m; u = Rp(u), o = Dp(o), u && o;)c = Dp(c), (a = Rp(a)).a = n, (i = u.z + l - o.z - f + t(u._, o._)) > 0 && (Fp(qp(u, n, r), n, i), f += i, s += i), l += u.m, f += o.m, h += c.m, s += a.m; u && !Rp(a) && (a.t = u, a.m += l - s), o && !Dp(c) && (c.t = o, c.m += f - h, r = n); } return r; }(n, i, n.parent.A || r[0])); } function a(t) { t._.x = t.z + t.parent.m, t.m += t.parent.m; } function u(t) { t.x *= n, t.y = t.depth * e; } return i.separation = function (n) { return arguments.length ? (t = n, i) : t; }, i.size = function (t) { return arguments.length ? (r = !1, n = +t[0], e = +t[1], i) : r ? null : [n, e]; }, i.nodeSize = function (t) { return arguments.length ? (r = !0, n = +t[0], e = +t[1], i) : r ? [n, e] : null; }, i; }, t.treemap = function () { let t = Yp; let n = !1; let e = 1; let r = 1; let i = [0]; let o = np; let a = np; let u = np; let c = np; let f = np; function s(t) { return t.x0 = t.y0 = 0, t.x1 = e, t.y1 = r, t.eachBefore(l), i = [0], n && t.eachBefore(Tp), t; } function l(n) { let e = i[n.depth]; let r = n.x0 + e; let s = n.y0 + e; let l = n.x1 - e; let h = n.y1 - e; l < r && (r = l = (r + l) / 2), h < s && (s = h = (s + h) / 2), n.x0 = r, n.y0 = s, n.x1 = l, n.y1 = h, n.children && (e = i[n.depth + 1] = o(n) / 2, r += f(n) - e, s += a(n) - e, (l -= u(n) - e) < r && (r = l = (r + l) / 2), (h -= c(n) - e) < s && (s = h = (s + h) / 2), t(n, r, s, l, h)); } return s.round = function (t) { return arguments.length ? (n = !!t, s) : n; }, s.size = function (t) { return arguments.length ? (e = +t[0], r = +t[1], s) : [e, r]; }, s.tile = function (n) { return arguments.length ? (t = tp(n), s) : t; }, s.padding = function (t) { return arguments.length ? s.paddingInner(t).paddingOuter(t) : s.paddingInner(); }, s.paddingInner = function (t) { return arguments.length ? (o = typeof t === 'function' ? t : ep(+t), s) : o; }, s.paddingOuter = function (t) { return arguments.length ? s.paddingTop(t).paddingRight(t).paddingBottom(t).paddingLeft(t) : s.paddingTop(); }, s.paddingTop = function (t) { return arguments.length ? (a = typeof t === 'function' ? t : ep(+t), s) : a; }, s.paddingRight = function (t) { return arguments.length ? (u = typeof t === 'function' ? t : ep(+t), s) : u; }, s.paddingBottom = function (t) { return arguments.length ? (c = typeof t === 'function' ? t : ep(+t), s) : c; }, s.paddingLeft = function (t) { return arguments.length ? (f = typeof t === 'function' ? t : ep(+t), s) : f; }, s; }, t.treemapBinary = function (t, n, e, r, i) { let o; let a; const u = t.children; const c = u.length; const f = new Array(c + 1); for (f[0] = a = o = 0; o < c; ++o)f[o + 1] = a += u[o].value; !(function t(n, e, r, i, o, a, c) { if (n >= e - 1) { const s = u[n]; return s.x0 = i, s.y0 = o, s.x1 = a, void (s.y1 = c); } const l = f[n]; const h = r / 2 + l; let d = n + 1; let p = e - 1; for (;d < p;) { const g = d + p >>> 1; f[g] < h ? d = g + 1 : p = g; }h - f[d - 1] < f[d] - h && n + 1 < d && --d; const y = f[d] - l; const v = r - y; if (a - i > c - o) { const _ = r ? (i * v + a * y) / r : a; t(n, d, y, i, o, _, c), t(d, e, v, _, o, a, c); } else { const b = r ? (o * v + c * y) / r : c; t(n, d, y, i, o, a, b), t(d, e, v, i, b, a, c); } }(0, c, t.value, n, e, r, i)); }, t.treemapDice = Ap, t.treemapResquarify = Lp, t.treemapSlice = Ip, t.treemapSliceDice = function (t, n, e, r, i) { (1 & t.depth ? Ip : Ap)(t, n, e, r, i); }, t.treemapSquarify = Yp, t.tsv = Mc, t.tsvFormat = lc, t.tsvFormatBody = hc, t.tsvFormatRow = pc, t.tsvFormatRows = dc, t.tsvFormatValue = gc, t.tsvParse = fc, t.tsvParseRows = sc, t.union = function (...t) { const n = new InternSet(); for (const e of t) for (const t of e)n.add(t); return n; }, t.unixDay = _y, t.unixDays = by, t.utcDay = yy, t.utcDays = vy, t.utcFriday = By, t.utcFridays = Vy, t.utcHour = hy, t.utcHours = dy, t.utcMillisecond = Wg, t.utcMilliseconds = Zg, t.utcMinute = cy, t.utcMinutes = fy, t.utcMonday = qy, t.utcMondays = jy, t.utcMonth = Qy, t.utcMonths = Jy, t.utcSaturday = Yy, t.utcSaturdays = Wy, t.utcSecond = iy, t.utcSeconds = oy, t.utcSunday = Fy, t.utcSundays = Ly, t.utcThursday = Oy, t.utcThursdays = Gy, t.utcTickInterval = av, t.utcTicks = ov, t.utcTuesday = Uy, t.utcTuesdays = Hy, t.utcWednesday = Iy, t.utcWednesdays = Xy, t.utcWeek = Fy, t.utcWeeks = Ly, t.utcYear = ev, t.utcYears = rv, t.variance = x, t.version = '7.9.0', t.window = pn, t.xml = Sc, t.zip = function () { return gt(arguments); }, t.zoom = function () {
    let t; let n; let e; let r = Ew; let i = Nw; let o = zw; let a = Cw; let u = Pw; const c = [0, 1 / 0]; const f = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]]; let s = 250; let l = ri; const h = $t('start', 'zoom', 'end'); const d = 500; const p = 150; let g = 0; let y = 10; function v(t) {
      t.property('__zoom', kw).on('wheel.zoom', T, { passive: !1 }).on('mousedown.zoom', A).on('dblclick.zoom', S)
        .filter(u)
        .on('touchstart.zoom', E)
        .on('touchmove.zoom', N)
        .on('touchend.zoom touchcancel.zoom', k)
        .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');
    } function _(t, n) { return (n = Math.max(c[0], Math.min(c[1], n))) === t.k ? t : new ww(n, t.x, t.y); } function b(t, n, e) { const r = n[0] - e[0] * t.k; const i = n[1] - e[1] * t.k; return r === t.x && i === t.y ? t : new ww(t.k, r, i); } function m(t) { return [(+t[0][0] + +t[1][0]) / 2, (+t[0][1] + +t[1][1]) / 2]; } function x(t, n, e, r) { t.on('start.zoom', (function () { w(this, arguments).event(r).start(); })).on('interrupt.zoom end.zoom', (function () { w(this, arguments).event(r).end(); })).tween('zoom', (function () { const t = this; const o = arguments; const a = w(t, o).event(r); const u = i.apply(t, o); const c = e == null ? m(u) : typeof e === 'function' ? e.apply(t, o) : e; const f = Math.max(u[1][0] - u[0][0], u[1][1] - u[0][1]); const s = t.__zoom; const h = typeof n === 'function' ? n.apply(t, o) : n; const d = l(s.invert(c).concat(f / s.k), h.invert(c).concat(f / h.k)); return function (t) { if (t === 1)t = h; else { const n = d(t); const e = f / n[2]; t = new ww(e, c[0] - n[0] * e, c[1] - n[1] * e); }a.zoom(null, t); }; })); } function w(t, n, e) { return !e && t.__zooming || new M(t, n); } function M(t, n) { this.that = t, this.args = n, this.active = 0, this.sourceEvent = null, this.extent = i.apply(t, n), this.taps = 0; } function T(t, ...n) { if (r.apply(this, arguments)) { const e = w(this, n).event(t); const i = this.__zoom; const u = Math.max(c[0], Math.min(c[1], i.k * 2 ** a.apply(this, arguments))); const s = ne(t); if (e.wheel)e.mouse[0][0] === s[0] && e.mouse[0][1] === s[1] || (e.mouse[1] = i.invert(e.mouse[0] = s)), clearTimeout(e.wheel); else { if (i.k === u) return; e.mouse = [s, i.invert(s)], Gi(this), e.start(); }Sw(t), e.wheel = setTimeout((() => { e.wheel = null, e.end(); }), p), e.zoom('mouse', o(b(_(i, u), e.mouse[0], e.mouse[1]), e.extent, f)); } } function A(t, ...n) { if (!e && r.apply(this, arguments)) { const i = t.currentTarget; const a = w(this, n, !0).event(t); var u = Zn(t.view).on('mousemove.zoom', ((t) => { if (Sw(t), !a.moved) { const n = t.clientX - s; const e = t.clientY - l; a.moved = n * n + e * e > g; }a.event(t).zoom('mouse', o(b(a.that.__zoom, a.mouse[0] = ne(t, i), a.mouse[1]), a.extent, f)); }), !0).on('mouseup.zoom', ((t) => { u.on('mousemove.zoom mouseup.zoom', null), ue(t.view, a.moved), Sw(t), a.event(t).end(); }), !0); const c = ne(t, i); var s = t.clientX; var l = t.clientY; ae(t.view), Aw(t), a.mouse = [c, this.__zoom.invert(c)], Gi(this), a.start(); } } function S(t, ...n) { if (r.apply(this, arguments)) { const e = this.__zoom; const a = ne(t.changedTouches ? t.changedTouches[0] : t, this); const u = e.invert(a); const c = e.k * (t.shiftKey ? 0.5 : 2); const l = o(b(_(e, c), a, u), i.apply(this, n), f); Sw(t), s > 0 ? Zn(this).transition().duration(s).call(x, l, a, t) : Zn(this).call(v.transform, l, a, t); } } function E(e, ...i) { if (r.apply(this, arguments)) { let o; let a; let u; let c; const f = e.touches; const s = f.length; const l = w(this, i, e.changedTouches.length === s).event(e); for (Aw(e), a = 0; a < s; ++a)c = [c = ne(u = f[a], this), this.__zoom.invert(c), u.identifier], l.touch0 ? l.touch1 || l.touch0[2] === c[2] || (l.touch1 = c, l.taps = 0) : (l.touch0 = c, o = !0, l.taps = 1 + !!t); t && (t = clearTimeout(t)), o && (l.taps < 2 && (n = c[0], t = setTimeout((() => { t = null; }), d)), Gi(this), l.start()); } } function N(t, ...n) { if (this.__zooming) { let e; let r; let i; let a; const u = w(this, n).event(t); const c = t.changedTouches; const s = c.length; for (Sw(t), e = 0; e < s; ++e)i = ne(r = c[e], this), u.touch0 && u.touch0[2] === r.identifier ? u.touch0[0] = i : u.touch1 && u.touch1[2] === r.identifier && (u.touch1[0] = i); if (r = u.that.__zoom, u.touch1) { const l = u.touch0[0]; const h = u.touch0[1]; const d = u.touch1[0]; const p = u.touch1[1]; var g = (g = d[0] - l[0]) * g + (g = d[1] - l[1]) * g; var y = (y = p[0] - h[0]) * y + (y = p[1] - h[1]) * y; r = _(r, Math.sqrt(g / y)), i = [(l[0] + d[0]) / 2, (l[1] + d[1]) / 2], a = [(h[0] + p[0]) / 2, (h[1] + p[1]) / 2]; } else { if (!u.touch0) return; i = u.touch0[0], a = u.touch0[1]; }u.zoom('touch', o(b(r, i, a), u.extent, f)); } } function k(t, ...r) { if (this.__zooming) { let i; let o; const a = w(this, r).event(t); const u = t.changedTouches; const c = u.length; for (Aw(t), e && clearTimeout(e), e = setTimeout((() => { e = null; }), d), i = 0; i < c; ++i)o = u[i], a.touch0 && a.touch0[2] === o.identifier ? delete a.touch0 : a.touch1 && a.touch1[2] === o.identifier && delete a.touch1; if (a.touch1 && !a.touch0 && (a.touch0 = a.touch1, delete a.touch1), a.touch0)a.touch0[1] = this.__zoom.invert(a.touch0[0]); else if (a.end(), a.taps === 2 && (o = ne(o, this), Math.hypot(n[0] - o[0], n[1] - o[1]) < y)) { const f = Zn(this).on('dblclick.zoom'); f && f.apply(this, arguments); } } } return v.transform = function (t, n, e, r) {
      const i = t.selection ? t.selection() : t; i.property('__zoom', kw), t !== i ? x(t, n, e, r) : i.interrupt().each((function () {
        w(this, arguments).event(r).start().zoom(null, typeof n === 'function' ? n.apply(this, arguments) : n)
          .end();
      }));
    }, v.scaleBy = function (t, n, e, r) { v.scaleTo(t, (function () { return this.__zoom.k * (typeof n === 'function' ? n.apply(this, arguments) : n); }), e, r); }, v.scaleTo = function (t, n, e, r) { v.transform(t, (function () { const t = i.apply(this, arguments); const r = this.__zoom; const a = e == null ? m(t) : typeof e === 'function' ? e.apply(this, arguments) : e; const u = r.invert(a); const c = typeof n === 'function' ? n.apply(this, arguments) : n; return o(b(_(r, c), a, u), t, f); }), e, r); }, v.translateBy = function (t, n, e, r) { v.transform(t, (function () { return o(this.__zoom.translate(typeof n === 'function' ? n.apply(this, arguments) : n, typeof e === 'function' ? e.apply(this, arguments) : e), i.apply(this, arguments), f); }), null, r); }, v.translateTo = function (t, n, e, r, a) { v.transform(t, (function () { const t = i.apply(this, arguments); const a = this.__zoom; const u = r == null ? m(t) : typeof r === 'function' ? r.apply(this, arguments) : r; return o(Mw.translate(u[0], u[1]).scale(a.k).translate(typeof n === 'function' ? -n.apply(this, arguments) : -n, typeof e === 'function' ? -e.apply(this, arguments) : -e), t, f); }), r, a); }, M.prototype = {
      event(t) { return t && (this.sourceEvent = t), this; },
      start() { return ++this.active == 1 && (this.that.__zooming = this, this.emit('start')), this; },
      zoom(t, n) { return this.mouse && t !== 'mouse' && (this.mouse[1] = n.invert(this.mouse[0])), this.touch0 && t !== 'touch' && (this.touch0[1] = n.invert(this.touch0[0])), this.touch1 && t !== 'touch' && (this.touch1[1] = n.invert(this.touch1[0])), this.that.__zoom = n, this.emit('zoom'), this; },
      end() { return --this.active == 0 && (delete this.that.__zooming, this.emit('end')), this; },
      emit(t) {
        const n = Zn(this.that).datum(); h.call(t, this.that, new xw(t, {
          sourceEvent: this.sourceEvent, target: v, type: t, transform: this.that.__zoom, dispatch: h,
        }), n);
      },
    }, v.wheelDelta = function (t) { return arguments.length ? (a = typeof t === 'function' ? t : mw(+t), v) : a; }, v.filter = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : mw(!!t), v) : r; }, v.touchable = function (t) { return arguments.length ? (u = typeof t === 'function' ? t : mw(!!t), v) : u; }, v.extent = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : mw([[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]]), v) : i; }, v.scaleExtent = function (t) { return arguments.length ? (c[0] = +t[0], c[1] = +t[1], v) : [c[0], c[1]]; }, v.translateExtent = function (t) { return arguments.length ? (f[0][0] = +t[0][0], f[1][0] = +t[1][0], f[0][1] = +t[0][1], f[1][1] = +t[1][1], v) : [[f[0][0], f[0][1]], [f[1][0], f[1][1]]]; }, v.constrain = function (t) { return arguments.length ? (o = t, v) : o; }, v.duration = function (t) { return arguments.length ? (s = +t, v) : s; }, v.interpolate = function (t) { return arguments.length ? (l = t, v) : l; }, v.on = function () { const t = h.on.apply(h, arguments); return t === h ? v : t; }, v.clickDistance = function (t) { return arguments.length ? (g = (t = +t) * t, v) : Math.sqrt(g); }, v.tapDistance = function (t) { return arguments.length ? (y = +t, v) : y; }, v;
  }, t.zoomIdentity = Mw, t.zoomTransform = Tw;
})));
